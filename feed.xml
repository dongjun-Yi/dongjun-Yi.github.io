<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://dongjun-yi.github.io/</id><title>동준이 블로그</title><subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle> <updated>2025-01-27T13:44:09+08:00</updated> <author> <name>이동준</name> <uri>https://dongjun-yi.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://dongjun-yi.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://dongjun-yi.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator> <rights> © 2025 이동준 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>SQL SELECT 데이터 검색</title><link href="https://dongjun-yi.github.io/posts/SQL_Select/" rel="alternate" type="text/html" title="SQL SELECT 데이터 검색" /><published>2025-01-27T00:00:00+08:00</published> <updated>2025-01-27T00:00:00+08:00</updated> <id>https://dongjun-yi.github.io/posts/SQL_Select/</id> <content src="https://dongjun-yi.github.io/posts/SQL_Select/" /> <author> <name>{"name"=>"dongjun-Yi"}</name> </author> <category term="database" /> <summary> Select select는 테이블에서 열을 지정하여 선택한다. where where는 테이블에서 행을 지정하여 선택한다. where는 조건식을 지정해 조건식은 참 또는 거짓의 진리값을 반환하는 식으로 조건식에서 만족한 행만 결과값으로 반환한다. select * from sample21 where no=2; // where 조건식 사용 select와 from 구의 내부 처리 순서 where구에서 행 선택, select구에서 열 선택은 데이터베이스 서버 내부에서 where → select구 순서로 처리된다. like where 식에 =을... </summary> </entry> <entry><title>React 라이프사이클</title><link href="https://dongjun-yi.github.io/posts/ReactLifeCycle/" rel="alternate" type="text/html" title="React 라이프사이클" /><published>2024-11-09T00:00:00+08:00</published> <updated>2024-11-09T00:00:00+08:00</updated> <id>https://dongjun-yi.github.io/posts/ReactLifeCycle/</id> <content src="https://dongjun-yi.github.io/posts/ReactLifeCycle/" /> <author> <name>{"name"=>"dongjun-Yi"}</name> </author> <category term="react" /> <summary> 라이플사이클이란? 컴포넌트가 생성되고, 업데이트, 제거 까지의 과정을 말한다. 리액트 라이플사이클에서는 3가지의 단계로 나뉜다: 마운트(Mount), 업데이트(Update), 언마운트(Unmount) Mount : 컴포넌트가 생성되어 DOM에 추가되는 단계다. 이는 화면에 처음으로 랜더링 될 때를 말한다. Update : 컴포넌트가 상태(state)나 props의 변화로 인해 재렌더링되는 단계다. 화면에 리랜더링 될때를 말한다. Unmount : 컴포넌트가 DOM에서 제거되는 단계다. 이는 화면에서 사라질때를 말한다. 이 라이플 사이클 단계별로 컴포넌트들이 각각 다른 수행하도록 만드는 것을 라이플 사이클 제어라고 한다. 이 라이프 사이클 제어는 React의 hook인 useEf... </summary> </entry> <entry><title>@Mock, @MockBean, @InjectMocks</title><link href="https://dongjun-yi.github.io/posts/Mock/" rel="alternate" type="text/html" title="@Mock, @MockBean, @InjectMocks" /><published>2024-09-16T00:00:00+08:00</published> <updated>2024-09-16T00:00:00+08:00</updated> <id>https://dongjun-yi.github.io/posts/Mock/</id> <content src="https://dongjun-yi.github.io/posts/Mock/" /> <author> <name>{"name"=>"dongjun-Yi"}</name> </author> <category term="test" /> <summary> Spring에서 단위테스트와 통합테스트시 객체 생성에 사용하는 애너테이션인 @Mock, @MockBean, @InjectMocks에 대해서 알아보자. @Mock Mock 객체를 직접 생성하여 사용하는 애너테이션으로, 스프링 컨텍스트와 관련이 없는 순수 객체이다. @MockBean Mock 객체를 생성하고, Bean이므로 스프링 컨텍스트에 등록을 한다. 스프링 컨텍스트에 직접 생성하므로, 관련된 객체와 연결하여 통합 테스트를 수행할 수 있다. ​ 통합 테스트에서 컨테이너가 필요하고, 빈을 등록해야한다면 @MockBean을 통해 등록해주면 되고, 단위 테스트 같이 컨테이너가 필요 없다면 @Mock을 통해 객체를 만들어주면 된다. @Inj... </summary> </entry> <entry><title>[Clean Code] 7장. 오류 처리</title><link href="https://dongjun-yi.github.io/posts/CleanCode_ErrorHandling/" rel="alternate" type="text/html" title="[Clean Code] 7장. 오류 처리" /><published>2024-08-15T00:00:00+08:00</published> <updated>2024-08-15T12:51:06+08:00</updated> <id>https://dongjun-yi.github.io/posts/CleanCode_ErrorHandling/</id> <content src="https://dongjun-yi.github.io/posts/CleanCode_ErrorHandling/" /> <author> <name>{"name"=>"dongjun-Yi"}</name> </author> <category term="clean code" /> <summary> Use Exceptions Rather than Return Codes DeviceController.java public class DeviceController { ... public void sendShutDown() { DeviceHandle handle = getHandle(DEV1); // Check the state of the device if (handle != DeviceHandle.INVALID) { // Save the device status to the record field retrieveDeviceRecord(handle); // If not suspended, shut down if (record.getStatus() != DEVICE_SU... </summary> </entry> <entry><title>[JavaScript] Common Js 와 ES6 Module</title><link href="https://dongjun-yi.github.io/posts/CommonJs&amp;ES6Module/" rel="alternate" type="text/html" title="[JavaScript] Common Js 와 ES6 Module" /><published>2024-07-07T00:00:00+08:00</published> <updated>2024-07-07T00:00:00+08:00</updated> <id>https://dongjun-yi.github.io/posts/CommonJs&amp;ES6Module/</id> <content src="https://dongjun-yi.github.io/posts/CommonJs&amp;ES6Module/" /> <author> <name>{"name"=>"dongjun-Yi"}</name> </author> <category term="javascript" /> <summary> 자바스크립트의 모듈 시스템은 코드를 분리해 유지보수성을 높여준다. 모듈 시스템 중 가장 대표적인 Common JS와 ES6 Module 시스템에 대해서 알아보자. Common JS Common JS는 NodeJS에서 주로 사용되는 모듈 시스템으로 require와 export 키워드를 통해 모듈을 가져오고 내보낼 수 있다. 예제로 숫자를 더하고 빼는 기능을 모듈화하여 math.js를 사용해보는 기능을 만들면 아래와 같다. math.js function add(a, b) { return a + b; } function sub(a, b) { return a - b; } module.exports = { add, sub } main.js const moduleData = requir... </summary> </entry> </feed>
