# 그리디 문제라고 판단하여 최대한 많이 나누면 최소 횟수연산을 구할줄 알았지만 이 문제는 나누는 값이 2,3,5로 3가지가 있기 때문에 최대한 많이 나누는 방법으로 생각하면 안된다.
# 피보나치 수열처럼 중복되는 부부문제가 있다고 생각하여 다이나믹 프로그래밍으로 접급해야 한다.
x = int(input())
cnt = 0

while x != 1:
  n = x
  if n % 5 == 0:
    x /= 5
    cnt += 1
  elif n % 3 == 0:
    x /= 3
    cnt += 1
  elif n % 2 == 0:
    x /= 2
    cnt += 1
  else:
    x -= 1
    cnt += 1

print(x)

# 풀이
x = int(input())

# d[0]은 최적의 값을 찾을 필요가 없는 값이니 0으로 두고 1부터 세서 (d[0] ~ d[30001]) 30000개를 생성하려는 목적
d = [0] * 30001

# 2부터 세는 이유는 1을 입력받으면 계산횟수는 0이므로 1을 생략하고 2부터 시작한다.
for i in range(2, x + 1):
  d[i] = d[i - 1] + 1

  if i % 2 == 0:
    d[i] = min(d[i], d[i // 2] + 1)

  if i % 3 == 0:
    d[i] = min(d[i], d[i // 3] + 1)

  if i % 5 == 0:
    d[i] = min(d[i], d[i // 5] + 1)

print(d[x])