---
title: "[데이터베이스] 정규화"
author:
  name: dongjun-Yi
categories: [database]
tags: [database]
render_with_liquid: false
---
## 정규화(normalization)란?

---

정규화란 **불필요한 데이터의 중복을 피하기 위해 스키마를 분해**하는데, 이 과정을 **정규화**라고 한다.

## 정규형의 종류

---

**정규화**는 테이블에 대한 **삽입, 삭제, 수정 등의 연산으로 인해 발생할 수 있는 이상현상을 방지**해준다.
그리고 각 단계별 정규화 과정을 통해 분해된 테이블들을 **정규형(normal form)**이라고 한다.

![Untitled.png](/assets/images/Normalization/Untitled.png)

정규형에는 **1차 정규형** 부터 **5차 정규형**까지 있으며 정규형의 차수가 높아질수록 더 많은 제약들이 가해진다. 이외에도 특수한 정규형인 보이스-코드 정규형이 있다. 일반적으로 데이터베이스를 설계할 때는 3**차 정규형이나 보이스-코드 정규형까지만을 고려한다.**

## 함수적 종속

---

정규형을 이해하기 위해서는 함수적 종속 이론에 대한 이해가 필요하다.
**함수적 종속(functional dependency)**이란 무결성 제약의 한 종류로서, **키의 개념을 일반화**한 것이다. 이는 테이블 내에서 **필드 간의 관계성을 표현한 것**이며, **데이터 중복의 발생 여부를 파악하는 데 중요한 역할**을 한다.

| stu_id | resident_id | name | year | dept_id | dept_name |
| --- | --- | --- | --- | --- | --- |
| 1292001 | 900424-1825409 | 김광식 | 3 | 920 | 컴퓨터공학과 |
| 1292002 | 900305-1730021 | 김정현 | 3 | 920 | 컴퓨터공학과 |
| 1292003 | 891021-2308302 | 김현정 | 4 | 920 | 컴퓨터공학과 |
| 1292301 | 890902-2704012 | 김현정 | 2 | 923 | 컴퓨터공학과 |
| 1292303 | 910715-1524390 | 박광수 | 3 | 923 | 컴퓨터공학과 |
| 1292305 | 921011-1809003 | 김우주 | 4 | 923 | 컴퓨터공학과 |
| 1292501 | 900825-1506390 | 박철수 | 3 | 925 | 컴퓨터공학과 |

함수적 종속은 **하나의 테이블 내에서 필드들 간의 관계**로 정의된다. **하나의 레코드에서 특정 필드의 값이 주어지면 특정 다른 필드의 값이 자동적으로 정해지는 경우**가 있다. 예를 들어 위의 테이블에서 기본키는 `stu_id`라고 가정하자. 여기서 레코드의 `stu_id`를 알면 `name`과 dept_name을 찾아낼 수 있다. 
다시 말해서, 학번이 동일한 두 개의 레코드가 존재한다면 이름과 학과명 둘다 동일하게 된다. 그 이유는 `name`과 `dept_name`의 값은 `stu_id`에 의존적이기 때문이다. **이 경우 `name`과 `dept_name` 각각은 `stu_id`에 함수적으로 종속된다고 말한다.**

### 함수적 종속

👉 테이블 R에서 X와 Y를 각각 R에서 정의된 필드들의 부분 집합이라고 하자. 이때 Y의 값이 동일한 임의의 레코드의 쌍인 t1, t2에 대해서 Y의 값도 동일하다고 하면 **Y는 X에 함수적으로 종속**된다고 한다. 표기는 다음과 같이 표현한다. 
X → Y

**Y는 X에 함수적으로 종속된다** 라는 표현은 역으로 X는 Y를 함수적으로 결정한다 를 의미한다. 이때 X를 **결정자(determinant)**라고 하고, Y를 **종속자(dependent)**라고 한다. 위의 테이블에서 함수적 종속 관계는 다음과 같이 표현할 수 있다.

- stu_id → name
- stu_id → resident_id
- resident_id → stu_id
- stu_id → dept_name
- resident_id → dept_name

## 1차 정규형

---

**테이블 R에 속한 모든 도메인이 원자값(atomic value)만으로 구성되어 있다면 R은 1차 정규형이다.**

| stu_id | title | grade | dept_name | office |
| --- | --- | --- | --- | --- |
| 1292001 | 전산개론 | B+ | 컴퓨터공학과 | 920 |
| 1292001 | 데이터베이스 | A+ | 컴퓨터공학과 | 920 |
| 1292001 | 운영체제 | A | 컴퓨터공학과 | 920 |
| 1292002 | 자료구조 | A | 컴퓨터공학과 | 920 |
| 1292002 | 데이터베이스 | B+ | 컴퓨터공학과 | 920 |
| 1292002 | 알고리즘 | C+ | 컴퓨터공학과 | 920 |
| 1292003 | 인공지능 | A+ | 컴퓨터공학과 | 920 |
| 1292003 | 자료구조 | C+ | 산업공학과 | 923 |

위의 테이블을 보면 각 학생이 수강하고 있는 과목과 그 과목에 대한 성적, 그리고 학생이 소속된 학과와 사무실 정보를 저장한다. 여기서 기본키는 `(stu_id, title)`의 복합키로 구성된다.
여기서는 모든 도메인이 **원자값으로 이주어져 있어 1차 정규형**임을 알 수 있다.

## 2차 정규형

---

**테이블 R에서 키가 아닌 모든 필드가 키에 대해 함수적으로 종속되며, 키의 부분집합이 결정자가 되는 부분 종속이 존재하지 않으면, R은 2차 정규형이다.**

이 말을 이해하기 위해서 앞서 본 테이블을 보자. 위의 테이블에서는 3가지의 이상현상이 발생할 수 있다.

1. **삽입 이상** : 학번이 ‘1292502’인 학생이 ‘전자공학과’에 소속된다는 사실을 삽입하려면, 최소한 그 학생이 하나의 과목을 수강해야만 가능하다. 그렇지 않으면 삽입이 불가능하다.
2. **삭제 이상** : 테이블에서 `stu_id`가 ‘1292301’인 학생이 ‘자료구조’를 수강한다는 사실을 삭제하면 이 학생이 ‘산업공학과’에 소속된다는 정보까지 동시에 삭제된다. 뿐만 아니라. 이 학생이 ‘산업공학과’에 유일한 학생이라면 학과 정보도 같이 삭제 된다.
3. **수정 이상 :** 학번이 ‘1292001’인 학생의 소속이 ‘컴퓨터공학과’에서 ‘산업공학과’로 변경 되면 이 사실에 해당하는 모든 레코드에 대해서 반영되어야 한다.

### 위의 문제점이 발생하는 이유가 무엇일까?

👉 위의 테이블에서 **`stu_id`는 기본키의 일부인데, 이 필드가 기본키에 포함하지 않은 필드인 `dept_name`을 함수적으로 결정**해서 이다. 함수적으로 결정한다는 뜻은 여기서 `stu_id`를 알면 `dept_name`을 찾을 수 있듯이 `dept_name`은 `stu_id`에 의존적이라서 함수적으로 결정된다. 따라서 `dept_name`필드는 기본키인 `(stu_id, title)`에 의해 영향을 받지 않고 오직 `stu_id`에 의해서만 결정된다. 결국 `dept_name`은 이 테이블에서 **중복되어 표현될 수 밖에 없어 이상현상**이 발생한 것이다.

![Untitled.png](/assets/images/Normalization/1.png)

이와 같이 키에 포함되지 않은 필드가 키의 부분집합에 종속되는 것을 부분 종속(partial dependency)이라고 한다. 위의 그림은 부분 종속의 예를 보여주며, 이 그림에서 X는 키의 부분집합이고, X → A가 성립하면 A는 키에 부분 종속된다.

이 이상현상을 해결하기 위해서는 부분 종속에 해당하는 **결정자**와 **종속자**를 별도의 테이블로 분리시켜야 한다. 위의 그림에서는 X`(stu_id)`와 A`(dept_name)`를 하나의 독립된 테이블로 구성하고, 본래의 테이블에서 A`(dept_name)`를 제외하면 된다.

**student 테이블**

| stu_id | dept_name | office |
| --- | --- | --- |
| 1292001 | 컴퓨터공학과 | 920 |
| 1292002 | 컴퓨터공학과 | 920 |
| 1292003 | 컴퓨터공학과 | 920 |
| 1292301 | 산업공학과 | 923 |

**takes 테이블**

| stu_id | title | grade |
| --- | --- | --- |
| 1292001 | 전산개론 | B+ |
| 1292001 | 데이터베이스 | A+ |
| 1292001 | 운영체제 | A |
| 1292002 | 자료구조 | A |
| 1292002 | 데이터베이스 | B+ |
| 1292002 | 알고리즘 | C+ |
| 1292003 | 인공지능 | A+ |
| 1292003 | 자료구조 | C+ |

분해된 student와 takes 테이블에는 다음과 같이 함수적 종속이 그대로 보존된다.

### student 테이블

- stu_id → dept_name
- dept_name - >office

### takes 테이블

- (stu_id, title) → grade

그래서 **2차 정규형**은 다음과 같다.

> **테이블 R에서 키가 아닌 모든 필드가 키에 대해 함수적으로 종속되며, 키의 부분 집합이 결정자가 되는 부분 족속이 존재하지 않으면 R은 2차 정규형이다. (하나의 필드로 키가 정의되는 경우는 모두 2차 정규형이다.)**
> 

## 3차 정규형

---

그러나 위의 테이블 중 student 테이블에서는 **이행적 함수적 종속**이 발생한다.

### 이행적 종속이란?

👉 **이행적 종속**이란 테이블 R에 필드 집합 X, Y, Z가 있다고 할때, X→Y 이고 Y→Z이면 이행적 함수적 종속이라고 한다.

위의 예제에서는 `office`는 `dept_name`에 종속되며 다시 `dept_name`은 `stu_id`에 종속되어서 레코드는 중복된다. 그래서 이 student 테이블을 아래와 같이 2개로 분해하여 이행 종속을 제거해야 한다.

**student 테이블**

| stu_id | dept_name |
| --- | --- |
| 1292001 | 컴퓨터공학과 |
| 1292002 | 컴퓨터공학과 |
| 1292003 | 컴퓨터공학과 |
| 1292301 | 산업공학과 |

**department 테이블**

| dept_name | office |
| --- | --- |
| 컴퓨터공학과 | 920 |
| 산업공학과 | 923 |

분해된 student와 department 테이블에는 다음과 같이 함수적 종속이 존재함을 알 수 있다.

### student 테이블

- stu_id → dept_name

### department 테이블

- dept_name - > office

따라서 **3차 정규형**은 다음과 같다.

> **테이블 R이 2차 정규형이면서 키에 속하지 않은 모든 필드가 기본키에 이행 종속되지 않는다면, R은 3차 정규형이다.**
> 

<aside>
📖 references 데이터베이스의 이해 [이한미디어]

</aside>