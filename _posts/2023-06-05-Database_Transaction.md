---
title: "[Database] 트랜잭션"
author:
  name: dongjun-Yi
categories: [database]
tags: [database]
render_with_liquid: false
---
## 트랜잭션(Transaction)이란?

---

하나의 논리적인 작업 단위를 구성하는 연산들의 집합을 **트랜잭션(Transcation)**이라 한다. 즉, 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위이다.

예를 들어 A계좌에서 B계좌로 일정 금액을 이체한다고 했을 때의 순서를 보자

1. A는 A계좌의 잔액을 확인하고 현재 금액에서 인출할 금액을 뺀 나머지 금액을 다시 저장한다. 
2. B계좌의 잔액을 읽어 들인 후 이체된 금액을 더하고 그 합을 다시 저장하면 계좌이체가 완려된다.

> 위의 과정들을 모두 합쳐져 ‘계좌이체’라는 하나의 작업 단위를 구성하게 된다.
> 

## 트랜잭션의 필요성

---

문제가 발생하지 않도록 사전에 방지하기 위해 필요하다.

계좌이체의 예를 들어보면 현금 인출기를 작동하는 도중에 기계 오류나 정전 등 예기치 않은 상황이 발생하여 기계가 멈추는 경우가 있을 것이다. 이때 만약 내 계좌에서 돈이 빠져나갔지만 상대방 계좌에는 이체가 되지 않는 문제가 발생할 수 도 있다. 이 문제가 발생하지 않기 위해 트랜잭션이 필요하다.

**즉, 트랜잭션은 내 계좌에서 금액이 빠져나가기 전 상태로 돌아가던지, 아니면 상대방 계좌로 이체가 성공적으로 끝나도록 보장해준다.**

## ACID

---

트랜잭션은 반드시 지켜야 할 중요한 조건이 있는데, DBMS는 이러한 조건들이 항상 만족되도록 보장해 주어야 한다. 이 조건들은 각 단어의 첫 문자를 따서 ACID라고 부른다.

- **Atomicity(원자성)** : 트랜잭션이 시작되면 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지, 아니면 실행되기 전 상태로 되돌아가야 한다. **(All or nothing)**
- **Consistency(일관성)** : 트랜잭션이 시작되기 전에 데이터베이스 내용이 일관된 상태라면 트랜잭션이 종료된 후에도 데이터베이스의 내용이 일관된 상태로 유지되어야 한다.
- **Isolation(고립성)** : 트랜잭션이 실행하는 과정에서 갱신한 데이터는 트랜잭션이 완료될때까지 다른 트랜잭션이 참조할 수 없다.
- **Durability(지속성)** : 트랜잭션이 성공적으로 완료되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장되어야 한다.

### Atomicity

- 트랜잭션은 성공하거나 실패하거나 둘중 하나여야 한다.

![Untitled.png](/assets/images/Database Transaction/Untitled.png)

예를 들어서 A,B 모두 400원이 있고, 100원을 이체한다고 가정했을 때

- 트랜잭션이 성공할 경우 A계좌 잔액 : 300원, B계좌 잔액 : 500원
- 트랜잭션이 실패할 경우 A계좌 잔액 : 400원, B계좌 잔액 : 400원  → 원래의 상태로 되돌려 놓아야 한다.

<aside>
📖 이와 같이 트랜잭션이 실행 도중 중단된 상태로 남아 있지 않아야 한다는 조건을 의미!

</aside>

### Consistency

- 트랜잭션 완료 후에도 데이터베이스가 일관된 상태로 유지해야 한다.

![Untitled1.png](/assets/images/Database Transaction/Untitled 1.png)

예를 들어서 계좌이체 과정에서 일관성을 살펴보면 계좌이체 전후 두 계좌의 잔액의 합이 일정해야 한다.

이 일관된 상태를 판단은 DBM가 인지할 수 없고 개발자가 판단해야 한다. 따라서 일관성 유지되도록 트랜잭션을 정의하는 것은 개발자의 책임이다.

위와 같이 트랜잭션을 인출과 입금 두개로 나눠서 트랜잭션을 구성할 경우 계좌이체를 위해서는 인출 트랜잭션과 입금 트랜잭션이 모두 완료되어야 한다. 그러나 인출 트랜잭션만 완료된 상태에서는 A계좌와 B계좌의 잔액의 합이 같지 않다. 따라서 위의 트랜잭션은 일관성을 유지 못한 트랜잭션이다.!

### Isolation

- 트랜잭션이 실행하는 도중에 변경한 데이터는 이 트랜잭션이 완료될 때까지 다른 트랜잭션이 참조하지 못하게 하는 특성이다.

![Untitled2.png](/assets/images/Database Transaction/Untitled 2.png)

위와 같이 A계좌에서 B계좌로 d원을 이체하는 트랜잭션 (a)와 A와 B의 잔액 합을 계산하는 트랜잭션이 동시에 실행했다고 가정해보자. 위의 번호대로 1,2,3을 실행되면 두 계좌의 합을 계산하는 (b)의 트랜잭션은 잘못된 결과가 나올거다. 그 이유는 (b)에서 읽은 A와 B의 잔액이 일시적으로 일관된 상태가 아니기 때문이다.

이를 해결하기 위해서은 동시에 실행되는 각 트랜잭션을 순차적으로 실행되도록 하는 것이다. 그러나, 다중 프로그래밍 환경에서 트랜잭션을 순차적으로 실행하면 성능면에서 많은 문제가 있어서 이 문제를 해결하기 위해서는 트랜잭션을 동시에 실행하면서 상호간에 간섭이 일어나지 않도록 하는 기법이 필요하다. 따라서 고립성이 만족되어야 하며, 고립성이 만족되는지 확인하는 방법은 동시에 실행하는 트랜잭션들 실행 결과가 순차적으로 실행된 결과와 동일하다면 고립성이 만족 되는 것이다.

### Durability

- 트랜잭션 완로 후에도 그 결과가 영구적으로 보존되어야 한다.

트랜잭션이 완료되면 주기억장치가 아닌 디스크와 같은 보조기억장치에 저장하거나 시스템 장애가 회복되고 난 후에 어떠한 형태로든지 그 데이터를 복구할 수 있어야 한다.

## 트랜잭션의 상태

---

![Untitled](%E1%84%90%E1%85%B3%E1%84%85%E1%85%A2%E1%86%AB%E1%84%8C%E1%85%A2%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20d409ab79eaf044aba6c4c078adbc7e28/Untitled%202.png)

1. 트랜잭션이 시작되면 **동작**상태로 집입
2. 이후 모든 연산이 성공적으로 실행되면 **부분완료** 집입한다.
    - 아직 부분완료인 이유는 이 결과가 곧바로 디스크에 영구적으로 저장되는 것이 아니기 때문이다.
3. 부분완료 상태에서 트랜잭션의 결과가 영구적으로 보존될 수 있다고 보장되면 최종적으로 **완료** 상태에 도달한다. (완료되면 지속성에 의해 취소는 불가)
4. 만약 동작 상태나 부분완료 상태에서 트랜잭션이 더 이상 정상적인 실행을 하지 못할 경우 **실패** 상태에 도달한다.
5. 만약 실패하면 원자성에 의해 실행되기 이전의 상태로 되돌려 놓아야 한다. 이러한 과정을 복귀(Rollback)라 하며 복귀가 이루어 지면 트랜잭션은 최종적으로 **중단** 상태에 도달한다.
6. 중단 상태에 도달한 트랜잭션은 상황에 따라 다시 시작될 수도 있고 더 이상 실행되지 않고 완전히 종료 될 수 있는데, 트랜잭션이 완료되거나 중단되었을 때 **종료** 되었다고 한다.

![Untitled3.png](/assets/images/Database Transaction/Untitled 3.png)

**트랜잭션의 상태 전이도**

<aside>
📖 references 데이터베이스의 이해 [이한미디어]

</aside>