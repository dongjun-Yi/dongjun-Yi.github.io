[ { "title": "SQL SELECT 데이터 검색", "url": "/posts/SQL_Select/", "categories": "database", "tags": "sql, database", "date": "2025-01-27 00:00:00 +0800", "snippet": " Select select는 테이블에서 열을 지정하여 선택한다. where where는 테이블에서 행을 지정하여 선택한다. where는 조건식을 지정해 조건식은 참 또는 거짓의 진리값을 반환하는 식으로 조건식에서 만족한 행만 결과값으로 반환한다. select * from sampl...", "content": " Select select는 테이블에서 열을 지정하여 선택한다. where where는 테이블에서 행을 지정하여 선택한다. where는 조건식을 지정해 조건식은 참 또는 거짓의 진리값을 반환하는 식으로 조건식에서 만족한 행만 결과값으로 반환한다. select * from sample21 where no=2; // where 조건식 사용 select와 from 구의 내부 처리 순서 where구에서 행 선택, select구에서 열 선택은 데이터베이스 서버 내부에서 where → select구 순서로 처리된다. like where 식에 =을 사용하면 셀의 데이터 값이 완전일치하는지를 비교하고 like를 사용하면 특정문자나 문자열이 포함되어있는지를 검색 가능하다. // where 조건식에 like술어를 사용하여 text열이 sql을 포함하는 행을 검색 select * from sample25 where text like '%sql%'; order by 검색 결과의 행 순서를 바꿀 수 있다. order by 구로 정렬하고 싶은 열을 지정한다. 이 열은 기준이되며 이 값을 기준으로 행 순서가 결정된다. 내림차순(DESC), 오름차순(ASC, default) 2가지가 존재한다. select * from sample31 order by age; order by 실행순서 where → select→ order by limit 반환되는 데이터의 개수를 제한할 수 있다. limit은 where, order by, limit순으로 실행된다. 집계와 서브쿼리SQL은 데이터 집합을 다루는 언어다. 여기서 집합의 개수나 합계와 같은 값을 알고 싶으면 집계함수를 사용하면된다.count(집합), sum(집합), avg(집합), max(집합), min(집합)집계함수는 인수로 집합을 지정한다. 집계함수의 특징은 복수의 값(집합)에서 하나의 값을 반환한다. 즉, select구에서 집계함수를 쓰면 하나의 행만 추출된다. group by group by를 통해 집계함수로 넘겨줄 집합을 그룹으로 나눈다. group by로 열을 지정하여 그룹화하면 같은 행이 하나의 그룹으로 묶이게 된다. // group by 구에 name열을 지정해 그룹화 select name from sample51 group by name; having 집계함수의 조건식을 지정하려면 having을 사용해야 하며 where 구에 사용하면 에러가 난다. 이유는 where구가 group by보다 먼저 처리되기 때문에 집계함수 조건은 where에서 사용 불가능하다. 내부 처리 순서 where → group by→ having → select → order by → limit group by에 지정한 열 이외의 열은 집계함수를 사용하지 않은 채 select 구에 기술할 수 없다. select no, name, quantity from sample51 group by name; 이유는 group by는 반환되는 결과가 그룹 당 하나의 행이 반환되는 데, 만약 지정되지 않은 열로 추출하면 그룹에 여러 값 중 어느 값을 선택해야되는지를 모르기 때문에 에러가 발생한다. 서브 쿼리 서브쿼리는 select 명령에 의한 질의문으로 SQL문안에 지정하는 하부 select 명령으로 지정한다. select from sample54 where a = (select MIN(a) from sample54); 스칼라 값 스칼라 값이란 하나의 값을 반환하는 뜻으로 서브 쿼리에서 단 하나의 값을 반환한다면 스칼라 서브쿼리라고 부른다. where 구에서 스칼라 값을 반환하는 서브 쿼리는 = 연산자로 비교할 수 있다. select from sample54 where a = (select MIN(a) from sample54); 위와 같이 서브쿼리에 스칼라 값을 반환하도록 하여 비교 연산자를 통해 서브 쿼리로 사용하기 간편하다. 상관 서브쿼리 상관 서브 쿼리란 메인 쿼리문과 서브 쿼리가 특정 관계를 맺는 것을 상관 서브쿼리라고 부른다. // 부모 테이블의 행을 셀값을 이용해 서브쿼리에서 비교연산자를 사용하기 때문에 이는 상관서브쿼리다. update sample551 set a='있음' where exists (select * from sample 552 where no2=no); 📖 references SQL 첫걸음 - 한빛미디어" }, { "title": "React 라이프사이클", "url": "/posts/ReactLifeCycle/", "categories": "react", "tags": "react, javascript", "date": "2024-11-09 00:00:00 +0800", "snippet": "라이플사이클이란?컴포넌트가 생성되고, 업데이트, 제거 까지의 과정을 말한다. 리액트 라이플사이클에서는 3가지의 단계로 나뉜다: 마운트(Mount), 업데이트(Update), 언마운트(Unmount) Mount : 컴포넌트가 생성되어 DOM에 추가되는 단계다. 이는 화면에 처음으로 랜더링 될 때를 말한다. Update : 컴포넌트가 상태(state)...", "content": "라이플사이클이란?컴포넌트가 생성되고, 업데이트, 제거 까지의 과정을 말한다. 리액트 라이플사이클에서는 3가지의 단계로 나뉜다: 마운트(Mount), 업데이트(Update), 언마운트(Unmount) Mount : 컴포넌트가 생성되어 DOM에 추가되는 단계다. 이는 화면에 처음으로 랜더링 될 때를 말한다. Update : 컴포넌트가 상태(state)나 props의 변화로 인해 재렌더링되는 단계다. 화면에 리랜더링 될때를 말한다. Unmount : 컴포넌트가 DOM에서 제거되는 단계다. 이는 화면에서 사라질때를 말한다.이 라이플 사이클 단계별로 컴포넌트들이 각각 다른 수행하도록 만드는 것을 라이플 사이클 제어라고 한다. 이 라이프 사이클 제어는 React의 hook인 useEffect를 이용해 제어할 수 있다.useEffectuseEffect란 React 컴포넌트의 Side Effect를 제어하는 React hook이다. 여기서 Side Effect란 컴포넌트의 동작에 따라 파생되는 여러 효과를 말한다. 예를 들어 컴포넌트 내부에 값이 변경되면 콘솔에 변경된 값을 출력하는 행위는 변경되는 행위에서 파생되는 Side Effect가 된다. 이러한 Side Effect를 제어하고 싶을 때는 useEffect를 통해 제어할 수 있다.// mountuseEffect(()=&gt; { console.log('mount');}, []);// updateuseEffect(()=&gt; { console.log('update');});//unmountuseEffect(() =&gt; {\treturn () =&gt; {\t console.log('unmount'); //Clean up };}, []); mount: useEffect로 의존성 배열에 빈 배열을 주게 되면 처음 랜더링 시점에만 useEffect에 setup 부분의 코드가 실행된다. update : 의존성 인자에 빈 값을 주게되면 화면이 랜더링 될 때마다 호출된다. unmount: useEffect에 return문을 사용하면 화면에서 컴포넌트가 사라질 때 실행하게 된다.📖 references [https://ko.react.dev/reference/react/useEffect](https://ko.react.dev/reference/react/useEffect)[https://github.com/Wavez/react-hooks-lifecycle](https://github.com/Wavez/react-hooks-lifecycle)" }, { "title": "@Mock, @MockBean, @InjectMocks", "url": "/posts/Mock/", "categories": "test", "tags": "test, junit, java", "date": "2024-09-16 00:00:00 +0800", "snippet": "Spring에서 단위테스트와 통합테스트시 객체 생성에 사용하는 애너테이션인 @Mock, @MockBean, @InjectMocks에 대해서 알아보자.@Mock Mock 객체를 직접 생성하여 사용하는 애너테이션으로, 스프링 컨텍스트와 관련이 없는 순수 객체이다.@MockBean Mock 객체를 생성하고, Bean이므로 스프링 컨텍스트에 등록을 한다....", "content": "Spring에서 단위테스트와 통합테스트시 객체 생성에 사용하는 애너테이션인 @Mock, @MockBean, @InjectMocks에 대해서 알아보자.@Mock Mock 객체를 직접 생성하여 사용하는 애너테이션으로, 스프링 컨텍스트와 관련이 없는 순수 객체이다.@MockBean Mock 객체를 생성하고, Bean이므로 스프링 컨텍스트에 등록을 한다. 스프링 컨텍스트에 직접 생성하므로, 관련된 객체와 연결하여 통합 테스트를 수행할 수 있다. ​통합 테스트에서 컨테이너가 필요하고, 빈을 등록해야한다면 @MockBean을 통해 등록해주면 되고,단위 테스트 같이 컨테이너가 필요 없다면 @Mock을 통해 객체를 만들어주면 된다.@InjectMocks테스트 대상 클래스에 자동으로 @Mock으로 만들어진 객체들을 의존성으로 주입하여, 클래스 내부에서 의존하는 객체들을 Mock으로 대체합니다.@RunWith(MockitoJUnitRunner.class)public class UserServiceTest { // 실제 테스트 대상 클래스 @InjectMocks private UserService userService; // UserService에서 의존하고 있는 Repository 클래스에 대한 Mock 객체 @Mock private UserRepository userRepository; @Test public void testGetUserById() { when(userRepository.findById(1L)).thenReturn(Optional.of(new User(1L, \"John\"))); User user = userService.getUserById(1L); assertEquals(\"John\", user.getName()); }}@InjectMocks는 아래와 같이 생성자에 인자로 인스턴스를 주입해는 코드와 같다.UserRepository userRepository = new UserRepository();UserService userService = new UserService(userRepoistory);" }, { "title": "[Clean Code] 7장. 오류 처리", "url": "/posts/CleanCode_ErrorHandling/", "categories": "clean code", "tags": "clean code", "date": "2024-08-15 00:00:00 +0800", "snippet": "Use Exceptions Rather than Return CodesDeviceController.javapublic class DeviceController {\t...\tpublic void sendShutDown() {\t\tDeviceHandle handle = getHandle(DEV1); // Check the state of the device...", "content": "Use Exceptions Rather than Return CodesDeviceController.javapublic class DeviceController {\t...\tpublic void sendShutDown() {\t\tDeviceHandle handle = getHandle(DEV1); // Check the state of the device\t\tif (handle != DeviceHandle.INVALID) {\t\t\t// Save the device status to the record field retrieveDeviceRecord(handle);\t\t\t// If not suspended, shut down\t\t\tif (record.getStatus() != DEVICE_SUSPENDED) {\t\t\t\tpauseDevice(handle);\t\t\t\tclearDeviceWorkQueue(handle);\t\t\t\tcloseDevice(handle);\t\t\t} else {\t\t\t\tlogger.log(\"Device suspended. Unable to shut down\");\t\t\t}\t\t} else {\t\t\tlogger.log(\"Invalid handle for: \" + DEV1.toString()); }\t...}위의 코드를 보면 함수 호출자는 함수를 호출 후 에러 발생 여부를 체크를 하는 코드가 있다. 이러한 에러 체크는 호출자에게 혼란을 준다.함수의 호출자는 에러 발생여부를 확인하기 위해 오류 코드를 작성하는 것보다 에러를 마주했을 때는 예외를 발생시키는게 더 낫다. 그러면 호출자의 코드는 더 깔끔해지게 되고 이러한 오류 처리는 논리가 모호해지지 않는다.DeviceController.javapublic class DeviceController {\t...\tpublic void sendShutDown() {\t\ttry {\t\t\ttryToShutDown();\t\t} catch (DeviceShutDownError e) {\t\t\tlogger.log(e);\t\t}\t}\tprivate void tryToShutDown() throws DeviceShutDownError {\t\tDeviceHandle handle = getHandle(DEV1);\t\tDeviceRecord record = retrieveDeviceRecord(handle);\t\tpauseDevice(handle);\t\tclearDeviceWorkQueue(handle);\t\tcloseDevice(handle);\t}\tprivate DeviceHandle getHandle(DeviceID id) { ...\t\tthrow new DeviceShutDownError(\"Invalid handle for: \" + id.toString());\t\t...\t}\t...}위와 같이 예외를 발생시키는 코드는 중요한 2가지가 있다. 장치 종료 알고리즘과 오류처리가 나뉘어 작성되어 2개의 관심사가 분리된 것이다. 따라서 코드를 읽게 되면 2개의 기능을 독립적으로 작동되는 것을 살펴볼 수 있다.Write your Try-catch-Finally Statement Firsttry 블럭은 마치 트랜잭션과 같다. 트랜잭션은 데이터베이스에서 수행하는 여러 작업들이 하나의 단위로 처리되어 모두 성공하거나 모두 실패하는 것을 보장하는 개념인데 try 블럭도 성공과 실패에 대해서 명확하게 이루어지기 때문에 이는 트랜잭션과 유사하다.try 블럭에서 비즈니스 로직을 수행하고, 코드가 실행에 실패할 수 있다는 예측이 가능하다.파일을 열고 파일의 내용을 읽는 예를 살펴보자.@Test(expected = StorageException.class)public void retrieveSectionShouldThrowOnInvalidFileName() {\tsectionStore.retrieveSection(\"invalid - file\");}public List&lt;RecordedGrip&gt; retrieveSection(String sectionName) {\t// dummy return until we have a real implementation\treturn new ArrayList&lt;RecordedGrip&gt;();}위의 코드는 실행하면 빈 객체를 반환하기 때문에 테스트에 실패한다.public List&lt;RecordedGrip&gt; retrieveSection(String sectionName) {\ttry {\t FileInputStream stream = new FileInputStream(sectionName)\t} catch (Exception e) {\t throw new StorageException(\"retrieval error\", e);\t}\t return new ArrayList&lt;RecordedGrip&gt;();}위의 코드는 예외 처리를 했기 때문에 테스트가 통과한다. 여기서 더 예외 처리를 구체적으로 다루면 다음과 같이 코드를 바꿀 수 있다.public List&lt;RecordedGrip&gt; retrieveSection(String sectionName) {\ttry {\t FileInputStream stream = new FileInputStream(sectionName);\t\tstream.close();\t} catch (FileNotFoundException e) {\t throw new StorageException(\"retrieval error”, e);\t}\treturn new ArrayList&lt;RecordedGrip&gt;();}위의 코드는 예외 클래스를 FileNotFoundException으로 선언하여 예외 범위를 좁혀 파일을 찾을 수 없는 에러에 대해서 헨들링을 하여 코드를 읽을 때 어떤 상황에서 예외가 발생할지 예측할 수 있게 된다.이처럼 예외를 강제하는 테스트를 작성하고 테스트를 만족하기 위한 catch 블럭을 작성하게 되면트랜잭션의 범위를 구축하고 해당 범위에서 발생하는 예외를 짐작할 수 있어 트랜잭션 특성을 유지하는데 도움을 준다.Use Unchecked ExceptionCheked Exception의 경우 예외 처리를 강제한다. 이 특징 때문에 Checked Exception은 확장에는 열려있고 수정에는 닫혀있어야 하는 OCP 원칙을 위반한다.예를 들어 3단계에 거쳐서 호출하는 구조를 가진 함수에서 만약 가장 늦게 불리는 함수가 Checked Exception 예외를 발생시키는 코드로 수정됐다면, 이는 상위 호출자의 함수에도 throws를 추가해줘야 되기 때문에 하위 함수 때문에 모든 상위 함수들이 수정해야 하는 문제가 발생하게 된다.이러한 전파되는 수정사항 때문에 캡슐화의 외부로 부터 세부사항을 숨기는 특징을 지키지 못해 하위 레벨의 세부 사항을 상위 레벨에서 알아야 하도록 강제되는 것이다.Checked Exception은 가끔 중요한 라이브러리를 작성할 때 반드시 잡아야 하는 오류를 처리할 때 유용하지만 일반적인 애플리케이션 개발에서는 의존성 비용이 장점들보다 더 많이 든다.Provide Context with Exceptions예외를 발생시킬 때 충분한 정보가 담긴 에러 메세지를 만들고 예외를 발생시켜야 에러가 발생했을 때 원인을 찾기 쉽게 된다.Define Exception Classes in Terms of a Caller’s NeedsACMEPort port = new ACMEPort(12);try { port.open();} catch (DeviceResponseException e) { reportPortError(e); logger.log(\"Device response exception\", e);} catch (ATM1212UnlockedException e) { reportPortError(e); logger.log(\"Unlock exception\", e);} catch (GMXError e) { reportPortError(e); logger.log(\"Device response exception\");} finally {\t...}LocalPort port = new LocalPort(12);t시ry { port.open();} catch (PortDeviceFailure e) { reportError(e); logger.log(e.getMessage(), e);} finally {\t...}public class LocalPort {\tprivate ACMEPort innerPort;\tpublic LocalPort(int portNumber) {\t innerPort = new ACMEPort(portNumber);\t}\tpublic void open() {\t\ttry {\t\t innerPort.open();\t\t} catch (DeviceResponseException e) {\t\t throw new PortDeviceFailure(e);\t\t} catch (ATM1212UnlockedException e) { \t\t throw new PortDeviceFailure(e);\t\t} catch (GMXError e) {\t\t throw new PortDeviceFailure(e);\t\t}\t}\t...}위의 코드와 아래 코드를 비교해보면 위에 코드는 하나의 try문에 여러 catch문이 선언되어 있지만 두번째 코드에서는 Third-party Library를 이용한 API 안에 예외처리를 해두어 외부로부터 세부구현을 숨기고 실제 port를 open하는 로직에 대해서만 try catch문을 작성한 것이다. 이렇게 되면 코드를 더 간소화하고 예외를 발생시키는 클래스를 정의하여 어떤 예외가 발생하는 지를 명확하게 알 수 있다. 따라서 하나의 예외 클래스로 여러 오류를 처리할 수 있으면 단일 예외 클래스를 사용하고, 특정 예외를 구분하여 처리할 필요가 있다면, 서로 다른 예외 클래스를 정의하는 것이 더 나은 선택이다.Define the Normal Flowtry {\tMealExpenses expenses = expenseReportDAO.getMeals(employee.getID());\tm_total += expenses.getTotal();} catch(MealExpensesNotFound e) {\tm_total += getMealPerDiem();}위의 코드는 식사비가 지출된 경우 총 금액에 더하는 로직이다. 만약 식사비가 지출이 되지 않았다면 그날의 일당 식사량을 총액에 더하는 로직이다. 이 코드는 예외로 인해 기본 비즈니스 로직까지 복잡해지는 경우이며 특별한 경우를 다루는 코드를 작성해야 단순해진다.public class PerDiemMealExpenses implements MealExpenses {\tpublic int getTotal() {\t\t// return the per diem default\t}}위 코드는 항상 MealExpense Object를 반환하는 코드이며, 만약 식사비 지출이 없다면 일당 식사비를 가진 객체를 반환하게 된다.위와 같은 패턴을 Special Case Pattern이라고 한다. 특별한 경우를 다루는 클래스로, 이렇게 특별한 경우를 클래스안에 함수로 감싸 예외 처리를 안해도 되게 된다.Don’t Return NullNull을 반환하지 마라.public void registerItem(Item item) {\tif (item != null) {\t\tItemRegistry registry = peristentStore.getItemRegistry();\t\tif (registry != null) {\t\t\tItem existing = registry.getItem(item.getID());\t\t\tif (existing.getBillingPeriod().hasRetailOwner()) {\t\t\t\texisting.register(item);\t\t\t}\t\t}\t}}Null값이 return되는 것을 예상하고 예외 처리를 수행하고 있다. 이는 호출자에게 문제를 떠넘기는 구조로, 만약 Null을 넘기는 로직을 작성하게 되면 이대신 예외를 던지거나, Special Case Object를 반환하도록 하라.List&lt;Employee&gt; employees = getEmployees();if (employees != null) {\tfor(Employee e : employees) {\t\ttotalPay += e.getPay();\t}}만약 위와 같이 Null를 반환하는 getEmployees()를 Null이 아닌 빈 리스트로 반환한고 하면 코드는 다음과 같이 수정된다.List&lt;Employee&gt; employees = getEmployees();for(Employee e : employees) { // if check문이 없어짐.\ttotalPay += e.getPay();}public List&lt;Employee&gt; getEmployees() {\tif( .. there are no employees .. )\t\treturn Collections.emptyList();}위와 같이 작성하면 NullPointException을 최소화하고 코드가 깔끔해진다.Dont Pass Null함수의 매개변수나 return 값으로 Null 값을 전달하면 안된다. 왜냐하면 이는 NullPointException을 발생할 뿐만 아니라 이를 예외처리 한들 Runtime Error가 발생하기 때문에 Null 값을 넘겨주는 로직은 지양해야 한다.Robert C. Martin - Clean Code_ A Handbook of Agile Software Craftsmanship-Prentice Hall (2008)" }, { "title": "[JavaScript] Common Js 와 ES6 Module", "url": "/posts/CommonJs&ES6Module/", "categories": "javascript", "tags": "javascript, nodejs", "date": "2024-07-07 00:00:00 +0800", "snippet": "자바스크립트의 모듈 시스템은 코드를 분리해 유지보수성을 높여준다. 모듈 시스템 중 가장 대표적인 Common JS와 ES6 Module 시스템에 대해서 알아보자.Common JSCommon JS는 NodeJS에서 주로 사용되는 모듈 시스템으로 require와 export 키워드를 통해 모듈을 가져오고 내보낼 수 있다.예제로 숫자를 더하고 빼는 기능을 ...", "content": "자바스크립트의 모듈 시스템은 코드를 분리해 유지보수성을 높여준다. 모듈 시스템 중 가장 대표적인 Common JS와 ES6 Module 시스템에 대해서 알아보자.Common JSCommon JS는 NodeJS에서 주로 사용되는 모듈 시스템으로 require와 export 키워드를 통해 모듈을 가져오고 내보낼 수 있다.예제로 숫자를 더하고 빼는 기능을 모듈화하여 math.js를 사용해보는 기능을 만들면 아래와 같다.math.jsfunction add(a, b) {\treturn a + b;}function sub(a, b) {\treturn a - b;}module.exports = {\tadd,\tsub}main.jsconst moduleData = require('./math.js');console.log(moduleData.add(1, 2)); // 3console.log(moduleData.minus(1, 2)); // -1math.js에서 add와 minus 함수를 정의하고 이를 export로 내보내 main.js에서 이 내보낸 모듈을 require()로 사용할 수 있다. 그러면 require로 받아온 모듈에서 객체형태로 받아 add와 minus를 사용할 수 있다.ES6 ModuleES6 Module 시스템은 ECMAScript 2015(ES6)에서 처음 나온 모듈 시스템으로 import와 export 키워드를 통해 모듈을 내보내고 가져올 수 있다.자바스크립트는 기본적으로 CommonJS 방식을 사용하고 있기 때문에 ES6 Module 시스템을 사용하려면 package.json에서 type을 module로 명시해줘야 사용할 수 있다.package.json{ ... \"type\": \"module\"}위와 같이 package.json을 설정해줬다면 더하고 뺴는 기능을 math.js 에 정의하고 main.js에서 이를 가져다 쓰는 코드를 작성하면 아래와 같이 작성할 수 있다.math.jsfunction add(a, b) {\treturn a + b;}function sub(a, b) {\treturn a - b;}export { add, sub};main.jsimport { add, sub} from './math.js';console.log(add(1, 2)); // 3console.log(minus(1, 2)); // -1ES6 모듈 시스템에서 모듈의 함수를 내보낼때는 export를 사용하고 이를 가져다 쓰려면 import를 통해 사용할 수 있다.이처럼 자바스크립트에서는 모듈 시스템을 사용하여 코드를 조직화하고 분리하여 유지보수성을 높일 수 있다." }, { "title": "[알고리즘] 이항계수", "url": "/posts/BinominalCoefficient/", "categories": "algorithm, java", "tags": "algorithm, java", "date": "2024-05-18 00:00:00 +0800", "snippet": "이항계수란 2개의 항을 전개하여 계수를 나타낸 수를 이항계수라고 한다.예를 들어 (a+b)^3을 전개한다고 했을 때 (a+b)^3 = a^3 + 2a^2b + 2ab^2 + b^3이 되어 계수는 {1, 3, 3, 1}이 된다. 이런식으로 이항계수들을 전개하다보면 다음과 같은 파스칼 삼각형의 모습이 나온다.이항계수를 다르게 해석하면 b를 뽑는 개수로 이...", "content": "이항계수란 2개의 항을 전개하여 계수를 나타낸 수를 이항계수라고 한다.예를 들어 (a+b)^3을 전개한다고 했을 때 (a+b)^3 = a^3 + 2a^2b + 2ab^2 + b^3이 되어 계수는 {1, 3, 3, 1}이 된다. 이런식으로 이항계수들을 전개하다보면 다음과 같은 파스칼 삼각형의 모습이 나온다.이항계수를 다르게 해석하면 b를 뽑는 개수로 이해할 수 있다. a^3는 b를 0개 뽑는 것 2a^2b는 b를 1개 뽑는 것 2ab^2는 b를 2개 뽑는 것 b^3는 b를 3개 뽑는 것이와 같이 b가 n개 있을 때 이들 중에서 r개를 뽑는 것으로 조합 공식을 이용해 이항 계수를 구할 수 있다.즉, 이항계수를 구하려면 조합 공식을 이용해 구할 수 있고, 이를 코드로 구현하면 다음과 같다.public class Combination1 { public static void main(String[] args) { int n = 5; int k = 2; System.out.println(f(n) / (f(k) * f(n - k))); } static int f(int n) { if (n == 0) return 1; return n * f(n - 1); }}위의 코드는 팩토리얼을 이용해 구한 코드다. 이렇게 구하는 방법외에도 조합의 성질을 이용해 이항계수를 알아낼 수 있다. 바로 파스칼의 법칙을 이용해 이항계수를 구할 수 있다.위와 같은 공식을 이용해 이항계수를 구할 수 있으며 n과 r이 같거나 r = 0이면 1이 나온다는 것을 이용해 알고리즘을 작성할 수 있다.public class Combination2 { public static void main(String[] args) { System.out.println(combi(5, 2)); // 5C2 } static int combi(int n, int r) { if (n == r || r == 0) { return 1; } return combi(n - 1, r - 1) + combi(n - 1, r); }}위와 같이 재귀를 이용해 조합 경우의 수를 구할 수 있지만, 위는 n과 r의 숫자가 커지게 되면 재귀 형식으로 인해 스택오버플로가 발생할 수 있다. 따라서 여기에 다이나믹 프로그래밍의 핵심 아이디어인 메모리제이션을 이용해 이미 구한 조합의 경우의 수는 기록해두어 재방문하게 되면 기록한 값을 되돌려주는 방식으로 오버플로 문제를 해결할 수 있다.public class Combination3 { static int[][] D = new int[6][6]; // DP 테이블 public static void main(String[] args) { System.out.println(combi(5, 2)); // 5C2 } static int combi(int n, int r) { if (D[n][r] &gt; 0) return D[n][r]; if (n == r || r == 0) { return D[n][r] = 1; } return combi(n - 1, r - 1) + combi(n - 1, r); }}위의 코드는 다이나믹 프로그래밍으로 풀이한 방식이며, 그 중 탑다운 방법을 이용해 구현한 것이다. 탑다운 말고도 바텀업으로도 구현이 가능해 재귀를 이용하지 않고 반복문으로 풀이도 할 수 있다.public class Combination4 { static int[][] D = new int[6][6]; public static void main(String[] args) { for (int i = 0; i &lt;= 5; i++) { D[i][1] = i; D[i][0] = 1; D[i][i] = 1; } for (int i = 2; i &lt;= 5; i++) { for (int j = 1; j &lt; i; j++) { D[i][j] = D[i - 1][j] + D[i - 1][j - 1]; // nCr = n-1Cr-1 + n-1Cr } } System.out.println(D[5][2]); }}정리이항계수를 구하는 알고리즘을 공부하다가 조합의 공식과 성질을 이용해 다양한 방식으로 알아낼 수 있어 해결하는 방법을 정리해봤다. 재귀 형식으로 구현한 코드는 입력이 극한으로 커지게 되면 스택 오버플로가 발생하게 되고, 이를 방지하기 위해 다이나믹 프로그래밍의 메모리제이션을 이용해 해결할 수 있다. 또한 스택 오버플로 방지를 위해 탑다운 방식이 아닌 바텀업 방식으로 반복문을 사용해 구현할 수 있는 것을 확인해봤다." }, { "title": "[Java] Generics", "url": "/posts/Generics/", "categories": "java", "tags": "java", "date": "2024-04-01 00:00:00 +0800", "snippet": "Generics란 클래스나 컬렉션 자료구조에 타입 체크를 통해 타입 안정성을 제공해주는 기능이다. 여기서 타입 안정성이란 저장되는 곳에 의도하지 않은 데이터 타입 삽입을 막고 잘못된 형변환의 오류를 방지하는 것을 말한다.Generics의 필요성list에 문자열을 저장하고 데이터를 꺼낼때 형변환을 명시해 조회하는 예를 들어보자.List list = ne...", "content": "Generics란 클래스나 컬렉션 자료구조에 타입 체크를 통해 타입 안정성을 제공해주는 기능이다. 여기서 타입 안정성이란 저장되는 곳에 의도하지 않은 데이터 타입 삽입을 막고 잘못된 형변환의 오류를 방지하는 것을 말한다.Generics의 필요성list에 문자열을 저장하고 데이터를 꺼낼때 형변환을 명시해 조회하는 예를 들어보자.List list = new LinkedList();list.add(\"abc\"); Integer i = (Integer) list.get(0);이 코드는 String 타입의 데이터를 List에서 값을 꺼낼 때 개발자가 잘못 형변환을 하여 참조변수 i에 Integer 타입으로 형변환하였다. 이는 컴파일시에는 문제가 없이 실행되지만 이 코드를 실행하면 ClassCastException이 발생하게 된다.@Test@DisplayName(\"Non Generics 타입으로 잘못 형변환하여 데이터를 조회할 시 ClassCastException이 발생한다.\")void NonGenericGetDataTest() { List list = new LinkedList(); list.add(\"abc\"); Assertions.assertThrows(ClassCastException.class, () -&gt; { Integer i = (Integer) list.get(0); });}이를 방지하고자 JDK1.5버전부터 Generics가 나오게 되고 클래스나 메서드에 Generics 타입으로 선언하게 되면 의도하지 않은 데이터 삽입을 막을 수 있다.List&lt;String&gt; list = new LinkedList();list.add(1); // Required type: String, Provided: intlist.add(\"abc\");Integer i = (Integer) list.get(0); // Inconvertible types; cannot cast 'java.lang.String' to 'java.lang.Integer'Generics를 사용하여 list에 String 타입만 다룰 수 있게 선언하게 되면 list에 int 타입 데이터를 삽입하면 컴파일러가 Required type: String, Provided: int라고 오류를 발생시킨다.또한 list에서 데이터를 조회할 때 Integer 타입으로 잘못 형변환시키게 되면 Inconvertible types; cannot cast 'java.lang.String' to 'java.lang.Integer'라고 오류가 발생한다.이렇게 Generics를 사용하면 런타임 때 발생할 오류를 컴파일 시에 오류를 발생시켜 개발자가 올바르게 코드를 수정할 수 있도록 도와준다.실제 bytecode로 확인해보면 다음과 같다.@Test@DisplayName(\"Generics을 사용한 데이터 조회\")void GenericsTest() { List&lt;String&gt; list = new LinkedList(); list.add(\"abc\"); String getString = list.get(0); Assertions.assertEquals(getString, \"abc\");} L2 LINENUMBER 32 L2 ALOAD 1 ICONST_0 INVOKEINTERFACE java/util/List.get (I)Ljava/lang/Object; (itf) CHECKCAST java/lang/String ASTORE 2아래 코드는 자바의 bytecode 일부분이며 list.get(0)을 수행하면 Object 타입으로 조회되는 데이터를 CHECKCAST 명령어를 통해 String 타입으로 컴파일러가 형변환을 수행해준다. 이 때문에 개발자는 코드로 직접 형변환하는 코드를 작성하지 않아도 됐던 것이다.이렇게 Generics를 사용하면 컴파일러가 컴파일 시 직접 형변환을 수행해주고 데이터에 대한 타입 체크를 수행해준다.정리Generics는 컴파일 타임 때 타입체크를 통해 타입 안정성을 제공해주는 기능이다. Generics의 핵심 개념은 런타임 시 발생하는 ClassCastException을 컴파일 타임으로 끌어와 미리 에러를 발생시켜 코드를 올바르게 수 정할 수 있도록 프로그램 예외 발생을 방지해주는 것이다. 이 개념은 컴파일러의 정적 타입 분석을 이용한 기능이며 Generics는 컴파일 언어의 특성을 활용한 개념임을 알게 되었다.📖 references https://www.baeldung.com/java-generics" }, { "title": "[알고리즘] 재귀", "url": "/posts/Recursion/", "categories": "algorithm", "tags": "algorithm, C", "date": "2024-03-21 00:00:00 +0800", "snippet": "프로그래밍의 반복 알고리즘에 사용되는 알고리즘은 크게 2가지가 있다. 하나는 반복문을 이용해 순회하는 방식이고, 다른 하나는 재귀를 이용한 방식이다. 재귀란 자기 자신을 호출하면서 반복적으로 수행하는 코드이다. 팩토리얼을 계산하는 알고리즘을 재귀 형식으로 구현해보자.위 알고리즘은 재귀형식으로 팩토리얼을 구하는 방식으로 Factorial()인 함수가 자...", "content": "프로그래밍의 반복 알고리즘에 사용되는 알고리즘은 크게 2가지가 있다. 하나는 반복문을 이용해 순회하는 방식이고, 다른 하나는 재귀를 이용한 방식이다. 재귀란 자기 자신을 호출하면서 반복적으로 수행하는 코드이다. 팩토리얼을 계산하는 알고리즘을 재귀 형식으로 구현해보자.위 알고리즘은 재귀형식으로 팩토리얼을 구하는 방식으로 Factorial()인 함수가 자기 자신을 호출하면서 값을 누적하는 것을 알 수 있다.재귀를 해결하려면 2가지의 과정이 필요하다. 첫번째로는 문제를 탑다운방식으로 나누고, 문제를 바텀탑방식으로 풀어야한다.재귀 코드 설계재귀형식으로 코드를 구현하려면 2가지 조건이 필요하다.Base Case : 문제를 해결해야 하는 조건General Case : 문제를 작은 문제로 사이즈를 줄여야 하는 조건모든 재귀 알고리즘은 반드시 Base Case를 포함해야 한다. 앞서 팩토리얼 예제에서는 Base Case가 factorial(0)이 되고, general case는 n X factorial(n-1)이 된다.따라서 재귀 알고리즘을 설계할때는 다음의 과정을 거치면된다. Base Case 정의 General Case 정의 Base Case와 General Case를 합친다.팩토리얼을 구하는 알고리즘을 재귀형식으로 구하면 다음과 같다.int resursiveFactorial(int n) { // base case if (n == 0) { return 1; } else { return n * recursiveFactorial(n - 1); // general case }}재귀 VS 반복문그럼 재귀와 반복문의 차이는 무엇일까? 차이를 알아보기 위해 팩토리얼을 구하는 코드를 반복문을 통해 구해보자.int iteraionFactorial(int n) {\tint sum = 1;\tfor (int i = 1; i &lt;= n; i++){\t sum *= i;\t}\treturn sum;}차이를 살펴보면 재귀를 이용한 방식은 지역변수 없이 코드가 구성되고 매번 다른 매개변수를 통해 코드가 반복되고 있다. 재귀로 코드를 구현하면 코드가 훨씬 단순하게 구성할 수 있다. 하지만 재귀를 사용할때 주의점이 있다.재귀의 한계재귀를 사용하면 추가적인 오버헤드가 발생한다. 왜냐하면 재귀는 자기 자신을 호출하기 때문에 Call Stack에 추가적인 메모리 할당이 필요하기 때문이다. 그래서 재귀는 일반적으로 반복문보다 더 느리게 동작하게 된다. 따라서 재귀를 구현하기 전에 먼저 주어진 공간과 시간안에 해결할 수 있는지, 재귀 방식의 코드가 더 짧고 이해하기 쉬운지를 고려하여 사용해야 한다.📖 references Richard F. Gilberg, Behrouz A. Forouzan - Data Structures_ A Pseudocode Approach with C(2004)" }, { "title": "서블릿", "url": "/posts/Servlet/", "categories": "java", "tags": "java, servlet", "date": "2024-03-07 00:00:00 +0800", "snippet": "웹 서버 VS 웹 애플리케이션 서버웹 서버는 정적인 리소스만 제공되는 서버다. 정적인 리소스는 HTML, CSS와 같은 즉시 응답 가능한 파일을 말한다. 반면 웹 애플리케이션 서버(WAS)는 동적인 웹 페이지를 만들고 응답해준다. WAS는 웹 서버가 할 수 있는 기능도 처리가 가능하며 비즈니스 로직을 수행할 수 있어 클라이언트에게 동적인 컨텐츠를 전달...", "content": "웹 서버 VS 웹 애플리케이션 서버웹 서버는 정적인 리소스만 제공되는 서버다. 정적인 리소스는 HTML, CSS와 같은 즉시 응답 가능한 파일을 말한다. 반면 웹 애플리케이션 서버(WAS)는 동적인 웹 페이지를 만들고 응답해준다. WAS는 웹 서버가 할 수 있는 기능도 처리가 가능하며 비즈니스 로직을 수행할 수 있어 클라이언트에게 동적인 컨텐츠를 전달할 수 있다. WAS의 대표적인 예로는 Tomcat, JBoss등이 있으며 Tomcat에서는 서블릿을 이용해 동적인 요청을 처리해준다.서블릿이란?서블릿이란 서버에서 실행되는 작은 자바 프로그램으로 동적인 컨텐츠를 제공할 수 있는 기능을 제공한다. 서블릿은 서블릿 컨테이너에 의해 관리되며 서블릿의 생명주기도 컨테이너가 관리하게 된다. 다음 그림은 서블릿의 생명주기를 나타낸다.생명주기 흐름을 나타내면 다음과 같다. init()으로 서블릿이 초기화 되어 생성된다. 서블릿 컨테이너가 일치하는 url에 해당하는 서블릿 스레드를 생성해 service()를 호출한다. destroy()로 서블릿이 종료된다.위의 과정이 일반적인 서블릿의 생명주기이며 서블릿 인터페이스는 다음 코드로 구성되어 있다.package javax.servlet; import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException; public interface Servlet { public void init(); public void service(HttpServletRequest request, HttpServletResponse response) throws IOException; public void destroy();}init(), service(), destroy()는 서블릿 인터페이스로 제공되는 메서드들로, 서블릿 생명주기를 이용해 필요시에 비즈니스 로직을 구성할 수 있다.클라이언트 요청과 응답 흐름서블릿은 클라이언트로부터 요청이 들어오면 서블릿 컨테이너에 의해 관리되게 된다. HTTP 요청이 오면 서블릿의 실행 흐름은 다음과 같다. 클라이언트로부터 HTTP 요청이 오면 서블릿 컨테이너가 요청온 URL가 매칭되는 서블릿이 존재하는지 확인한다. 서블릿 컨테이너는 HttpServletRequest, HttpServletResponse 객체를 생성하고 찾은 서블릿에게 스레드를 할당 해 매개변수로 요청과 응답 객체가 전달되어 service(request, response)를 호출한다. service()는 HTTP 메서드에 따라 해당되는 메서드를 찾아 실행한다. 서블릿은 클라이언트에게 응답을 반환해주고 서블릿의 생명주기는 끝나게 된다. 서블릿 컨테이너는 클라이언트의 요청마다 스레드를 생성해 서블릿에게 스레드를 할당한다. 따라서 서블릿을 사용할때는 스레드 동기화에 대한 문제가 생길 수 있어 공유되는 변수는 조심해서 사용해야 한다.📖 references Bryan Basham, Kathy Sierra, Bert Bates - Head First Servlets and JSP_ Passing the Sun Certified Web Component Developer Exam-O'Reilly Media (2008)" }, { "title": "Java Stream과 for 문", "url": "/posts/StreamAndForLoop/", "categories": "java", "tags": "java", "date": "2024-02-23 00:00:00 +0800", "snippet": "자바 Stream API를 이용해 코드를 구성하면 다양한 데이터 소스를 일관성있게 다룰 수 있다는 장점이 있어 가독성을 향상시키는 효과를 준다. 그럼 for문과 Stream API를 이용한 반복문은 성능의 차이가 있을까?for loop vs Stream비교를 위해 원시타입 int를 저장하는 배열을 하나 만들고, 배열에서 가장 큰 원소를 찾는 함수를 각...", "content": "자바 Stream API를 이용해 코드를 구성하면 다양한 데이터 소스를 일관성있게 다룰 수 있다는 장점이 있어 가독성을 향상시키는 효과를 준다. 그럼 for문과 Stream API를 이용한 반복문은 성능의 차이가 있을까?for loop vs Stream비교를 위해 원시타입 int를 저장하는 배열을 하나 만들고, 배열에서 가장 큰 원소를 찾는 함수를 각각 for-loop와 순차 스트림으로 만들어보자.int[] ints = new int[500000];int[] a = ints;int e = ints.length;int m1 = Integer.MIN_VALUE;long start1 = System.nanoTime();for (int i = 0; i &lt; e; i++) { // for loop if (a[i] &gt; m1) m1 = a[i];}long end1 = System.nanoTime();System.out.println(\"for-loop : \" + (end1 - start1) + \"ns\");long start2 = System.nanoTime();int m2 = Arrays.stream(ints) // stream .reduce(Integer.MIN_VALUE, Math::max);long end2 = System.nanoTime();System.out.println(\"sequential stream : \" + (end2 - start2) + \"ns\");for-loop : 4419500nssequential stream : 12006875nsfor loop과 stream을 비교해보니 결과가 매번 달랐지만 for문이 약 3배 차이로 빠르게 실행되었다. 그 이유는 JIT 컴파일러가 for문을 40년이상 다뤄와서 그만큼 최적화가 되어있었지만 stream은 2015년에 도입되어 아직 컴파일러가 최적화를 못했다는 것이다. 그러면 for문이 무조건 stream을 이용한 반복보다 좋을까? 그렇지 않다. 다음 예시를 통해 확인해보자.List&lt;Integer&gt; myList = new ArrayList(500000);int m3 = Integer.MIN_VALUE;long start3 = System.nanoTime();for (int i : myList) // for loop if (i &gt; m3) m3 = i;long end3 = System.nanoTime();System.out.println(\"for-loop wrapped Type : \" + (end3 - start3) + \"ns\");long start4 = System.nanoTime();int m4 = myList.stream() // stream .reduce(Integer.MIN_VALUE, Math::max);long end4 = System.nanoTime();System.out.println(\"sequential stream wrapped Type : \" + (end4 - start4) + \"ns\");for-loop wrapped Type : 181667nssequential stream wrapped Type : 1876333ns위의 코드는 원시타입 int가 아닌 Integer 타입으로 비교해 ArrayList에서 가장 큰 값을 찾는 로직이다. 실행결과를 보면 매번 값이 달랐지만 for문과 stream 속도 차이가 줄어든것을 확인할 수 있다. 그 이유는 무엇일까?Primitive Type Vs Reference Type앞서 for문과 stream의 성능 차이가 얼마 나지 않았는데, 그 이유는 바로 ArrayList를 순회하는 비용이 워낙 커서 for문과 stream간의 성능을 압도해버린 것이다. ArrayList를 순회하는 비용이 컸던 이유는 바로 참조형 타입의 값을 사용했기 때문이다.int와 같은 원시타입은 JVM내에서 stack에 저장되어 직접 값을 참조해서 가져올 수 있지만, 참조 타입은 JVM내에서 heap 영역에 저장되기 때문에 stack에 있는 참조변수를 통해 간접적으로 값을 가져와야 한다. 참조 타입을 heap 영역에 간접 참조하여 값을 가져오는 것은, 단순히 두 숫자 간의 크기 비교를 하는 것보다 훨씬 비싼 비용이다. 결국 순회 비용이 계산 비용보다 높았기 때문에 앞선 예제에서 Integer타입으로 가장 큰 숫자를 찾는 로직을 for문과 stream으로 비교했을 때 성능의 차이가 많이 나지 않았던 것이다.그러면 순회하는 비용보다 계산하는 비용이 크게 된다면 결과는 달라질까?이 자료는 Effective Java의 공저자인 Angelika Langer가 JAX London 2015에서 발표했던 ‘The Performance Model of Streams in Java 8” 이라는 발표 자료 파일이다. 계산 비용을 크게 하기 위해 아파치 라이브러인 slowSin()을 이용할 수 있다. 이 메서드는 파라미터로 넘겨지는 메서드에 대해서 sin함수값을 취하고 이에 대한 테일러 급수를 계산하는 함수이다. 전과 같이 int타입의 배열과 Integer 타입에 대한 ArrayList를 10000개의 원소를 순회하여 slowSin()을 적용해보면 다음과 같다.결과를 보면 for문과 stream의 차이가 없으며 계산 비용이 순회비용을 앞서 성능의 차이가 없는 것을 확인할 수 있다. 이로써 순회비용과 계산 비용이 충분히 크다면 stream의 속도는 for문에 가까워지는 것을 확인할 수 있다.for loop Vs Stream 결론Angelika Langer가 JAX London 2015에서 발표했던 ’The Performance Model of Streams in Java 8”의 강의를 수강하여 for문과 stream의 성능을 예제를 통해 비교해보고 확인해보았다. for문은 오래전부터 사용되어 컴파일러가 최적화를 하였기 때문에 stream보다 성능이 빨랐지만, 원시타입과 참조타입의 값을 사용했을 때의 순회비용이 계산비용보다 앞서게 되면 stream의 성능이 for문과 비슷하였고, 계산비용도 마찬가지로 충분히 크게되면 stream이 for문과 비슷한 성능을 가진다는 것을 알게되었다. 처음에는 stream은 for문보다 성능이 떨어지는 대신 가독성을 향상시켜준다는 trade-off가 있다는 것을 알았지만 순회비용과 계산비용이 stream 성능을 좌우하고 상황에 맞게 for문과 stream API를 이용해야겠다는 공부가 되었다.📖 references [[http://www.angelikalanger.com/Conferences/Videos/Conference-Video-GeeCon-2015-Performance-Model-of-Streams-in-Java-8-Angelika-Langer.html](http://www.angelikalanger.com/Conferences/Videos/Conference-Video-GeeCon-2015-Performance-Model-of-Streams-in-Java-8-Angelika-Langer.html)][[https://jaxlondon.com/wp-content/uploads/2015/10/The-Performance-Model-of-Streams-in-Java-8-Angelika-Langer-1.pdf](https://jaxlondon.com/wp-content/uploads/2015/10/The-Performance-Model-of-Streams-in-Java-8-Angelika-Langer-1.pdf)]" }, { "title": "[소프트웨어공학] 애자일 방법론", "url": "/posts/Agile/", "categories": "software engineering", "tags": "software engineering", "date": "2024-01-06 00:00:00 +0800", "snippet": "애자일이란?애자일은 ‘날렵한’, ‘기민한’이라는 뜻으로 소프트웨어 개발 방법론 중 하나이다. 작업 계획을 짧은 단위로 세우고 제품을 만들고 고쳐 나가는 사이클을 반복함으로써 고객의 요구 변화에 유연하고도 신속하게 대응하는 개발 방법론이다. 애자일을 더 알아보기 위해 폭포수 모델 방법론과 비교하여 알아보자.폭포수 모델 방법론(Waterfall Metho...", "content": "애자일이란?애자일은 ‘날렵한’, ‘기민한’이라는 뜻으로 소프트웨어 개발 방법론 중 하나이다. 작업 계획을 짧은 단위로 세우고 제품을 만들고 고쳐 나가는 사이클을 반복함으로써 고객의 요구 변화에 유연하고도 신속하게 대응하는 개발 방법론이다. 애자일을 더 알아보기 위해 폭포수 모델 방법론과 비교하여 알아보자.폭포수 모델 방법론(Waterfall Methodology)위의 사진과 같이 폭포수 모델은 요구사항 분석- 설계 - 구현 - 테스트 - 유지보수의 단계를 거쳐 개발하는 방식이다. 이 방식의 문제점은 각 단계가 종료된 후에만 다음 단계로 넘어갈 수 있다는 것이다. 소프트웨어 개발에 있어 고객의 모든 요구사항이 완벽하게 수집된다면 문제가 되진 않지만 이 가정은 매우 비현실적이다.이러한 문제점으로 애자일 방법론이 대두 되었다.애자일 방법론(Agile Methodology)애자일 방법론은 하나의 사이클안에 분석 - 설계 - 테스트 - 구현을 두어 주기를 돌게 한 후 여러번 반복하는 방식이다. 이러한 반복적이고 점진적인 개발 방식을 통해 사이클마다 피드백을 받고 요구사항들을 쉽게 수용할 수 있는 유연한 개발방법이다. 이 개발방법을 이용해 많은 종류의 방법론이 나오게 되고 그 중 대표적인 스크럼에 대해 알아보자.스크럼(Scrum)스크럼은 애자일 방법론 중 하나이며 비즈니스 요구를 충족시키는데 초점을 맞추기 위해, 작은 목표를 짧은 주기로 점진적이며 경험적으로 제품을 지속적으로 개발하는것에 목표를 가지고 있다.위의 사진은 스크럼 프로세스를 나타내고 스크럼 프로세스 동안 계획회의, 일일 스크럼 등 여러 단계를 수행하며 주요 용어는 아래와 같다. 제품 백로그(Product Backlog) : 개발할 제품의 요구사항인 사용자 스토리 집합이며, 우선순위로 관리. 스프린트(Sprint) : 계획,개발,리뷰 작업 등 최소 단위의 Cycle이다. 스프린트 계획 회의(Sprint Planning Meeting) : 스프린트 목표와 스프린트 백로그를 계획하는 회의. 스프린트 백로그(Sprint Backlog) : 각각의 스프린트 목표에 도달하기 위해 필요한 작업 목록. 일일 스크럼(Daily Scrum) : 매일 어제 한일, 오늘 할일, 해결해야 할 장애/문제 요소를 공유하는 회의(매일 15분 정도 수행) 스프린트 리뷰(Sprint Review) : 스프린트 마지막날 개발자가 개발한 내용을 Stakeholder, 고객, 제품 책임자에게 시연하고 검토. 스프린트 회고(Sprint Retrospective) : 스프린트 마지막날 좋았던 점, 개선할 점을 도출하고 더 나은 방향으로 개선. 이러한 유연하고 효율적인 개발을 할 수 있도록 만드는 애자일 방법론은 고객의 요구사항을 한 주기마다 파악할 수 있고, 피드백을 받을 수 있다는 점에서 소프트웨어의 품질을 지속적으로 개선할 수 있게 된다.📖 references 오픈 소스 소프트웨어로 실습하는 소프트웨어공학 - 정인상Robert C. Martin - Agile Software Development, Principles, Patterns, and Practices-Prentice Hall[https://velog.io/@iamminzzy/애자일Agile-방법론-이란-BDD부터-TDD까지][https://medium.com/dtevangelist/scrum-dfc6523a3604](https://medium.com/dtevangelist/scrum-dfc6523a3604)" }, { "title": "[알고리즘] 중복 문자 제거", "url": "/posts/removeDuplicateLetters/", "categories": "algorithm", "tags": "algorithm, python", "date": "2023-12-21 00:00:00 +0800", "snippet": "문제중복된 문자를 제외하고 사전식 순서로 나열하라.입력\"bcabc\"출력\"abc\"입력\"cbacdcbc\"출력\"acdb\"풀이1 (스택 일치 여부 판별)이 문제를 풀기 전에, 사진식 순서라는 용어를 알아야한다. 사전식 순서란 사전에서 가장 먼저 찾을 수 있는 순서를 말하며, bcabc에서 중복문자를 제외하면 사전에서 가장 먼저 찾을 수 있는 문자열은 abc가...", "content": "문제중복된 문자를 제외하고 사전식 순서로 나열하라.입력\"bcabc\"출력\"abc\"입력\"cbacdcbc\"출력\"acdb\"풀이1 (스택 일치 여부 판별)이 문제를 풀기 전에, 사진식 순서라는 용어를 알아야한다. 사전식 순서란 사전에서 가장 먼저 찾을 수 있는 순서를 말하며, bcabc에서 중복문자를 제외하면 사전에서 가장 먼저 찾을 수 있는 문자열은 abc가 될 것이다. 만약 앞에 e 문자가 하나 더 붙은 ebcabc가 입력값이라면 결과는 eabc가 될 것이다. 반면 입력값이 ebcabce라면 첫 번째 e는 중복으로 제거할 수 있고 마지막 e를 남겨서, 결과는 abce가 될 수 있다.먼저 전체 코드를 보자.def removeDuplicateLetters(self, s: str) -&gt; str: # 집합으로 정렬 for char in sorted(set(s)): suffix = s[s.index(char):] # 전체 집합과 접미사 집합이 일치할때 분리 진행 if set(s) == set(suffix): return char + self.removeDuplicateLetters(suffix.replace(char, '')) return ''중복문자를 제거하는 원리는 중복 문자를 제외한 알파벳순으로 문자열 입력값을 모두 정렬(sorted(set(s))한 다음 접미사 suffix를 분리하여 확인한다. 분리 가능 여부는 전체 집합(set(s))과 접미사 집합(set(suffix))이 일치하는지 판별한다.# 전체 집합과 접미사 집합이 일치할때 분리 진행if set(s) == set(suffix): return char + self.removeDuplicateLetters(suffix.replace(char, ''))이 코드는 사전식 순서를 만들기 위해 분리하는 데, 현재문자가 c라고 했을 때 c를 리턴하는 재귀 호출 구조로 처리한다. 이 후 뒤에 이어지는 모든 c는 replace()로 제거한다. 이렇게 되면 접미사 suffix가 점점 줄어들어 더 이상 남지 않을 때 백트래킹 되면서 조합된다.아래는 입력값으로 “cbacdcbc”가 들어왔을 때 중복문자가 제거되는 과정을 보여준다.removeDuplicateLetters()는 rDL()로 줄여서 함수를 표기하였고 전체 집합과 접미사 집합이 일치할 경우 분리가 진행되어 재귀형식으로 호출되며 진행되는 것을 볼 수 있다. 입력 예제와 같이 “cbacdcbc”가 입력값으로 들어올 경우, “acdb”가 반환되는 것을 알 수 있다.풀이 2 (스택을 이용한 문자 제거)스택을 이용하여 이 문제를 해결할 수 있는데, 먼저 스택을 이용한 코드를 보면 아래와 같다.def removeDuplicateLetters(self, s: str) -&gt; str: counter, seen, stack = collections.Counter(s), set(), [] for char in s: counter[char] -= 1 if char in seen: continue # 뒤에 붙일 문자가 남아 있다면 스택에서 제거 while stack and char &lt; stack[-1] and counter[stack[-1]] &gt; 0: seen.remove(stack.pop()) stack.append(char) seen.add(char) return ''.join(stack)코드를 이해하기 위해 다음 실행과정을 살펴보자.먼저 첫 번째 ‘c’가 스택에 삽입되는 동시에 seen 리스트에도 삽입된다. seen 리스트는 여기서 중복을 제거하기 위한 체크변수로, 만약 seen 리스트에 문자가 있다면 다음 문자로 스킵한다. 그렇게 문자가 삽입되고 3번과정을 보면 char=’a’일 때, a는 문자 b,c보다 사전식으로 먼저오고, b,c는 아직 s문자열에 남아있으므로 스택에 있는 문자를 다 pop()되며 스택에 a가 삽입된다. 나머지도 이와 같이 실행되면서 문자가 사전식으로 나열되고 중복을 제거한 형태로 답을 찾을 수 있다.정리두가지 풀이로 이 문제를 풀어보았는데, 이해하기가 상당히 어려웠다. 동작과정을 그려보면서 해보니 이해할 수 있었고 중복을 제거하는 아이디어는 스택을 이용할 수 있다는 것을 배웠다.📖 references 파이썬 알고리즘 인터뷰 - [책만]" }, { "title": "[알고리즘] 그리디 알고리즘", "url": "/posts/Algorithm_Greedy/", "categories": "algorithm", "tags": "algorithm", "date": "2023-11-13 00:00:00 +0800", "snippet": "탐욕 알고리즘(Greedy Algorithm)이란?Greedy는 탐욕스러운, 욕심 많은 이라는 뜻이다. 탐욕 알고리즘은 현재 상황에서 지금 당장 좋은 것만 고르는 방법만 의미한다. 그리디 알고리즘 문제로 유명한 거스름돈 문제를 보면서 이해해 보자.문제당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원,...", "content": "탐욕 알고리즘(Greedy Algorithm)이란?Greedy는 탐욕스러운, 욕심 많은 이라는 뜻이다. 탐욕 알고리즘은 현재 상황에서 지금 당장 좋은 것만 고르는 방법만 의미한다. 그리디 알고리즘 문제로 유명한 거스름돈 문제를 보면서 이해해 보자.문제당신은 음식점의 계산을 도와주는 점원이다. 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정한다. 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러 줘야 할 동전의최소 개수를 구하라. 단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.위의 문제는 가장 큰 화폐 단위부터 돈을 거슬러 500원, 100원, 50원, 10원짜리 동전을 차례대로 거슬러 줄 수 있을 만큼 거슬러 주면된다.n = 1260count = 0# 큰 단위의 화폐부터 차례대로 확인coin_types = [500, 100, 50, 10]for coin in coin_types: count += n//coin n%=coin위 거스름돈 문제를 보듯이 그리디 알고리즘은 현재 상황에서 가장 좋은 것을 선택해나가는 방식이다. 그러면 이 알고리즘의 방식이 항상 최적의 해를 보장할 수 있을까? 그렇지 않다. 처음에 그리디 알고리즘 문제를 풀어보면서 현재 상황에서 가장 좋은 것만 선택해서 풀려고 하는데, 이 방법이 적용되지 않는 문제들이 많자 왜 그런지 생각해보니 그리디 알고리즘은 미래 상황을 고려하지 않아 전체 문제에서의 최적의 해를 구할 수 없었던 것이다. 현재의 최적해 ≠ 전체의 최적해그래서 그리디 알고리즘은 최적의 해가 보장된 조건에서만 적용해야되는 알고리즘이다!그리디 알고리즘 최적의 해 보장조건1. 현재의 선택이 미래의 선택에 영향을 주지 않는다.예를 들어 서울에서 부산까지의 최소비용을 구하라고 할때 서울에서 대전까지 가는 경로를 선택하는데 대전에서 부산까지의 경로를 선택하는데 영향을 미치지 않으므로, 서울에서 대전까지 가는 3개의 경로 중 가장 짧은 경로를 택하면 된다. 즉, 현재 선택이 미래 선택에 영향을 주지 않는다. 이럴 때 서울에서 대전까지 가는 비용만 고려하여 선택해도 최적의 해가 보장된다. 이 조건을 탐욕스러운 선택 조건(Greedy Choice Property) 라고 부른다.2. 부분의 최적해가 모이면 전체의 최적 해가 된다.위의 같은 문제로 예를 들면 서울에서 부산까지의 최소비용을 구할 때, 이 문제를 쪼개면 서울 → 대전, 대전 → 부산 의 최소 비용을 구하면 된다. 즉, 하나의 큰 문제를 여러개의 작은 문제들로 나눌 수 있고, 그 작은 문제들에 대한 최적의 해가 더해지는 것이 전체 문제의 최적해가 된다. 이 조건을 최적 부분 구조 조건(Optimal Substructure)이라고 한다.위의 2개의 조건들이 성립해야만 그리디 알고리즘이 최적의 해를 보장해준다📖 references 이것이 코딩테스다 with 파이썬 [한빛미디어][https://www.youtube.com/watch?app=desktop&amp;v=_IZuE7NIeW4][https://velog.io/@contea95/탐욕법그리디-알고리즘][https://hanamon.kr/알고리즘-탐욕알고리즘-greedy-algorithm/]" }, { "title": "[데이터베이스] in과 exists 연산자 차이", "url": "/posts/Database_inexists/", "categories": "database", "tags": "database", "date": "2023-11-06 00:00:00 +0800", "snippet": "중첩질의in과 exists연산자는 중첩질의 중 하나인데, 중첩질의란 SQL문을 다른 SQL문 안에 중첩하여 사용하는 질의를 의미한다. 이때 내부에 포함된 SQL문을 부 질의(sub query) 또는 내부 질의(inner query)라 하며 부 질의를 갖는 SQL문을 외부 질의(outer query)라고 한다.스키마course(course_id, tit...", "content": "중첩질의in과 exists연산자는 중첩질의 중 하나인데, 중첩질의란 SQL문을 다른 SQL문 안에 중첩하여 사용하는 질의를 의미한다. 이때 내부에 포함된 SQL문을 부 질의(sub query) 또는 내부 질의(inner query)라 하며 부 질의를 갖는 SQL문을 외부 질의(outer query)라고 한다.스키마course(course_id, title, credit)class(class_id, course_id, year, semester, division, prof_id, classroom, enroll)예를 들어 스키마 구조는 위와 같고, ‘301호’ 강의실에서 개설된 강좌의 과목명을 출력하는 SQL문은 다음과 같이 작성할 수 있다.select titlefrom coursewhere course_id in (select distinct course_id from class where classromm = '301호')위의 SQL문에서 부 질의 키워드 in 뒤에 나오는 SQL문으로서 class 테이블에서 강의실이 ‘301호’인 교과목 번호를 검색한다. 키워드 in은 부 질의의 검색 결과에 포함되는 경우를 나타낸다. 따라서 외부 질의에서는 course 테이블에서 course_id 필드의 값이 부 질의의 검색 결과에 포함되는 경우에만 과목명을 출력하게 된다.또한 위의 예제를 exists를 이용해 SQL문을 작성해도 같은 결과를 얻을 수 있다.select titlefrom coursewhere exists (select * from class where classromm = '301호' and course.course_id = class.course_id)exists는 최소한 하나 이상의 레코가 존재하면 참이 되고 그렇지 않으면 거짓이 된다. 따라서 부질의 검색 결과에 최소한 하나 이상의 레코드가 존재하는지의 여부를 표현할 수 있다.그렇다면 in과 exists 모두 중첩 질의이고 둘의 차이점은 무엇일까?in과 existsin연산은 부질의의 SQL문을 실행하면 select연산으로 만족하는 모든 행을 추출한 뒤 외부 질의를 하게되지만, exists연산은 부 질의의 SQL문을 실행하면 하나라도 만족하는 행이 있다면 SQL엔진은 더 이상 탐색하지 않고 참 혹은 거짓을 반환하여 외부 질의를 하게 된다. 위의 예를 가지고 살펴보자-- in 연산select titlefrom coursewhere course_id in (select distinct course_id from class where classromm = '301호')먼저 in연산을 사용한 SQL에서 부 질의의 실행결과는 아래와 같을 것이다. course_id C101 C103 C301 이후 course 테이블에서 부질의 연산의 결과인 course_id를 검색하여 title을 반환하면 아래와 같다. title 전산개론 데이터베이스 운영체제 반면, exists연산을 다시 보면-- exists 연산select titlefrom coursewhere exists (select * from class where classromm = '301호' and course.course_id = class.course_id)exists는 in 구문과 다르게 외부 쿼리에 먼저 접근하여 행 하나를 가져오고 exists의 서브쿼리를 실행시켜 결과가 존재하는지를 판단합니다.서브쿼리의 결과가 true 인지 false 인지 체크하기 때문에 exists에서는 결과가 존재할 경우(= true) 메인 쿼리의 결과를 출력하고 not exists에서는 서브쿼리 내의 결과가 존재하지 않을 경우(= false) 메인 쿼리의 결과를 출력하게 된다. in은 서브 쿼리 → 외부 쿼리 순으로 실행exists는 외부 쿼리 → 서브 쿼리 순으로 실행in 연산자는 서브쿼리를 모두 검색하고, exists 연산자는 찾을 때까지 검색한다. 따라서 서브쿼리의 데이터가 작을 경우 in 구문과 exists 의 성능은 크게 차이가 없지만, 서브쿼리에 조회되는 데이터가 많아질수록 exists연산자가 in에 비해 성능이 더 좋다.📖 references 데이터베이스의 이해 [이한미디어][https://wildeveloperetrain.tistory.com/223](https://wildeveloperetrain.tistory.com/223)[https://stackoverflow.com/questions/24929/difference-between-exists-and-in-in-sql](https://stackoverflow.com/questions/24929/difference-between-exists-and-in-in-sql)" }, { "title": "[알고리즘] 순열", "url": "/posts/Permutation/", "categories": "algorithm", "tags": "algorithm, python", "date": "2023-10-30 00:00:00 +0800", "snippet": "문제서로 다른 정수를 입력받아 가능한 모든 순열을 리턴하라.입력[1,2,3]출력[\t[1,2,3],\t[1,3,2],\t[2,1,3],\t[2,3,1],\t[3,1,2],\t[3,2,1]]풀이1 (DFS를 활용한 순열 생성)순열은 모든 가능한 경우를 그래프 형태로 나열할 수 있기 때문에 그래프로 표현하면 다음과 같다.위 그래프 형태를 만족시키는 코드로 구성하려면...", "content": "문제서로 다른 정수를 입력받아 가능한 모든 순열을 리턴하라.입력[1,2,3]출력[\t[1,2,3],\t[1,3,2],\t[2,1,3],\t[2,3,1],\t[3,1,2],\t[3,2,1]]풀이1 (DFS를 활용한 순열 생성)순열은 모든 가능한 경우를 그래프 형태로 나열할 수 있기 때문에 그래프로 표현하면 다음과 같다.위 그래프 형태를 만족시키는 코드로 구성하려면 재귀 형태로 구현하면 된다. 이전 값을 하나씩 덧붙여서 계속 재귀 호출을 하다가 리프노드(len(elements) ==0)에 도달한 경우 result변수에 결과를 담는다.코드는 다음과 같다.def permute(self, nums: List[int]) -&gt; List[List[int]]: results = [] prev_elements = [] def dfs(elements): # 리프 노드일때 결과 추가 if len(elements) == 0: results.append(prev_elements[:]) # 순열 생성 재귀 호출 for e in elements: next_elements = elements[:] next_elements.remove(e) prev_elements.append(e) dfs(next_elements) prev_elements.pop() dfs(nums) return results재귀 형태로 구성했을 때 변수들의 변화량은 아래와 같이 진행된다.풀이2 (itertools 모듈 사용)import itertoolsdef permute(self, nums: List[int]) -&gt; List[List[int]]: return list(itertools.permutations(nums))파이썬의 itertools 모듈을 사용해서 순열을 구할 수 있다. itertools 모듈은 반복자 생성에 최적화된 효율적인 기능들을 제공하므로 문제 풀이 속도도 빠르고 코드도 훨씬 간편하게 구성할 수 있다.정리순열의 모든 경우의 수를 그래프 형태로 나타내고 이 그래프 형태를 구현하기 위해 재귀방법을 사용하여 순열의 모든 경우의 수를 구할 수 있었다. 또한 itertools를 사용해 순열을 구할 수 있어 라이브러리 사용만으로 순열을 쉽게 구할 수 있는 방법도 알게 되었다.📖 references 파이썬 알고리즘 인터뷰 - [책만]" }, { "title": "[알고리즘] 역순 연결 리스트 II", "url": "/posts/ReversedLinkedList2/", "categories": "algorithm", "tags": "algorithm, python", "date": "2023-10-17 00:00:00 +0800", "snippet": "문제인덱스 m에서 n까지를 역순으로 만들어라. 인덱스 m은 1부터 시작한다.입력1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL, m = 2, n = 4출력1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; NULL풀이 ( 반복 구조로 노드 뒤집기)이 풀이에서는 start와 end변수를 이용하여 풀이할...", "content": "문제인덱스 m에서 n까지를 역순으로 만들어라. 인덱스 m은 1부터 시작한다.입력1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL, m = 2, n = 4출력1 -&gt; 4 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; NULL풀이 ( 반복 구조로 노드 뒤집기)이 풀이에서는 start와 end변수를 이용하여 풀이할 수 있다. start와 end를 기준으로 반복하면서 역순으로 뒤집으면서 풀이할수 있다.root = start = ListNode(None)root.next = head# start, end 지정for _ in range(m - 1): start = start.nextend = start.next여기서 start는 변경이 필요한 2의 바로 앞 지점인 1을 가르키게 하고 end는 start.next인 2를 지정한다. head는 1이고 root가 head를 가르키게 하여 최종적으로 root.next를 반환하게 된다.그리고 start와 end는 끝까지 값이 변하지 않는다. 아래 코드는 start와 end를 기준으로 연결 리스트를 역순으로 바꾸는 역할을 한다. 위의 입력 예제로 코드와 함께 동작과정을 살펴보자.tmp = start.nextstart.next = end.nextend.next = end.next.nextstart.next.next = tmp start.next를 tmp로 지정한다. start.next는 end.next가 된다. end.next는 end.next.next로 한 칸 더 앞의 값을 가르킨다. start.next.next 는 tmp로 지정한다.위와 같은 구조로 n-m번 반복하면 최종결과가 나오게 된다.반복하면서 역순으로 리스트를 구성할 때 다중 할당 형태로 코드를 구성할 수 있다.def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode:\t # 예외 처리\t if not head or m == n:\t return head\t\t root = start = ListNode(None)\t root.next = head\t # start, end 지정\t for _ in range(m - 1):\t start = start.next\t end = start.next\t\t # 반복하면서 노드 차례대로 뒤집기\t for _ in range(n - m):\t tmp, start.next, end.next = start.next, end.next, end.next.next\t start.next.next = tmp\t return root.next정리반복문을 활용해서 연결 리스트를 역순으로 뒤집을 수 있고, 노드를 차례대로 뒤집을 때 다중 할당 구조를 사용하면 소스코드가 간결해지는 것을 볼 수 있었다.📖 references 파이썬 알고리즘 인터뷰 - [책만]" }, { "title": "[데이터베이스] 정규화", "url": "/posts/Normalization/", "categories": "database", "tags": "database", "date": "2023-09-30 00:00:00 +0800", "snippet": "정규화(normalization)란?정규화란 불필요한 데이터의 중복을 피하기 위해 스키마를 분해하는데, 이 과정을 정규화라고 한다.정규형의 종류정규화는 테이블에 대한 삽입, 삭제, 수정 등의 연산으로 인해 발생할 수 있는 이상현상을 방지해준다.그리고 각 단계별 정규화 과정을 통해 분해된 테이블들을 정규형(normal form)이라고 한다.정규형에는 1...", "content": "정규화(normalization)란?정규화란 불필요한 데이터의 중복을 피하기 위해 스키마를 분해하는데, 이 과정을 정규화라고 한다.정규형의 종류정규화는 테이블에 대한 삽입, 삭제, 수정 등의 연산으로 인해 발생할 수 있는 이상현상을 방지해준다.그리고 각 단계별 정규화 과정을 통해 분해된 테이블들을 정규형(normal form)이라고 한다.정규형에는 1차 정규형 부터 5차 정규형까지 있으며 정규형의 차수가 높아질수록 더 많은 제약들이 가해진다. 이외에도 특수한 정규형인 보이스-코드 정규형이 있다. 일반적으로 데이터베이스를 설계할 때는 3차 정규형이나 보이스-코드 정규형까지만을 고려한다.함수적 종속정규형을 이해하기 위해서는 함수적 종속 이론에 대한 이해가 필요하다.함수적 종속(functional dependency)이란 무결성 제약의 한 종류로서, 키의 개념을 일반화한 것이다. 이는 테이블 내에서 필드 간의 관계성을 표현한 것이며, 데이터 중복의 발생 여부를 파악하는 데 중요한 역할을 한다. stu_id resident_id name year dept_id dept_name 1292001 900424-1825409 김광식 3 920 컴퓨터공학과 1292002 900305-1730021 김정현 3 920 컴퓨터공학과 1292003 891021-2308302 김현정 4 920 컴퓨터공학과 1292301 890902-2704012 김현정 2 923 컴퓨터공학과 1292303 910715-1524390 박광수 3 923 컴퓨터공학과 1292305 921011-1809003 김우주 4 923 컴퓨터공학과 1292501 900825-1506390 박철수 3 925 컴퓨터공학과 함수적 종속은 하나의 테이블 내에서 필드들 간의 관계로 정의된다. 하나의 레코드에서 특정 필드의 값이 주어지면 특정 다른 필드의 값이 자동적으로 정해지는 경우가 있다. 예를 들어 위의 테이블에서 기본키는 stu_id라고 가정하자. 여기서 레코드의 stu_id를 알면 name과 dept_name을 찾아낼 수 있다. 다시 말해서, 학번이 동일한 두 개의 레코드가 존재한다면 이름과 학과명 둘다 동일하게 된다. 그 이유는 name과 dept_name의 값은 stu_id에 의존적이기 때문이다. 이 경우 name과 dept_name 각각은 stu_id에 함수적으로 종속된다고 말한다.함수적 종속👉 테이블 R에서 X와 Y를 각각 R에서 정의된 필드들의 부분 집합이라고 하자. 이때 Y의 값이 동일한 임의의 레코드의 쌍인 t1, t2에 대해서 Y의 값도 동일하다고 하면 Y는 X에 함수적으로 종속된다고 한다. 표기는 다음과 같이 표현한다. X → YY는 X에 함수적으로 종속된다 라는 표현은 역으로 X는 Y를 함수적으로 결정한다 를 의미한다. 이때 X를 결정자(determinant)라고 하고, Y를 종속자(dependent)라고 한다. 위의 테이블에서 함수적 종속 관계는 다음과 같이 표현할 수 있다. stu_id → name stu_id → resident_id resident_id → stu_id stu_id → dept_name resident_id → dept_name1차 정규형테이블 R에 속한 모든 도메인이 원자값(atomic value)만으로 구성되어 있다면 R은 1차 정규형이다. stu_id title grade dept_name office 1292001 전산개론 B+ 컴퓨터공학과 920 1292001 데이터베이스 A+ 컴퓨터공학과 920 1292001 운영체제 A 컴퓨터공학과 920 1292002 자료구조 A 컴퓨터공학과 920 1292002 데이터베이스 B+ 컴퓨터공학과 920 1292002 알고리즘 C+ 컴퓨터공학과 920 1292003 인공지능 A+ 컴퓨터공학과 920 1292003 자료구조 C+ 산업공학과 923 위의 테이블을 보면 각 학생이 수강하고 있는 과목과 그 과목에 대한 성적, 그리고 학생이 소속된 학과와 사무실 정보를 저장한다. 여기서 기본키는 (stu_id, title)의 복합키로 구성된다.여기서는 모든 도메인이 원자값으로 이주어져 있어 1차 정규형임을 알 수 있다.2차 정규형테이블 R에서 키가 아닌 모든 필드가 키에 대해 함수적으로 종속되며, 키의 부분집합이 결정자가 되는 부분 종속이 존재하지 않으면, R은 2차 정규형이다.이 말을 이해하기 위해서 앞서 본 테이블을 보자. 위의 테이블에서는 3가지의 이상현상이 발생할 수 있다. 삽입 이상 : 학번이 ‘1292502’인 학생이 ‘전자공학과’에 소속된다는 사실을 삽입하려면, 최소한 그 학생이 하나의 과목을 수강해야만 가능하다. 그렇지 않으면 삽입이 불가능하다. 삭제 이상 : 테이블에서 stu_id가 ‘1292301’인 학생이 ‘자료구조’를 수강한다는 사실을 삭제하면 이 학생이 ‘산업공학과’에 소속된다는 정보까지 동시에 삭제된다. 뿐만 아니라. 이 학생이 ‘산업공학과’에 유일한 학생이라면 학과 정보도 같이 삭제 된다. 수정 이상 : 학번이 ‘1292001’인 학생의 소속이 ‘컴퓨터공학과’에서 ‘산업공학과’로 변경 되면 이 사실에 해당하는 모든 레코드에 대해서 반영되어야 한다.위의 문제점이 발생하는 이유가 무엇일까?👉 위의 테이블에서 stu_id는 기본키의 일부인데, 이 필드가 기본키에 포함하지 않은 필드인 dept_name을 함수적으로 결정해서 이다. 함수적으로 결정한다는 뜻은 여기서 stu_id를 알면 dept_name을 찾을 수 있듯이 dept_name은 stu_id에 의존적이라서 함수적으로 결정된다. 따라서 dept_name필드는 기본키인 (stu_id, title)에 의해 영향을 받지 않고 오직 stu_id에 의해서만 결정된다. 결국 dept_name은 이 테이블에서 중복되어 표현될 수 밖에 없어 이상현상이 발생한 것이다.이와 같이 키에 포함되지 않은 필드가 키의 부분집합에 종속되는 것을 부분 종속(partial dependency)이라고 한다. 위의 그림은 부분 종속의 예를 보여주며, 이 그림에서 X는 키의 부분집합이고, X → A가 성립하면 A는 키에 부분 종속된다.이 이상현상을 해결하기 위해서는 부분 종속에 해당하는 결정자와 종속자를 별도의 테이블로 분리시켜야 한다. 위의 그림에서는 X(stu_id)와 A(dept_name)를 하나의 독립된 테이블로 구성하고, 본래의 테이블에서 A(dept_name)를 제외하면 된다.student 테이블 stu_id dept_name office 1292001 컴퓨터공학과 920 1292002 컴퓨터공학과 920 1292003 컴퓨터공학과 920 1292301 산업공학과 923 takes 테이블 stu_id title grade 1292001 전산개론 B+ 1292001 데이터베이스 A+ 1292001 운영체제 A 1292002 자료구조 A 1292002 데이터베이스 B+ 1292002 알고리즘 C+ 1292003 인공지능 A+ 1292003 자료구조 C+ 분해된 student와 takes 테이블에는 다음과 같이 함수적 종속이 그대로 보존된다.student 테이블 stu_id → dept_name dept_name - &gt;officetakes 테이블 (stu_id, title) → grade그래서 2차 정규형은 다음과 같다. 테이블 R에서 키가 아닌 모든 필드가 키에 대해 함수적으로 종속되며, 키의 부분 집합이 결정자가 되는 부분 족속이 존재하지 않으면 R은 2차 정규형이다. (하나의 필드로 키가 정의되는 경우는 모두 2차 정규형이다.)3차 정규형그러나 위의 테이블 중 student 테이블에서는 이행적 함수적 종속이 발생한다.이행적 종속이란?👉 이행적 종속이란 테이블 R에 필드 집합 X, Y, Z가 있다고 할때, X→Y 이고 Y→Z이면 이행적 함수적 종속이라고 한다.위의 예제에서는 office는 dept_name에 종속되며 다시 dept_name은 stu_id에 종속되어서 레코드는 중복된다. 그래서 이 student 테이블을 아래와 같이 2개로 분해하여 이행 종속을 제거해야 한다.student 테이블 stu_id dept_name 1292001 컴퓨터공학과 1292002 컴퓨터공학과 1292003 컴퓨터공학과 1292301 산업공학과 department 테이블 dept_name office 컴퓨터공학과 920 산업공학과 923 분해된 student와 department 테이블에는 다음과 같이 함수적 종속이 존재함을 알 수 있다.student 테이블 stu_id → dept_namedepartment 테이블 dept_name - &gt; office따라서 3차 정규형은 다음과 같다. 테이블 R이 2차 정규형이면서 키에 속하지 않은 모든 필드가 기본키에 이행 종속되지 않는다면, R은 3차 정규형이다.📖 references 데이터베이스의 이해 [이한미디어]" }, { "title": "[알고리즘] 두 수의 덧셈", "url": "/posts/AddTwoNumbers/", "categories": "algorithm", "tags": "algorithm, python", "date": "2023-09-24 00:00:00 +0800", "snippet": "문제역순으로 저장된 연결 리스트의 숫자를 더하라.입력(2 -&gt; 4 -&gt; 3), (5 -&gt; 6 -&gt; 4)출력7 -&gt; 0 -&gt; 8 설명 342 + 465 = 807 풀이 1 (자료형 변환)입력으로 들어오는 두 리스트를 역순으로 된 연결리스트로 변환 후 두 리스트를 더해야 한다.역순으로 리스트를 변환하는 코드...", "content": "문제역순으로 저장된 연결 리스트의 숫자를 더하라.입력(2 -&gt; 4 -&gt; 3), (5 -&gt; 6 -&gt; 4)출력7 -&gt; 0 -&gt; 8 설명 342 + 465 = 807 풀이 1 (자료형 변환)입력으로 들어오는 두 리스트를 역순으로 된 연결리스트로 변환 후 두 리스트를 더해야 한다.역순으로 리스트를 변환하는 코드는 다음과 같다.# 연결 리스트 뒤집기def reverseList(self, head: ListNode) -&gt; ListNode: node, prev = head, None while node: next, node.next = node.next, prev prev, node = node, next return prev역순으로 연결하기 위해 node.next를 이전 prev 리스트로 계속 연결하면서 끝날 때까지 반복한다.node가 None이 될 때, prev는 뒤집힌 연결 리스트의 첫 번째 노드가 된다.이 후 덧셈을 위해 연결 리스트를 파이썬의 리스트로 변경해야 한다.# 연결 리스트를 파이썬 리스트로 변환def toList(self, node: ListNode) -&gt; List: list: List = [] while node: list.append(node.val) node = node.next return listnode를 list에 삽입하면서 변환하는 코드이다.덧셈 후 다시 역순으로 된 연결 리스트로 변환해야 되기 때문에 리스트를 역순 연결 리스트로 변환하는 코드는 다음과 같다.# 파이썬 리스트를 연결 리스트로 변환def toReversedLinkedList(self, result: str) -&gt; ListNode: prev: ListNode = None for r in result: node = ListNode(r) node.next = prev prev = node return node역순 연결리스트로 변환 해주는 함수에서 매개변수가 str 인 result변수로 받게되는데, 이는 덧셈 풀이에서 문자열로 변환해서 작업했기 때문이다. 덧셈 코드를 보면 다음과 같다.a = self.toList(self.reverseList(l1))b = self.toList(self.reverseList(l2))resultStr = int(''.join(str(e) for e in a)) + int(''.join(str(e) for e in b))입력받은 두개의 리스트를 역순 연결 리스트로 변환하고 파이썬의 리스트로 변경 후, 덧셈 연산을 위해 리스트를 int형태로 결합해여 한다. 그러기 때문에 합치기 전에 문자형으로 먼저 변경이 필요하다.int(''.join(str(e) for e in a))여기서 str(e) 로 각 항목을 문자로 변경한 다음 join()으로 합쳤다. 합치고 난 후 덧셈 연산이 필요하므로 int() 를 이용해 숫자형으로 변환 후 덧셈을 수행한 것이다.이후, 최종적으로 나온 결과를 역순으로 구성된 연결리스트로 바꾸면 되기 때문에 앞서 작성한 toReversedLinkedList() 를 사용하여 변환해주면 된다.전체 코드는 다음과 같다.# 연결 리스트 뒤집기def reverseList(self, head: ListNode) -&gt; ListNode: node, prev = head, None while node: next, node.next = node.next, prev prev, node = node, next return prev# 연결 리스트를 파이썬 리스트로 변환def toList(self, node: ListNode) -&gt; List: list: List = [] while node: list.append(node.val) node = node.next return list# 파이썬 리스트를 연결 리스트로 변환def toReversedLinkedList(self, result: str) -&gt; ListNode: prev: ListNode = None for r in result: node = ListNode(r) node.next = prev prev = node return node# 두 연결 리스트의 덧셈def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode: a = self.toList(self.reverseList(l1)) b = self.toList(self.reverseList(l2)) resultStr = int(''.join(str(e) for e in a)) + \\ int(''.join(str(e) for e in b)) # 최종 계산 결과 연결 리스트 변환 return self.toReversedLinkedList(str(resultStr))풀이 2 (전가산기 구현)이번에는 논리 회로의 전가산기(Full Adder)와 유사한 형태로 구현해보자. 이진법이 아니라 십진법이라는 차이만 있을 뿐 자리올림수(Carry)를 구하는 것까지 가산기의 원리와 거의 동일하다.여기서는 연산 결과로 나머지(Remainder)를 취하고 몫은 자리올림수 형태로 올리는 전가산기의 전체적인 구조만 풀이한다.sum = 0# 두 입력값의 합 계산if l1: sum += l1.val l1 = l1.nextif l2: sum += l2.val l2 = l2.next이 코드는 먼저 두 입력값의 합을 구한다. 두 입력값의 연산을 수행하고 다음과 같이 자릿수가 넘어갈 경우 자리올림수를 저장하는 코드는 다음과 같다.# 몫(자리올림수)과 나머지(값) 계산carry, val = divmod(sum + carry, 10)자리올림수는 파이썬의 내장함수인 divmod() 를 사용하여 구한다. divmod()는 몫과 나머지로 구성된 튜플을 return한다. 즉, (a // b, a % b)와 동일한 결과를 출력한다.위의 예제를 전가산기 형태로 구현했을 때 sum, carry, val의 변화량은 다음과 같다.자리올림수(carry)를 설정하여 두 값을 합한 결과가 두 자릿수가 될 경우를 다음번 연산에 사용하고, 나머지는 값을 취하여 이 값을 연결리스트로 만들어주면 된다.전체 코드는 다음과 같다.def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:\t\troot = head = ListNode(0)\t\t\t\tcarry = 0\t\twhile l1 or l2 or carry:\t\t sum = 0\t\t # 두 입력값의 합 계산\t\t if l1:\t\t sum += l1.val\t\t l1 = l1.next\t\t if l2:\t\t sum += l2.val\t\t l2 = l2.next\t\t\t\t # 몫(자리올림수)과 나머지(값) 계산\t\t carry, val = divmod(sum + carry, 10)\t\t head.next = ListNode(val)\t\t head = head.next\t\t\t\treturn root.next정리연결 리스트를 파이썬의 리스트 형태로 변환하여 풀이하는 방법과 전가산기의 원리와 유사하게 자리올림수를 적용해서 풀이해보았다. 첫 번째 풀이 방법에서 자료형을 일일이 변환하여 풀이하여 코드가 다소 길지만, 두 번째 전가산기 원리를 이용하여 구현했을 때의 코드는 한결 깔끔하다.📖 references 파이썬 알고리즘 인터뷰 - [책만]" }, { "title": "[알고리즘] 두 정렬 리스트 병합", "url": "/posts/MergeTwoLists/", "categories": "algorithm", "tags": "algorithm, python", "date": "2023-09-17 00:00:00 +0800", "snippet": "문제정렬되어 있는 두 연결 리스트를 합쳐라.입력1 -&gt; 2 -&gt; 4, 1 -&gt; 3 -&gt; 4출력1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4풀이 1 (재귀 구조로 연결)입력으로 들어오는 두 연결 리스트는 정렬된 리스트기 때문에 첫 번째 값부터 서로 비교하면서 재귀 형태로 풀 수 있다. 코드는 다음과 같다...", "content": "문제정렬되어 있는 두 연결 리스트를 합쳐라.입력1 -&gt; 2 -&gt; 4, 1 -&gt; 3 -&gt; 4출력1 -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 4풀이 1 (재귀 구조로 연결)입력으로 들어오는 두 연결 리스트는 정렬된 리스트기 때문에 첫 번째 값부터 서로 비교하면서 재귀 형태로 풀 수 있다. 코드는 다음과 같다.# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = Nonedef mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode: if (not l1) or (l2 and l1.val &gt; l2.val): l1, l2 = l2, l1 if l1: l1.next = self.mergeTwoLists(l1.next, l2) return l1연결리스트는 해당 값과 다음 노드를 가르키는 변수로 구성되고,mergeTwoLists()는 재귀함수로 구현되어있다. 매개변수로 두개의 연결 리스트를 받아 L1의 값과 L2의 값을 비교하여 L1의 값이 클 때 L2의 값과 교체하여 L1 리스트에 순서대로 정렬해 나간다. 이 때 L1의 다음값은 재귀 형태로 구현되어있는데, 이를 스택의 형태와 L1과 L2의 리스트의 변화되는 모습은 다음과 같다.초기에는 L1과 L2는 각 연결리스트의 첫 번째 값을 가리킨다. 만약 L1이 L2의 값보다 크다면 L1과 L2의 값을 바꾸어 L1 리스트에 L2값들을 순서대로 병합하여 리스트를 합쳐 나간다. 여기서 값을 스왑해나가면서 계속 재귀호출을 하는데, 이는 두개의 리스트를 하나로 합쳐주는 역할을 해준다. 그리고 마지막에 L1이 None이 되면 재귀가 끝나게 되고 호출한 함수쪽으로 return하게 된다. return하면서 백트래킹이 끝나게 되면 리스트는 하나로 병합된 연결 리스트가 된다.정리재귀 방식으로 리스트를 하나로 합치는 과정을 이해하는데 살짝 어려웠지만, 재귀로 구현된 코드는 코드의 길이가 짧고 풀이가 명확하다는 장점을 알게 되었다.📖 references 파이썬 알고리즘 인터뷰 - [책만]" }, { "title": "[알고리즘] 팰린드롬 연결 리스트", "url": "/posts/PalindromeList/", "categories": "algorithm", "tags": "algorithm, python", "date": "2023-09-14 00:00:00 +0800", "snippet": "문제연결 리스트가 팰린드롬 구조인지 판별하라.입력1 -&gt; 2출력false입력1 -&gt; 2 -&gt; 2 -&gt; 1출력true풀이1 (리스트 변환)파이썬 리스트의 pop()연산을 통해 연결 리스트의 입력을 리스트로 변환하여 풀 수 있다.먼저 연결 리스트를 구현한 ListNode클래스는 다음과 같다.# Definition for singly...", "content": "문제연결 리스트가 팰린드롬 구조인지 판별하라.입력1 -&gt; 2출력false입력1 -&gt; 2 -&gt; 2 -&gt; 1출력true풀이1 (리스트 변환)파이썬 리스트의 pop()연산을 통해 연결 리스트의 입력을 리스트로 변환하여 풀 수 있다.먼저 연결 리스트를 구현한 ListNode클래스는 다음과 같다.# Definition for singly-linked list.class ListNode: def __init__(self, x): self.val = x self.next = None클래스로 정의된 ListNode는 해당 노드의 값(self.val)과 다음 값이 연결될 노드(self.next)로 구성되어 있다.그래서 파이썬 리스트로 변환하여 풀이를 하면 다음과 같다.def isPalindrome(self, head: ListNode) -&gt; bool: q: List = [] if not head: return True node = head # 리스트 변환 while node is not None: q.append(node.val) node = node.next # 팰린드롬 판별 while len(q) &gt; 1: if q.pop(0) != q.pop(): return False return Trueq.pop(0) != q.pop()를 통해 앞뒤 값을 비교하고 팰린드롬인지를 판별할 수 있다.풀이 2 (데크를 이용한 최적화)앞서 풀이의 pop(0)는 첫 번째 값을 꺼내오면 모든 값이 한 칸씩 시프팅 되어 시간복잡도가 O(n)이 된다. 이는 deque에서 popleft()를 이용하여 맨 앞의 값을 꺼내오는 연산을 O(1)로 풀이 될 수 있다.def isPalindrome(self, head: ListNode) -&gt; bool: # 데크 자료형 선언 q: Deque = collections.deque() if not head: return True node = head while node is not None: q.append(node.val) node = node.next while len(q) &gt; 1: if q.popleft() != q.pop(): return False return True풀이 3 (런너를 이용한 우아한 풀이)런너(Runner)는 연결 리스트를 순회할 때 2개의 포인터를 동시에 사용하는 기법이다. 한 포인터가 다른 포인터보다 앞서게 하여 병합 지점이나 중간 위치, 길이 등을 판별할 때 유용하게 사용할 수 있다.위의 그림처럼 각각 빠른 런너, 느린 런너라고 부르는 포인터 2개가 있고, 빠른 런너는 두칸씩 이동하고, 느린 런너는 한칸 씩 이동한다. 이때 빠른 런너가 연결 리스트의 끝에 도달하면, 느린 런너는 정확히 연결 리스트의 중간 지점을 가르킨다. 이를 이용해 중앙값을 기준으로 앞뒤 문자가 같은지 확인하여 풀이할 수 있다.그래서 빠른런너와 느린런너의 이동을 코드로 나타내면 다음과 같다.fast = fast.next.nextslow = slow.next위와 같이 빠른런너와 느린런너가 이동하면서 빠른런너가 리스트의 끝에 도달할 때까지 진행하면서 rev라는 리스트에다가 역순으로 값을 삽입한다.while fast and fast.next: fast = fast.next.next rev, rev.next, slow = slow, rev, slow.next위와 같이 rev의 초기값은 None에서 시작하고, 느린 런너가 이동하면서 1→ None, 2 → 1 → None과 같이 역순으로 연결된다.그리고 만약 연결리스트의 길이가 홀수이면 느린 런너가 팰린드롬인지 확인하기 위해 한칸 앞으로 이동한다.if fast: slow = slow.next이 후 역순으로 런너를 통해 역순으로 구성된 rev와 slow의 런너를 통해 값이 일치하는지 확인하면 된다.while rev and rev.val == slow.val: slow, rev = slow.next, rev.next전체 코드는 다음과 같다.def isPalindrome(self, head: ListNode) -&gt; bool: rev = None slow = fast = head # 런너를 이용해 역순 연결 리스트 구성 while fast and fast.next: fast = fast.next.next rev, rev.next, slow = slow, rev, slow.next if fast: slow = slow.next # 팰린드롬 여부 확인 while rev and rev.val == slow.val: slow, rev = slow.next, rev.next return not rev정리리스트에서의 연산 pop()연산을 deque popleft()연산을 통해 시간 복잡도를 O(1)로 줄일 수 있었고 런너를 활용한 풀이에서 빠른 런너가 리스트 끝에 도달했을 때 느린 런너가 중장지점에 온다는 것을 이용하여 역순으로 리스트로 구성해 팰린드롬인지 판별하는 방법도 알아보았다. 풀이 3개중에는 마지막에 풀이한 런너를 이용한 풀이가 가장 빠르게 실행되는 것을 알 수 있었다.📖 references 파이썬 알고리즘 인터뷰 - [책만]" }, { "title": "[알고리즘] 자신을 제외한 배열의 곱", "url": "/posts/ArrayExceptSelf/", "categories": "algorithm", "tags": "algorithm, python", "date": "2023-09-04 00:00:00 +0800", "snippet": "문제배열을 입력받아 output[i]가 자신을 제외한 나머지 모든 요소의 곱셈 결과가 되도록 출력하라.(단, 나눗셈을 사용하지 않고 O(n)에 풀이하라)입력[1,2,3,4]출력[24, 12, 8, 6]풀이 (왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈)이 문제의 제약사항인 나눗셈을 사용하지 않고 O(n)에 풀이하라고 했는데, 이는 전체 곱셈을 하고나서...", "content": "문제배열을 입력받아 output[i]가 자신을 제외한 나머지 모든 요소의 곱셈 결과가 되도록 출력하라.(단, 나눗셈을 사용하지 않고 O(n)에 풀이하라)입력[1,2,3,4]출력[24, 12, 8, 6]풀이 (왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈)이 문제의 제약사항인 나눗셈을 사용하지 않고 O(n)에 풀이하라고 했는데, 이는 전체 곱셈을 하고나서 각 항목별로 자기 자신을 나눠서 풀이하지 말라는 뜻이다. 그러면 자기 자신을 제외하고 왼쪽의 곱셈 결과와 오른쪽의 곱셈 결과를 곱하면 된다.먼저 왼쪽부터 차례대로 곱해서 p=1로 시작하여 out 리스트 변수에 담아 결과는 [1,1,2,6]이 된다. 코드는 아래와 같다.out = []p = 1# 왼쪽 곱셈for i in range(0, len(nums)): out.append(p) p = p * nums[i]이 후 오른쪽에서 왼쪽으로 이동하여 곱셈 결과를 누적한다. 코드는 아래와 같다.p = 1# 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈for i in range(len(nums) - 1, - 1, -1): out[i] = out[i] * p p = p * nums[i]여기서 만약 별도의 리스트 변수를 새로 만들어 곱셈 결과를 넣으면 공간 복잡도가 O(n)이 된다. 그러나 기존 out 리스트 변수에 곱셈을 하게 되면 공간복잡도가 O(1)이 되게 되어 효율적으로 풀이가 가능하다. 아래는 i가 왼쪽으로 이동하면서 out변수와 p의 변수의 변화량이다.전체 코드는 아래와 같다.def productExceptSelf(self, nums: List[int]) -&gt; List[int]: out = [] p = 1 # 왼쪽 곱셈 for i in range(0, len(nums)): out.append(p) p = p * nums[i] p = 1 # 왼쪽 곱셈 결과에 오른쪽 값을 차례대로 곱셈 for i in range(len(nums) - 1, 0 - 1, -1): out[i] = out[i] * p p = p * nums[i] return out정리처음엔 O(n)으로 풀이가 쉽게 떠올리지는 않았지만 왼쪽으로 이동한 곱셈값과 오른쪽으로 이동한 곱셈값을 곱하여 풀이가 가능하다라는 것을 배웠고, 공간복잡도도 O(n)으로 풀이된다는 것도 배웠다.📖 references 파이썬 알고리즘 인터뷰 - [책만]" }, { "title": "[알고리즘] 빗물 트래핑", "url": "/posts/RainWaterTrapping/", "categories": "algorithm", "tags": "algorithm, python", "date": "2023-08-25 00:00:00 +0800", "snippet": "문제높이를 입력받아 비 온 후 얼마나 많은 물이 쌓일 수 있는지 계산하라.입력[0,1,0,2,1,0,1,3,2,1,2,1]출력6풀이 1 (투포인터 이용)이 문제는 투포인터를 이용하여 풀이가 가능하다.왼쪽에서 출발하는 왼쪽 포인터와 오른쪽에서 출발하는 오른쪽 포인터를 두고, 최대 높이 지점까지 가운데로 이동한다. 포인터들이 이동하면서 최대높이를 기록해놓...", "content": "문제높이를 입력받아 비 온 후 얼마나 많은 물이 쌓일 수 있는지 계산하라.입력[0,1,0,2,1,0,1,3,2,1,2,1]출력6풀이 1 (투포인터 이용)이 문제는 투포인터를 이용하여 풀이가 가능하다.왼쪽에서 출발하는 왼쪽 포인터와 오른쪽에서 출발하는 오른쪽 포인터를 두고, 최대 높이 지점까지 가운데로 이동한다. 포인터들이 이동하면서 최대높이를 기록해놓고, 현재 포인터 위치의 높이와 비교하여 그 차이를 volume변수에 저장하여 기록해나간다. 그 코드는 다음과 같다.# 빗물의 양을 저장하는 변수volume = 0# 왼쪽 포인터와 오른쪽 포인터left, right = 0, len(height) - 1# 이동하면서 최대높이를 기록하는 변수 left_max, right_maxleft_max, right_max = height[left], height[right]while left &lt; right: left_max, right_max = max(height[left], left_max), max(height[right], right_max) # 더 높은 쪽을 향해 투 포인터 이동 if left_max &lt;= right_max: volume += left_max - height[left] left += 1 else: volume += right_max - height[right] right -= 1while문을 돌면서 두개의 포인터가 최대지점에서 만날때 까지 높이가 낮은쪽에서 높은쪽으로 이동해 나간다.아래 표를 보면 포인터 두개가 이동하면서 이동하면서 기록한 최대 높이(left_max, right_max)와 빗물의 양(volume) 값의 변화다.위와 같이 이동하여 좌우 포인터는 최대지점에서 만나게 되며, 시간 복잡도는 O(n)이 된다.전체코드def trap(self, height: List[int]) -&gt; int: if not height: return 0 volume = 0 left, right = 0, len(height) - 1 left_max, right_max = height[left], height[right] while left &lt; right: left_max, right_max = max(height[left], left_max), max(height[right], right_max) if left_max &lt;= right_max: volume += left_max - height[left] left += 1 else: volume += right_max - height[right] right -= 1 return volume풀이 2 (스택 쌓기)스택을 이용하여 풀이는 스택에 높이를 삽입하면서 만약 현재 높이가 이전 높이보다 높을 때 그 격차 만큼 물높이 volume 변수에 기록해나간다. volume은 가로(distance), 세로(waters)의 길이를 곱해서 volume 변수에 계속 더해나간다. volume과 이에 해당하는 변수들의 변화량은 다음과 같다.전체코드는 다음과 같다.def trap(self, height: List[int]) -&gt; int: stack = [] volume = 0 for i in range(len(height)): # 변곡점을 만나는 경우 while stack and height[i] &gt; height[stack[-1]]: # 스택에서 꺼낸다 top = stack.pop()\t\t\t\t\t# 스택이 비어있는 경우 break -&gt; 이전에 벽이 없기 때문에 물이 고여있지않아 측정하지 않음 if not len(stack): break # 이전과의 차이만큼 물 높이 처리\t\t\t\t\t# 가로 길이 측정 distance = i - stack[-1] - 1\t\t\t\t\t# 세로 길이 측정(현재 높이와 스택에서의 높이 중 작은 값을 선택해 이전의 높이와 차를 구함) waters = min(height[i], height[stack[-1]]) - height[top]\t\t\t\t\t# 가로 X 높이 = 물의 양 volume += distance * waters stack.append(i)\treturn volume스택으로 코드를 구현하면 while문 안에서 이전 항목들을 되돌아보며 체크하기는 하지만, 전체 수행은 한번만 하기 때문에 시간복잡도는 O(n)에 풀이가 가능하다.정리두가지 풀이 방법으로 모두 풀어보았고, 시간복잡도는 모두 O(n)이 나오게 됐다. 코드이해가 상당히 어려웠지만 차근차근 수행과정을 살펴보니 이해되었다.📖 references 파이썬 알고리즘 인터뷰 - [책만]" }, { "title": "[알고리즘] 가장 긴 팰린드롬 부분 문자열", "url": "/posts/LongestPalindrome/", "categories": "algorithm", "tags": "algorithm, python", "date": "2023-08-20 00:00:00 +0800", "snippet": "문제가장 긴 팰린드롬 부분 문자열을 출력하라입력\"babad\"\"cbbd\"출력\"bab\"\"bb\"풀이 (중앙을 중심으로 확장하는 풀이)팰린드롬을 판별하기 위해, 포인터가 이동하면서 만약 포인터의 문자가 같을 때 중앙을 중심으로 점점 확장해 나가면서 가장 긴 팰린드롬을 찾을 수 있다.방법을 자세히 설명하자면, 크기가 2개와 3개로 구성된 두개의 포인터가 앞으로...", "content": "문제가장 긴 팰린드롬 부분 문자열을 출력하라입력\"babad\"\"cbbd\"출력\"bab\"\"bb\"풀이 (중앙을 중심으로 확장하는 풀이)팰린드롬을 판별하기 위해, 포인터가 이동하면서 만약 포인터의 문자가 같을 때 중앙을 중심으로 점점 확장해 나가면서 가장 긴 팰린드롬을 찾을 수 있다.방법을 자세히 설명하자면, 크기가 2개와 3개로 구성된 두개의 포인터가 앞으로 전진해나가는 방식이다. 2개로 구성된 포인터는 한칸씩 전진하고, 3개로 구성된 포인터는 2칸씩 전진한다. 이 방식은 슬라이딩 윈도우라고 부르며, 이때 윈도우에 들어온 문자열이 팰린드롬인 경우 그자리에서 멈추고 투포인터가 양옆으로 점점 확장해 나가는 방식이다.위의 그림과 같이 포인터가 이동하면서 팰린드롬인지 확인하며, 위의 그림에서는 홀수 포인터가 “454”라는 팰린드롬을 확인하고, 이 지점에서 왼쪽과 오른쪽으로 점차 확장해나가며 팰린드롬 중 가장 긴 팰린드롬을 찾아나간다.코드로 살펴보면 다음과 같다.result = ''for i in range(len(s) - 1): result = max(result, expand(i, i + 1), expand(i, i + 2), key=len)먼저 짝수와 홀수 포인터가 이동하면서 가장 긴 팰린드롬인지 expand()함수로 확인하고, 그 중에서 가장 긴 문자열을 result변수에 담아 마지막에 최종적으로 result를 반환하게 된다.여기서 max(key = len) 은 시퀀스중에서 가장 길이가 큰 요소를 반환해준다.def expand(left: int, right: int) -&gt; str: while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right]이 expand()함수에서는 만약 왼쪽과 오른쪽의 문자가 같다면 이 위치에서 양 옆으로 확장해 나가 가장 긴 팰린드롬을 찾을 수 있게 해준다.만약 문자열 입력이 “babab”이라면, 팰린드롬을 판별하는 방식(홀수개의 팰린드롬인 경우)은 아래와 같다.i = 0일 때 expand(0,2)가 호출되면서 s[0]과 s[2]의 문자가 같으므로 이 위치에서 양 옆으로 확장해 나간다. 이 예에서는 “bab”로 반환이 된다. (”aba”도 해당)문자열 입력이 “cbbd”일때, 판별하는 방식이다.이 예는 짝수개의 팰린드롬을 판별하는 방식이며 마찬가지로 가장 긴 팰린드롬을 반환해주는것을 확인할 수 있다.전체 코드는 아래와 같다.\tdef longestPalindrome(self, s: str) -&gt; str: # 팰린드롬 판별 및 투 포인터 확장 def expand(left: int, right: int) -&gt; str: while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] # 해당 사항이 없을때 빠르게 리턴 if len(s) &lt; 2 or s == s[::-1]: return s result = '' # 슬라이딩 윈도우 우측으로 이동 for i in range(len(s) - 1): result = max(result, expand(i, i + 1), expand(i, i + 2), key=len) return result정리포인터가 이동하면서 팰린드롬인지 확인하는 형태인 투 포인터에 대해서 배웠고, 파이썬의 내장 함수인 max(len=key)가 시퀀스(리스트, 문자열, 튜플 등) 중에서 가장 길이가 큰 요소를 찾을 때 사용하는 방법 중 하나라는 것을 알게되었다.📖 references 파이썬 알고리즘 인터뷰 - [책만]" }, { "title": "[알고리즘] 로그 파일 재정렬", "url": "/posts/LogfileSort/", "categories": "algorithm", "tags": "algorithm, python", "date": "2023-08-15 00:00:00 +0800", "snippet": "문제로그를 재정렬하라. 기준은 다음과 같다. 로그의 가장 앞부분은 식별자다. 문자로 구성된 로그가 숫자 로그보다 앞에 온다. 식별자는 순서에 영향을 끼치지 않지만, 문자가 동일할 경우 식별자 순으로 한다. 숫자 로그는 입력 순서대로 한다.입력logs = [\"dig1 8 1 5 1\", \"let1 art can\", \"dig2 3 6\", \"let2 ...", "content": "문제로그를 재정렬하라. 기준은 다음과 같다. 로그의 가장 앞부분은 식별자다. 문자로 구성된 로그가 숫자 로그보다 앞에 온다. 식별자는 순서에 영향을 끼치지 않지만, 문자가 동일할 경우 식별자 순으로 한다. 숫자 로그는 입력 순서대로 한다.입력logs = [\"dig1 8 1 5 1\", \"let1 art can\", \"dig2 3 6\", \"let2 own kit dig\", \"let3 art zero\"]출력[\"let1 art can\", \"let3 art zero\",\"let2 own kit dig\", \"dig1 8 1 5 1\", \"dig2 3 6\"]풀이 (람다와 + 연산자 사용)먼저 문제의 조건에서 문자로 구성된 로그가 숫자 로그보다 이전에 오며, 숫자 로그는 입력 순서대로 둔다.문자와 숫자를 구분해서 따로 저장하고, 정렬된 문자에 숫자를 이어 붙이면 된다. 받은 문자열에서 숫자인지 아닌지 판단은 isdigit()을 사용한다.for log in logs: # logs는 입력받은 문자열\tif log.split()[1].isdigit():\t\tdigits.append(log)\telse:\t\tletters.append(log)여기서 log.split()[1]은 받은 문자열에서 식별자를 제외하면 1번째 값으로, 이 값이 숫자이면 digits 리스트에 보관해 맨 나중에 letters 리스트가 순서가 정해지면 뒤에 붙이면 된다.그래서 digits에 저장된 값을 출력해보면 다음과 같다.print(digits)['dig1 8 1 5 1', 'dig2 3 6']이후 문자 로그는 letters에 모두 모였으므로 다음 같이 정렬하면 된다.letters.sort(key=lambda x: (x.split()[1:], x.split()[0]))람다식을 이용하여 문자열에서 맨 첫번째 식별자를 제외한 첫번째 문자열부터 정렬하고, 동일한 경우 후순위 식으로 [0]를 지정해 정렬한다. 그래서 키는 [1:]로 정렬하고, 후순위 식은 [0]이 된다. 이후 문자로그와 숫자가 포함된 로그를 이어 붙여 반환하면 해결할 수 있다.return letters + digits전체 코드는 다음과 같다.def reorderLogFiles(self, logs: List[str]) -&gt; List[str]: letters, digits = [], [] for log in logs: if log.split()[1].isdigit(): digits.append(log) else: letters.append(log) # 두 개의 키를 람다 표현식으로 정렬 letters.sort(key=lambda x: (x.split()[1:], x.split()[0])) return letters + digits정리람다식에서 키를 지정해서 정렬할 수 있고, 후 순위로도 정렬할 수 있다는 것을 배웠다. 람다식을 사용하여 정렬하니 코드가 짧아지고 간결해지는 장점이 있어 정렬에 유용하게 쓰면 좋을 것 같다.📖 references 파이썬 알고리즘 인터뷰 - [책만]" }, { "title": "[알고리즘] 유효한 팰린드롬", "url": "/posts/ValidPalindrome/", "categories": "algorithm", "tags": "algorithm, python", "date": "2023-08-14 00:00:00 +0800", "snippet": "문제주어진 문자열이 팰린드롬인지 확인하라. 대소문자를 구분하지 않으며. 영문자와 숫자만을 대상으로 한다.입력\"A man, a plan, a canal: Panama\"출력true팰린드롬(Palindrome)이란?앞뒤가 똑같은 단어나 문장으로, 뒤집어도 같은 말이 되는 단어 또는 문장을 팰린드롬(Palindrome)이라고 한다.풀이1먼저 문자열을 입력받고...", "content": "문제주어진 문자열이 팰린드롬인지 확인하라. 대소문자를 구분하지 않으며. 영문자와 숫자만을 대상으로 한다.입력\"A man, a plan, a canal: Panama\"출력true팰린드롬(Palindrome)이란?앞뒤가 똑같은 단어나 문장으로, 뒤집어도 같은 말이 되는 단어 또는 문장을 팰린드롬(Palindrome)이라고 한다.풀이1먼저 문자열을 입력받고, 이 문자열 중, 문자인 것만 따로 배열에 추가한다. 문자인것을 판별하는 isalnum() 함수를 사용하고, 대소문자를 구분하지 않으므로 입력받은 문자열을 모두 lower()로 소문자로 변환하고 리스트에 추가한다.strs = []for char in s: # s는 입력받은 문자열\tif char.isalnum():\t\tstrs.append(char.lower())위의 코드로 입력값을 받은 후 strs을 print()로 출력하게 되면 arr에 담긴 리스트를 다음과 같이 확인할 수 있다.['a', 'm', 'a', 'n', 'a', 'p', 'l', 'a', 'n', 'a', 'c', 'a', 'n', 'a', 'l', 'p', 'a', 'n', 'a', 'm', 'a']이 후 펠린드롬 여부를 다음과 같이 판별한다.while len(arr) &gt; 1:\tif arr.pop(0) != arr.pop():\t\t\treturn Falsereturn True파이썬 리스트의 함수인 pop(0)이용하여 맨앞의 값과 pop()을 이용하여 마지막 값을 매칭하가면서 만약 일치하지 않은 경우, 펠린드롬이 아니라고 판단하여 False를 반한한다. 만약 while문을 모두 수행했다면 True를 반환한다.전체 코드는 아래와 같다.def isPalindrome(self, s: str) -&gt; bool: strs = [] for char in s: if char.isalnum(): arrstrsappend(char.lower()) # 팰린드롬 여부 판별 while len(strs) &gt; 1: if strs.pop(0) != strs.pop(): return False return True 풀이 2 (deque 자료형을 이용한 풀이)위의 풀이1처럼 pop(0)연산을 사용하게 되면 첫 번째 값을 꺼내고, 그 안에서 재정렬이 일어나기 때문에 시간복잡도가 O(n)이 되게 된다. 이 연산 시간을 줄이기 위해 deque의 popleft()를 사용하여 해결할 수 있다.from collections import dequedef isPalindrome(self, s: str) -&gt; bool: # 자료형 데크로 선언 strs: Deque = collections.deque() for char in s: if char.isalnum(): strs.append(char.lower()) while len(strs) &gt; 1: if strs.popleft() != strs.pop(): return False return True풀이 1처럼 리스트를 이용해 구현하고, n번씩 반복하면 시간 복잡도가 O(n^2)이 나오게 되지만, deque를 이용해 구현하게 되면 O(n)으로 성능이 개선되는것을 볼 수 있다.풀이 3 (슬라이싱 사용)슬라이싱을 이용하여 문제를 풀면 코드는 다음과 같다.import redef isPalindrome(self, s: str) -&gt; bool: s = s.lower() # 정규식으로 불필요한 문자 필터링 s = re.sub('[^a-z0-9]', '', s) return s == s[::-1] # 슬라이싱s = re.sub('[^a-z0-9]', '', s)를 이용해 정규식으로 불필요한 문자를 필터링 한다음, 파이썬의 슬라싱을 이용하여 앞뒤가 똑같은 문자열인지 판별할 수 있다.파이썬의 슬라이싱에서 [::-1]을 이용하여 리스트를 뒤집을 수 있다.정리유효한 펠린드롬 문제를 3가지 풀이 방법으로 알아보았다. 3가지 풀이 방법 중에서 풀이 3인 슬라이싱을 이용한 풀이 방법이 가장 빠르게 실행되었으며, 슬라이싱을 사용하면 내부적으로 C로 빠르게 구현되어있어 훨씬 더 좋은 속도를 보여주었다.📖 references 파이썬 알고리즘 인터뷰 - [책만]" }, { "title": "[JPA] 영속성 컨텍스트", "url": "/posts/PersistenceContext/", "categories": "JPA", "tags": "java, ORM, JPA", "date": "2023-08-07 00:00:00 +0800", "snippet": "엔티티 매니저 팩토리와 엔티티 매니저엔티티 매니저 팩토리는 이름 그대로 엔티티 매니저를 만드는 공장이고, 엔티티 매니저는 엔티티를 저장하고, 수정하고, 삭제하고, 조회하는 등 엔티티와 관련된 모든일을 처리하는 엔티티를 관리하는 관리자이다.영속성 컨텍스트란?영속성 컨텍스트(Persistence Context)는 논리적인 개념으로 엔티티를 영구 저장하는 ...", "content": "엔티티 매니저 팩토리와 엔티티 매니저엔티티 매니저 팩토리는 이름 그대로 엔티티 매니저를 만드는 공장이고, 엔티티 매니저는 엔티티를 저장하고, 수정하고, 삭제하고, 조회하는 등 엔티티와 관련된 모든일을 처리하는 엔티티를 관리하는 관리자이다.영속성 컨텍스트란?영속성 컨텍스트(Persistence Context)는 논리적인 개념으로 엔티티를 영구 저장하는 환경이다.EntityManger.persist(entity);persist()는 엔티티 객체를 DB에 저장하는게 아니라 영속성 컨텍스트라는 곳에 저장한다. 즉, 엔티티 메니저를 통해 영속성 컨텍스트에 접근한다!엔티티 메니저를 생성하면 영속성 컨텍스트와 1:1로 존재하게 된다.엔티티의 생명주기 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태//객체를 생성한 상태(비영속)Member member = new Member();member.setId(\"member1\");member.setUserName(\"회원1\"); 영속(managed) : 영속성 컨텍스트에 관리되는 상태//객체를 생성한 상태(비영속)Member member = new Member();member.setId(\"member1\");member.setUserName(\"회원1\");EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");EntityManager em = new emf.createEntityManager();em.getTransaction().begin();//객체를 저장한 상태(영속)em.persist(member); 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태Member member = em.find(Member.class, 150L);member.setName(\"AAA\");em.detach(member); 삭제(removed) : 삭제된 상태Member member = em.find(Member.class, 150L);member.setName(\"AAA\");em.remove(member);영속성 컨텍스트의 이점영속성 컨텍스트는 자바 어플리케이션과 DB중간에 있는 매개체로 다음과 같은 이점들이 있다.1. 1차 캐시영속성 컨텍스트는 내부에 1차 캐시가 있다. 이해를 위해 아래의 코드를 보자//객체를 생성한 상태(비영속)Member member = new Member();member.setId(\"member1\");member.setUserName(\"회원1\");//엔티티를 영속em.persist(member);Member객체 생성 후 em.persist(member)를 실행하면 Member 데이터가 영속성 컨텍스트 내부에 1차캐시에 저장된다. 엔티티를 생성할 때 키로 매핑한 @ID와 엔티티 인스턴스로 key-value형태로 저장된다.이 상태에서 만약 회원객체를 조회하면 어떤 일이 일어날까?Member member = new Member();member.setId(\"member1\");member.setUserName(\"회원1\");//영속em.persist(member);Member findMember = em.find(Member.class, );em.find()로 조회하면 JPA는 영속성 컨텍스트에서 1차 캐시에 member객체가 있는지 확인한다. 1차 캐시에 만약 member엔티티가 존재하면 1차캐시에서 값을 조회해온다.근데 만약 아래의 코드로 member2를 조회해오면Member findMember2 = em.find(Member.class, \"member2\");member2는 1차 캐시에 존재하지 않기 때문에 DB에서 member2를 조회한 후 1차 캐시에 저장한다. 그 후 member2를 반환한다. 위의 예처럼 1차캐시를 둠으로써 필요한 데이터를 조회했을 때 데이터가 1차 캐시에 존재하면 DB에 안거치고 데이터를 반환할 수 있다!2. 영속 엔티티의 동일성 보장Member a = em.find(Member.class, \"member1\");Member b = em.find(Member.class, \"member1\");System.out.println(a == b); //동일성 비교 true위의 코드를 실행하면 결과는 true가 반환된다. 마치 자바 컬렉션에서 꺼내서 똑같은 레퍼런스가 있는 객체를 꺼내면 ==비교했을때 true가 나오는것처럼 영속 엔티티도 1차 캐시에 존재했기 때문에 동일성을 보장해준다.3. 쓰기 지연(transactional write-behind)영속성 컨텍스트안에는 1차캐시외에 쓰기지연 SQL 저장소라는곳이 있다. 위의 그림처럼 em.persist(memberA)로 영속성 컨텍스트에 넣으면 memberA가 1차캐시에 보관된다. 그러면서 동시에 JPA는 memberA엔티티를 분석해서 INSERT쿼리를 생성한다. 그 후 쓰기지연 SQL저장소에 쌓아둔다.또한 memberB를 persist()하게 되면 1차캐시에 저장되고, JPA는 INSERT쿼리를 쓰기지연 SQL저장소에 보관하게 된다.보내그 후 transaction을 commit()하게 되면 쓰지 지연 SQL저장소에 있던 SQL문들이 DB에 보내지게 된다. 그래서 실제 데이터베이스 트랜잭션이 commit되게 된다.이와 같은 과정을 코드로 보면 아래와 같다.public class Main { public static void main(String[] args) { EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\"); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try { Member member1 = new Member(150L, \"A\"); Member member2 = new Member(160L, \"B\"); em.persist(member1); em.persist(member2); System.out.println(\"===========\");\t\t\t\t\t\ttx.commit(); //커밋하는 시점에 db에 쿼리가 날라감 } catch (Exception e) { tx.rollback(); } finally { em.close(); } emf.close(); }}//실행결과===========Hibernate: /* insert hellojpa.Member */ insert into Member (username, id) values (?, ?)Hibernate: /* insert hellojpa.Member */ insert into Member (username, id) values (?, ?)위의 결과처럼 persist()후 commit()시점에 INSERT쿼리가 2번 나갔다는것을 확인할 수 있다. 즉, 영속성 컨텍스트를 통해 버퍼링의 기능을 사용할 수 있다. 데이터베이스 커밋직전에만 INSERT쿼리가 나가면 되기 때문에 한번에 모아서 쿼리가 날라가면 버퍼링의 이점을 얻을 수 있다!3. 엔티티 수정(변경 감지)EntityManager em = emf.createEntityManager();EntityTransaction transaction = em.getTransaction();transaction.begin(); // [트랜잭션] 시작// 영속 엔티티 조회Member memberA = em.find(Member.class, \"memberA\");// 영속 엔티티 데이터 수정memberA.setUsername(\"hi\");memberA.setAge(10);////em.update(member)transaction.commit(); // [트랜잭션] 커밋현재 em.persist()나 em.update()같은 JPA에게 변경되었다라는 거를 알려주지 않아도 지금 위의 코드를 실행하면 DB에 변경사항이 잘 들어간거를 확인할 수 있다. 그 이유는 다음 그림과 같다.JPA는 내부적으로 Dirty checking이라는 것을 한다. JPA는 데이터베이스 트랜잭션을 커밋하는 시점에 내부적으로 flush()가 호출된다. flush()가 호출되면 엔티티와 스냅샷을 비교한다. 사실 1차 캐시안에는 @ID, Entity, 스냅샷이라는것으로 보관한다. 스냅샷은 최초 시점에 영속성 컨텍스트에 읽어온 값인다. 이렇게 해놓은 상태에서 memberA값을 변경하면 JPA가 커밋시점에 스냅샷과 비교하게 된다. 비교 한뒤 만약 memberA의 값이 바뀌었다면 UPDATE쿼리를 쓰기지연SQL저장소에 넣어두고 업데이트 쿼리를 데이터베이스에 반영하고 커밋하게 된다.flush플러시는 영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는 작업이다.영속성 컨텍스트를 플러시하는 방법은 3가지가 있다. em.flush() - 플러시 수동 호출 transaction.commit() - 플러시 자동 호출 JPQL 쿼리 실행 - 플러시 자동 호출다음 코드는 플러시를 수동으로 호출한 코드이다.public class Main { public static void main(String[] args) { EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\"); EntityManager em = emf.createEntityManager(); EntityTransaction tx = em.getTransaction(); tx.begin(); try { Member member1 = new Member(150L, \"A\");\t em.persist(member1);\t\t\t\t\t\tem.flush(); //플러시 강제 호출\t System.out.println(\"===========\");\t\t\t\t\t\ttx.commit(); } catch (Exception e) { tx.rollback(); } finally { em.close(); } emf.close(); }}//실행결과Hibernate: /* insert hellojpa.Member */ insert into Member (username, id) values (?, ?)===========위의 결과처럼 commit()전에 flush()로 INSERT쿼리가 DB에 나가는것을 확인할 수 있다. 플러시를 하면 1차캐시를 비우는게 아니라 영속성 컨텍스트안에 쓰기지연 SQL저장소에서 데이터들이 바뀐 것이 DB에 반영하는 작업이다!즉, 플러시는 영속성 컨텍스트의 변경내용을 데이터베이스에 동기화하는 작업이다!!준영속 상태준영속 상태란 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 상태(detached)를 뜻한다.아래의 명령어로 엔티티를 준영속상태로 전환할 수 있다.em.detach(entity); //특정 엔티티만 준영속 상태로 전환em.clear() // 영속성 컨텍스트를 완전히 초기화em.close() //영속성 컨텍스트를 종료📖 references 자바 ORM 표준 JPA 프로그래밍 -기본편 by 김영한" }, { "title": "[자바의정석] 예외처리", "url": "/posts/Java_Exception/", "categories": "java", "tags": "java", "date": "2023-07-14 00:00:00 +0800", "snippet": "프로그램 오류프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있다. 이러한 결과를 초래하는 원인을 프로그램 에러 또는 오류라고 한다. 이를 발생 시점에 따라 컴파일 에러와 런타임 에러로 나뉜다. 컴파일 에러 : 컴파일 할 때 발생하는 에러 런타임 에러 : 실행 시 발생하는 에러 논리적 에러 : 실행은 되지만, ...", "content": "프로그램 오류프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나 비정상적으로 종료되는 경우가 있다. 이러한 결과를 초래하는 원인을 프로그램 에러 또는 오류라고 한다. 이를 발생 시점에 따라 컴파일 에러와 런타임 에러로 나뉜다. 컴파일 에러 : 컴파일 할 때 발생하는 에러 런타임 에러 : 실행 시 발생하는 에러 논리적 에러 : 실행은 되지만, 의도와 다르게 동작하는 것.컴파일 에러는 프로그램 실행 전에 오류를 검사해줘서 걸러줄 수 는 있지만, 런타임 에러는 프로그램 실행 중에 잠재적인 오류까지 검사할 수 는 없다. 따라서 자바에서는 런타임 에러를 방지하기 위해 실행 시 발생할 수 있는 프로그램 오류를 에러와 예외 두가지로 구분한다.에러는 메모리 부족이나 스택 오버플로우 같은 복구할 수 없는 심각한 오류를 말하고, 예외는 발생하더라도 수습될 수 있는 상황을 말한다. 따라서 예외는 발생하더라고 프로그래머가 적절한 코드를 작성해 프로그램의 비정상적인 종료를 막을 수 있다.예외 클래스의 계층 구조자바에서는 실행 시 발생할 수 있는 오류를 클래스로 정의하였다. Exception과 Error클래스의 조상 Object클래스로 이루져 있는 구조다.모든 예외의 최고 조상은 Exception클래스이며, 상슥계층도를 Exception클래스로부터 도식화하면 다음과 같다.위의 사진에서 볼 수 잇듯이 예외 클래스는 Exception클래스와 그 자손들, RuntimeException클래스와 그 자손들로 나눠진다.RuntimeException들은 주로 프로그래머의 실수에 의해서 발생될 수 있는 예외들로 예를 들면, 배열의 범위를 번어난 ArrayIndexOutOfBoundsException, 값이 null인 참조변수의 멤버를 호출한 NullPointerException 등이 발생한다.Exception클래스들은 주로 외부의 영향으로 발생할 수 있는 것들로서, 프로그램의 사용자들의 동작에 의해서 발행하는 경우가 많다. 예를 들면 존재하지 않는 파일의 이름을 입력했다던가(FileNotFoundException),실수로 클래스의 이름을 잘못 적었다던가(ClassNotFoundException)인 경우에 발생한다.예외처리하기 try-catch문예외처리(error handling)란, 프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것이며, 예외처리의 목적은 예외의 발생으로 인한 실행중인 프로그램의 갑작스런 비정상 종료를 막고, 정상적인 실행상태를 유지할 수 있도록 하는 것이다.예외를 처리하기 위한 try-catch문의 구조는 다음과 같다.class ExceptionEx1 {\tpublic static void main(String[] args) {\t\ttry {\t\t\ttry\t{\t} catch (Exception e)\t{ }\t\t} catch (Exception e)\t{\t\t\ttry\t{\t} catch (Exception e) { }\t// 에러. 변수 e가 중복 선언되었다.\t\t} // try-catch의 끝\t\ttry {\t\t} catch (Exception e)\t{\t\t} // try-catch의 끝\t}\t// main메서드의 끝}catch블럭 내의 코드에서도 예외가 발생할 수 있기 때문에 try-catch문에 또 다른 try-catch문을 사용할 수 있다. 여기서 try-catch문에 또 다른 try-catch문을 사용할 경우 같은 이름의 참조변수를 사용하면 참조변수의 영역이 서로 겹치므로 다른 이름으로 사용해야 한다.ch8/Exception2.javaclass ExceptionEx2 {\tpublic static void main(String args[]) {\t\tint number = 100;\t\tint result = 0;\t\tfor(int i=0; i &lt; 10; i++) {\t\t\tresult = number / (int)(Math.random() * 10);\t\t\tSystem.out.println(result);\t\t}\t} // main의 끝}//실행결과20100java.lang.AritihimaticExcetpion : / by zero\t\tat ExceptionEx2.main (ExceptionEx2.java : 7)위의 예제는 100을 0~9사이의 랜덤수로 나눈 결과를 출력하는 일을 10번한다. random()을 사용하여 매번 실행할 때마다 결과가 달라지겠지만, 대부분 10번이 출력되기 전에 예외가 발생하여 프로그램이 비정상적으로 종료될 것이다.위의 결과는 ArithmeticException이 발생하였고, 이 오류는 산술과정에서 오류가 있을 때 발생하는 예외이다. 정수는 0으로 나누는 것이 금지 되었기 때문에 발생한 것이다.이 오류를 try-catch문으로 예외가 발생하지 않게 코드를 아래와 같이 구성할 수 있다.class ExceptionEx3 {\tpublic static void main(String args[]) {\t\tint number = 100;\t\tint result = 0;\t\tfor(int i=0; i &lt; 10; i++) {\t\t\ttry {\t\t\t\tresult = number / (int)(Math.random() * 10);\t\t\t\tSystem.out.println(result);\t\t\t} catch (ArithmeticException e)\t{\t\t\t\tSystem.out.println(\"0\");\t\t\t\t} \t\t}\t} }이렇게 작성하면 오류가 발생해도 catch구문에서 오류를 잡아주기 때문에 프로그램이 오류나지 않고 정상적으로 실행되게 된다.예외의 발생과 catch블럭catch블럭은 ()와 {}로 구성되는데 괄호 내에는 처리하고자 하는 예외와 같은 타입의 참조변수 하나를 선언해야 한다.예외가 발생하면 동작 순서는 다음과 같다. 발생한 예외에 해당하는 클래스의 인스턴스가 만들어진다. 예외가 발생한 문장이 try블럭에 포함되어 있다면, 이 예외를 처리할 수 있는 catch블럭 있는지 찾는다. catch블럭을 찾으면서 catch블럭의 괄호()내에 선언된 참조변수의 종류와 생성된 예외 클래스의 인스턴스에 instanceof연산자를 이용해서 검사하게 되는데, 검사결과가 true인 catch블럭을 만날때까지 검사는 계속된다. 검사결과가 true인 catch블럭을 찾게 되면, 블럭에 있는 문장들을 모두 수행한 후에 try-catch문을 빠져나가고 예외는 처리되지만, 검사결과가 true인 catch블럭이 하나도 없으면 예외는 처리되지 않는다.예제를 통해 살펴보자.class ExceptionEx7 {\tpublic static void main(String args[]) {\t\tSystem.out.println(1);\t\t\t\t\tSystem.out.println(2);\t\ttry {\t\t\tSystem.out.println(3);\t\t\tSystem.out.println(0/0);\t\t\tSystem.out.println(4); \t\t// 실행되지 않는다.\t\t} catch (ArithmeticException ae)\t{\t\t\tif (ae instanceof ArithmeticException) \t\t\t\tSystem.out.println(\"true\");\t\t\t\tSystem.out.println(\"ArithmeticException\");\t\t} catch (Exception e)\t{\t\t\tSystem.out.println(\"Exception\");\t\t}\t// try-catch의 끝\t\tSystem.out.println(6);\t}\t// main메서드의 끝}try블럭에서 ArithmeticException이 발생해서 catch블럭을 하나씩 차례로 검사하게 되는데, 첫 번째 검사에서 일치하는 catch블럭을 찾았기 때문에 두 번째 catch블럭은 검사하지 않는다.예외 발생시키기throw 키워드를 사용해 프로그래머가 고의로 예외로 발생시킬 수 있으며, 방법은 아래와 같다. 먼저 연산자 new를 이용하여 발생시키려는 예외 클래스의 객체를 만든다.Exception e = new Exception(\"고의로 발생시켰음\"); 키워드 throw를 이용해 예외를 발생시킨다.throw e;ch8/ExceptionEx9.javaclass ExceptionEx9 {\tpublic static void main(String args[]) {\t\ttry {\t\t\tException e = new Exception(\"고의로 발생시켰음.\");\t\t\tthrow e;\t // 예외를 발생시킴\t\t// throw new Exception(\"고의로 발생시켰음.\"); \t\t} catch (Exception e)\t{\t\t\tSystem.out.println(\"에러 메시지 : \" + e.getMessage());\t\t e.printStackTrace();\t\t}\t\tSystem.out.println(\"프로그램이 정상 종료되었음.\");\t}}Exception 인스턴스를 생성할 때, 생성자에 String을 넣어 주면, 이 String이 Exception 인스턴스에 메세지로 저장된더. 이 메세지는 getMessage()로 얻을 수 있다.메서드에 예외 선언하기메서드에 예외를 선언하려면, 메서드의 선언부에 키워드 throws를 사용해서 메서드 내에서 발생할 수 있는 예외를 적어주기만 하면 된다.void method() throws Exception1, Exception2 .. ExceptionN {\t\t...}이렇게 예외를 선언하면, 이 예외뿐만 아니라 그 자손타입의 예외까지도 발생할 수 있다는 점에 주의해야 한다.메서드 선언부에 예외를 선언하면 메서드를 사용하려는 사람이 메서드의 선언부를 봤을 때, 이 메서드를 사용하기 위해서는 어떠한 예외들이 처리되어져야 하는지 쉽게 알 수 있다!다음 예제를 보면서 throws를 이해해보자.ch8/ExceptionEx12.javaclass ExceptionEx12 {\tpublic static void main(String[] args) throws Exception {\t\tmethod1();\t // 같은 클래스내의 static멤버이므로 객체생성없이 직접 호출가능. \t}\t// main메서드의 끝\tstatic void method1() throws Exception {\t\tmethod2();\t}\t// method1의 끝\tstatic void method2() throws Exception {\t\tthrow new Exception();\t}\t// method2의 끝}//실행결과Exception in thread \"main\" java.lang.Exception\tat ExceptionEx12.method2(ExceptionEx12.java:11)\tat ExceptionEx12.method1(ExceptionEx12.java:7)\tat ExceptionEx12.main(ExceptionEx12.java:3)위의 예제를 보았듯이 사실 예외를 메서드의 throws에 명시하는 것은 예외를 처리하는 것이 아니라, 자신(예외가 발생할 가능성이 있는 메서드)을 호출한 메서드에게 예외를 전달하여 예외처리를 떠맡기는 것이다.따라서 위의 결과로부터 호출스택을 보면 다음과 같이 정리할 수 있다. 예외가 발생했을 때, 모두 3개의 메서드가 호출스택에 있었다. 예외가 발생한 곳은 제일 윗줄에 있는 method2()라는 것과 main메서드가 method1()을, 그리고 method1()은 method2()를 호출했다는 것을 알 수 있다. 이처럼 예외가 발생한 메서드에게서 예외처리를 하지 않고 자신을 호출한 메서드에게 예외를 넘겨줄 수 있지만, 이것으로 예외가 처리된 것이 아니고 예외를 단순히 전달만 한다.finally 블럭finally블럭은 예외의 발생여부에 상관 없이 실행되어야할 코드를 포함시킬 목적으로 사용된다. try-catch문의 끝에 덧붙여 사용할 수 있으며, try-catch-finally의 순서로 구성된다.try {\t\t//예외가 발생할 가능성이 있는 문장들을 넣는다.} catch(Exception e) {\t\t//예외 처리를 위한 문장을 넣는다.} finally {\t\t//예외의 발생여부에 관계없이 항상 수행되어야하는 문장들을 넣는다.\t\t//finally블럭은 try-catch문의 맨 마지막에 위치해야 한다.}사용자 정의 예외 만들기기존에 정의된 예외 클래스 외에 필요에 따라 프로그래머가 새로운 예외 클래스를 정의하여 사용할 수 있다.class MyException extends Exception { \t\t\tMyException(Stringm msg) {\t\t\t\t\tsuper(msg);\t\t\t}}위와 같이 사용자가 원하는대로 예외 클래스를 정의하여 사용할 수 있다.📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[프로젝트] 캡스톤디자인 후기", "url": "/posts/Capston/", "categories": "project", "tags": "project", "date": "2023-07-10 00:00:00 +0800", "snippet": "이번 우리조의 캡스톤 디자인 주제는 대학생들을 위한 워크스페이스로, 시중에 나와있는 Notion을 모티브로 하여, 조금 더 대학생들의 편리성에 맞게 웹서비스를 만들기로 하였다. 우리팀은 총 4명으로 프론트 2명과 백앤드 2명으로 구성하고 프론트는 리액트, 백엔드는 스프링 프레임워크를 사용하였다.기술 스택우리 백엔드 팀은 프론트와 백엔드간의 RESTfu...", "content": "이번 우리조의 캡스톤 디자인 주제는 대학생들을 위한 워크스페이스로, 시중에 나와있는 Notion을 모티브로 하여, 조금 더 대학생들의 편리성에 맞게 웹서비스를 만들기로 하였다. 우리팀은 총 4명으로 프론트 2명과 백앤드 2명으로 구성하고 프론트는 리액트, 백엔드는 스프링 프레임워크를 사용하였다.기술 스택우리 백엔드 팀은 프론트와 백엔드간의 RESTful API를 이용해 통신하고 이에 따라 RESTful API 개발에 필요한 다양한 기능을 제공해주는 스프링 프레임워크를 사용하기 하였다. 또한 자바는 많은 기업과 개발자들이 오랜 기간동안 사용해왔기에 커뮤니티가 활발해져있어 수월한 정보 수집을 할 수 있어 스프링 프레임워크를 선택하였다.서버 배포에는 적은 비용으로 쉽고 편리하게 서버를 배포할 수 있는 aws를 사용하였다.개발이번 프로젝트에서의 개발 과정은 DB설계, API설계, 개발순으로 이루어졌다. 먼저 DB설계는 회원 테이블부터 시작해서, 작업공간 테이블 그리고 스케줄 테이블까지 필요한 테이블들을 생각하고 이 테이블들 간의 연관관계를 적용시켰다. 이를 토대로 프론트와 JSON기반으로 통신하기 위해 API설계를 했으며, 여기서는 어떻게 하면 프론트 쪽에서 데이터를 쉽게 가져다 쓸수 있을지에 대해 고민하면서 만들었다.이후 스프링 부트를 사용하여 개발을 시작하였고, 나는 스케줄쪽 기능을 맡아 DB설계를 토대로 JPA를 통한 엔티티 매핑을 통해 테이블을 생성하고, RESTful API 개발에서는 Spring Web의 MVC패턴을 이용해 개발하였다.서버 배포aws Ec2를 사용해 서버를 배포하였고, 나중에는 우리팀은 2개의 서버를 만들어서 운영하였다. 이 2개의 서버를 운영하기 위해 로드밸런싱(aws ELB)을 사용하였고, 로드밸런싱을 하기 위해서는 도메인을 적용해야 되서 도메인도 구입하여 route53을 이용해 도메인도 설정하였다.aws Ec2의 데이터베이스로는 amazon Rds를 이용해 mysql 데이터베이스를 사용하였다.서버 배포 자동화를 위해 git actions를 이용해 CI/CD 환경을 만들어 git에 push할때마다 배포하도록 만들었다.각 ec2인스턴스마다 nginx를 설치해 상황에 맞게 프로세스를 배포하고, 한 인스턴스마다 2개의 프로세스를 띄울 수 있었다. 또한 여기서 사용자 인증과정에서 토큰을 이용하는데, 이 과정에서 토큰을 가로채지 못하게 API서버에 SSL(암호화)도 적용시켰다.배운점스프링을 사용했기에 올 1월부터 종강전까지 계속 스프링 프레임워크에 대해 공부하였으며, 스프링 MVC, Spring JPA, Spring Data Jpa, queryDsl까지 개발에 필요한 기술들을 배웠다.이에 더해서 나는 이번 프로젝트에서 주로 서버 인프라 구축을 담당하였다. 서버를 배포하는 과정에서 ec2가 리눅스 운영체제를 사용하다보니 리눅스에 관한 지식도 많이 공부하게 되었다. 서버 생성부터 도메인적용, 암호화 적용, 로드밸런싱 등 배포 환경을 구축하면서 aws로 클라우드 서비스를 이용해 다양한 기능들을 써볼 수 있었고, 클라우드 지식들을 많이 배울 수 있었다.그리고 내 팀원은 주로 서비스 기능을 구현한 어플리케이션 개발을 담당했는데, 여기서 구글 간편로그인, JWT기반 사용자 인증, SpringSecurity, Websocket을 이용하여 기능들을 구현했고, 나도 팀원의 코드를 보면서 이에 대한 내용들을 공부할 수 있었다.아쉬운점이번 프로젝트를 진행하면서 아쉬웠던 점은 먼저 단위 테스트를 제대로 못해본것이다. 실제 개발에서 단위 테스트가 정말 중요하다고 알고있는데, 이번 프로젝트에서 백엔드 개발이 처음이다보니 테스팅 까지는 많이 신경을 쓰지 못했다. 또 JPA를 사용하면서 DB에 쿼리를 보낼때의 성능을 최적화하는 부분도 굉장히 중요했지만 여기서는 기능을 완성하는데만 급급해서 성능 최적화까지 신경을 못써 아쉬웠다. 마지막으로는 프론트 쪽에서 리액트와 통신하는 과정 중에 Websocket을 구현하는데 굉장히 애를 먹었다. 웹소켓에 대해 지식도 부족했고, 이 HTTP통신에 대한 개념이 정말 중요하다고 깨닫게 되었다. 이를 통해 네트워크 개념을 더 공부하고 더불어 데이터베이스, 운영체제와 같은 CS과목들도 더 공부해야겠다고 느꼈다." }, { "title": "[자바의 정석] 인터페이스", "url": "/posts/Java_Interface/", "categories": "java", "tags": "java", "date": "2023-07-07 00:00:00 +0800", "snippet": "인터페이스란?인터페이스는 일종의 추상클래스다. 인터페이스는 추상클래스처럼 추상메서드를 갖지만, 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다. 추상클래스를 부분적으로만 완성된 미완성 설계도면, 인터페이스는 구현된것은 아무것도 없고 밑그림만 그려져 있는 기본설계도라 할 수 있다...", "content": "인터페이스란?인터페이스는 일종의 추상클래스다. 인터페이스는 추상클래스처럼 추상메서드를 갖지만, 추상클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다. 추상클래스를 부분적으로만 완성된 미완성 설계도면, 인터페이스는 구현된것은 아무것도 없고 밑그림만 그려져 있는 기본설계도라 할 수 있다. 오직 추상메서드와 상수만을 멤버로 가질 수 있으며, 그외에는 허용되지 않는다.인터페이스의 작성키워드를 class 대신 interface를 사용한다.interface PlayingCard { \t\t\tpublic static final int SPADE = 4;\t\t\tfinal int DIAMOND = 3;\t\t\tstatic int HEART = 2;\t\t\tint CLOVER = 1;\t\t\tpublic abstract String getCardNumber();\t\t\tString getCardKind();} 모든 멤버변수는 public static final이어야 하며, 이를 생략할 수 있다. 모든 메서드는 public abstract여야 하며, 이를 생략할 수 있다.(단. static 메서드와 디폴트 메서드는 예외다.(JDK1.8부터))인터페이스의 상속인터페이스는 인터페이스로부터만 상속받을 수 있고, 클래스와 달리 다중상속을 지원한다.interface Movable { \t\tvoid move(int x, int y);}interface Attackable { \t\tvoid attack(Unit u);}interface Fightable extends Movable, Attackable{}인터페이스의 구현인터페이스도 추상클래스처럼 그 자체로는 인스턴스를 생성할 수 없으며 ,추상클래스가 상속을 통해 추상메서드를 완성하는 것처럼, 인터페이스도 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야 하는데, implements 키워드를 사용한다.class Fighter implements Fightable { \t\t\tvoid move(int x, int y);\t\t\tvoid attack(Unit u);}상속과 구현을 동시에도 할 수 있다.class Fighter extends Unit implements Fightable { \t\t\tvoid move(int x, int y);\t\t\tvoid attack(Unit u);}인터페이스를 이용한 다중상속인터페이스는 static 상수만 정의할 수 있으므로, 조상클래스의 멤버변수와 충돌하는 경우는 거의 없고 충돌한다 해도 클래스 이름을 붙여서 구분이 가능하다. 그리고 추상메서드는 구현내용이 없어 조상클래스의 메서드와 선언부가 일치하는 경우는 당연히 조상클래스 쪽의 메서드를 상속받으면 되므로 문제되지 않는다.But, 이렇게 하면 상속받는 멤버의 충돌은 피하지만, 다중상속의 장점을 잃어 연관관계를 사용하여 구현하는것이 더 바람직하다.인터페이스를 이용한 다형성인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있으며, 인터페이스의 타입으로의 형변환도 가능하다.interface Parseable {\t// 구문 분석작업을 수행한다.\tpublic abstract void parse(String fileName);}class ParserManager {\t// 리턴타입이 Parseable인터페이스이다.\tpublic static Parseable getParser(String type) {\t\tif(type.equals(\"XML\")) {\t\t\treturn new XMLParser();\t\t} else {\t\t\tParseable p = new HTMLParser();\t\t\treturn p;\t\t\t// return new HTMLParser();\t\t}\t}}class XMLParser implements Parseable {\tpublic void parse(String fileName) {\t\t/* 구문 분석작업을 수행하는 코드를 적는다. */\t\tSystem.out.println(fileName + \"- XML parsing completed.\");\t}}class HTMLParser implements Parseable {\tpublic void parse(String fileName) {\t\t/* 구문 분석작업을 수행하는 코드를 적는다. */\t\tSystem.out.println(fileName + \"-HTML parsing completed.\");\t}}class ParserTest {\tpublic static void main(String args[]) {\t\tParseable parser = ParserManager.getParser(\"XML\");\t\tparser.parse(\"document.xml\");\t\tparser = ParserManager.getParser(\"HTML\");\t\tparser.parse(\"document2.html\");\t}}리턴타입이 인터페이스라는 것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 것을 의미한다.디폴트 메서드와 static 메서드원래는 인터페이스에 추상메서드만 선언할 수 있는데, JDK1.8부터 디폴트 메서드와 static메서드도 추가할 수 있게 되었다.디폴트 메서드는 추상메서드의 기본적인 구현을 제공하는 메서드로, 추상메서드가 아니기 때문에 디폴트 메서드가 새로 추가되어도 해당 인터페이스를 구현한 클래스를 변경하지 않아도 된다.interface MyInterface {\t\t\tvoid method();\t\t\tdefault void newMethod();}위와 같이 디폴트 메서드를 추가하면 기존의 MyInterface를 구현한 클래스를 변경하지 않아도 된다.📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[자바의 정석] 추상클래스", "url": "/posts/AbstractClass/", "categories": "java", "tags": "java", "date": "2023-07-01 00:00:00 +0800", "snippet": "추상클래스란?클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도에 비유할 수 있다. 즉, 미완성 메서드(추상메서드)를 포함하고 있는 클래스라는 의미이다.abstract class 클래스이름{}추상메서드(abstract method)메서드의 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상메서드이다. 즉, 설계만 해놓고 실제 수행될...", "content": "추상클래스란?클래스를 설계도에 비유한다면, 추상클래스는 미완성 설계도에 비유할 수 있다. 즉, 미완성 메서드(추상메서드)를 포함하고 있는 클래스라는 의미이다.abstract class 클래스이름{}추상메서드(abstract method)메서드의 선언부만 작성하고 구현부는 작성하지 않은 채로 남겨 둔 것이 추상메서드이다. 즉, 설계만 해놓고 실제 수행될 내용은 작성하지 않았기 때문에 미완성 메서드인 것이다.왜 그러면 메서드를 이와 같이 미완성 상태로 남겨놓았을까? 그 이유는 메서드 내용이 상속받는 클래스에 따라 달라질 수 있기 때문에 조상 클래스에서는 선언부만 작성하고, 실제 내용은 상속받는 클래스에서 구현하도록 비워 두는 것이다.abstract class Player { \tabstract void play(int pos);\tabstract void stop();}class AudioPlayer extends Player {\tvoid play(int pos) { }\tvoid stop() {}}abstract class AbstractPlayer extends Player {\tvoid play(int pos){}}추상메서드로 선언하는 이유예를 들어 Player 추상클래스가 있다고 가정해보자.abstract class Player {\tboolean pause;\tint currentPos;\t\tPlayer() {\t\tpause = 0;\t\tcurrentPos = 0;\t}\tabstract void play(int pos);\tabstract void stop();\t\t\tvoid play() {\t\tplay(currentPos); //추상메서드를 사용할 수 있다.\t}}사실 이 클래스는 추상클래스가 아닌 일반 클래스로 작성하여 abstract 메서드에는 아무내용 없는 메서드로 작성하면 된다. 근데 왜 굳이 abstract를 붙여서 추상 클래스를 사용하는걸까?그 이유는 자손 클래스에서 추상메서드를 반드시 구현하도록 강요하기 위해서이다.만일 추상메서드로 정의되어 있지 않고 위와 같이 빈 몸통만 가지도록 정의되어 있다면, 상속받는 자손 클래스에서는 이 메서드들이 온전히 구현된 것으로 인식하고 오버라이딩을 통해 자신의 클래스에 맞도록 구현하지 않을 수도 있기 때문이다! 그래서 추상메서드로 정의해놓으면, 자손 클래스를 작성할 때 이들이 추상메서드이므로 내용을 구현해주어야 한다는 사실을 인식하고 자신의 클래스에 알맞게 구현할 것이다.📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[데이터베이스] 트랜잭션", "url": "/posts/Transaction/", "categories": "database", "tags": "database", "date": "2023-06-30 00:00:00 +0800", "snippet": "트랜잭션(Transaction)이란?하나의 논리적인 작업 단위를 구성하는 연산들의 집합을 트랜잭션(Transcation)이라 한다. 즉, 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위이다.예를 들어 A계좌에서 B계좌로 일정 금액을 이체한다고 했을 때의 순서를 보자 A는 A계좌의 잔액을 확인하고 현재 금액에서 인출할 금액을 뺀 나머지 금액...", "content": "트랜잭션(Transaction)이란?하나의 논리적인 작업 단위를 구성하는 연산들의 집합을 트랜잭션(Transcation)이라 한다. 즉, 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위이다.예를 들어 A계좌에서 B계좌로 일정 금액을 이체한다고 했을 때의 순서를 보자 A는 A계좌의 잔액을 확인하고 현재 금액에서 인출할 금액을 뺀 나머지 금액을 다시 저장한다. B계좌의 잔액을 읽어 들인 후 이체된 금액을 더하고 그 합을 다시 저장하면 계좌이체가 완려된다. 위의 과정들을 모두 합쳐져 ‘계좌이체’라는 하나의 작업 단위를 구성하게 된다.트랜잭션의 필요성문제가 발생하지 않도록 사전에 방지하기 위해 필요하다.계좌이체의 예를 들어보면 현금 인출기를 작동하는 도중에 기계 오류나 정전 등 예기치 않은 상황이 발생하여 기계가 멈추는 경우가 있을 것이다. 이때 만약 내 계좌에서 돈이 빠져나갔지만 상대방 계좌에는 이체가 되지 않는 문제가 발생할 수 도 있다. 이 문제가 발생하지 않기 위해 트랜잭션이 필요하다.즉, 트랜잭션은 내 계좌에서 금액이 빠져나가기 전 상태로 돌아가던지, 아니면 상대방 계좌로 이체가 성공적으로 끝나도록 보장해준다.ACID트랜잭션은 반드시 지켜야 할 중요한 조건이 있는데, DBMS는 이러한 조건들이 항상 만족되도록 보장해 주어야 한다. 이 조건들은 각 단어의 첫 문자를 따서 ACID라고 부른다. Atomicity(원자성) : 트랜잭션이 시작되면 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되던지, 아니면 실행되기 전 상태로 되돌아가야 한다. (All or nothing) Consistency(일관성) : 트랜잭션이 시작되기 전에 데이터베이스 내용이 일관된 상태라면 트랜잭션이 종료된 후에도 데이터베이스의 내용이 일관된 상태로 유지되어야 한다. Isolation(고립성) : 트랜잭션이 실행하는 과정에서 갱신한 데이터는 트랜잭션이 완료될때까지 다른 트랜잭션이 참조할 수 없다. Durability(지속성) : 트랜잭션이 성공적으로 완료되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장되어야 한다.Atomicity 트랜잭션은 성공하거나 실패하거나 둘중 하나여야 한다.예를 들어서 A,B 모두 400원이 있고, 100원을 이체한다고 가정했을 때 트랜잭션이 성공할 경우 A계좌 잔액 : 300원, B계좌 잔액 : 500원 트랜잭션이 실패할 경우 A계좌 잔액 : 400원, B계좌 잔액 : 400원 → 원래의 상태로 되돌려 놓아야 한다.📖 이와 같이 트랜잭션이 실행 도중 중단된 상태로 남아 있지 않아야 한다는 조건을 의미!Consistency 트랜잭션 완료 후에도 데이터베이스가 일관된 상태로 유지해야 한다.예를 들어서 계좌이체 과정에서 일관성을 살펴보면 계좌이체 전후 두 계좌의 잔액의 합이 일정해야 한다.이 일관된 상태를 판단은 DBM가 인지할 수 없고 개발자가 판단해야 한다. 따라서 일관성 유지되도록 트랜잭션을 정의하는 것은 개발자의 책임이다.위와 같이 트랜잭션을 인출과 입금 두개로 나눠서 트랜잭션을 구성할 경우 계좌이체를 위해서는 인출 트랜잭션과 입금 트랜잭션이 모두 완료되어야 한다. 그러나 인출 트랜잭션만 완료된 상태에서는 A계좌와 B계좌의 잔액의 합이 같지 않다. 따라서 위의 트랜잭션은 일관성을 유지 못한 트랜잭션이다.!Isolation 트랜잭션이 실행하는 도중에 변경한 데이터는 이 트랜잭션이 완료될 때까지 다른 트랜잭션이 참조하지 못하게 하는 특성이다.위와 같이 A계좌에서 B계좌로 d원을 이체하는 트랜잭션 (a)와 A와 B의 잔액 합을 계산하는 트랜잭션이 동시에 실행했다고 가정해보자. 위의 번호대로 1,2,3을 실행되면 두 계좌의 합을 계산하는 (b)의 트랜잭션은 잘못된 결과가 나올거다. 그 이유는 (b)에서 읽은 A와 B의 잔액이 일시적으로 일관된 상태가 아니기 때문이다.이를 해결하기 위해서은 동시에 실행되는 각 트랜잭션을 순차적으로 실행되도록 하는 것이다. 그러나, 다중 프로그래밍 환경에서 트랜잭션을 순차적으로 실행하면 성능면에서 많은 문제가 있어서 이 문제를 해결하기 위해서는 트랜잭션을 동시에 실행하면서 상호간에 간섭이 일어나지 않도록 하는 기법이 필요하다. 따라서 고립성이 만족되어야 하며, 고립성이 만족되는지 확인하는 방법은 동시에 실행하는 트랜잭션들 실행 결과가 순차적으로 실행된 결과와 동일하다면 고립성이 만족 되는 것이다.Durability 트랜잭션 완로 후에도 그 결과가 영구적으로 보존되어야 한다.트랜잭션이 완료되면 주기억장치가 아닌 디스크와 같은 보조기억장치에 저장하거나 시스템 장애가 회복되고 난 후에 어떠한 형태로든지 그 데이터를 복구할 수 있어야 한다.트랜잭션의 상태 트랜잭션이 시작되면 동작상태로 집입 이후 모든 연산이 성공적으로 실행되면 부분완료 집입한다. 아직 부분완료인 이유는 이 결과가 곧바로 디스크에 영구적으로 저장되는 것이 아니기 때문이다. 부분완료 상태에서 트랜잭션의 결과가 영구적으로 보존될 수 있다고 보장되면 최종적으로 완료 상태에 도달한다. (완료되면 지속성에 의해 취소는 불가) 만약 동작 상태나 부분완료 상태에서 트랜잭션이 더 이상 정상적인 실행을 하지 못할 경우 실패 상태에 도달한다. 만약 실패하면 원자성에 의해 실행되기 이전의 상태로 되돌려 놓아야 한다. 이러한 과정을 복귀(Rollback)라 하며 복귀가 이루어 지면 트랜잭션은 최종적으로 중단 상태에 도달한다. 중단 상태에 도달한 트랜잭션은 상황에 따라 다시 시작될 수도 있고 더 이상 실행되지 않고 완전히 종료 될 수 있는데, 트랜잭션이 완료되거나 중단되었을 때 종료 되었다고 한다.![트랜잭션의 상태 전이도] 트랜잭션의 상태 전이도📖 references 데이터베이스의 이해 [이한미디어]" }, { "title": "[알고리즘] 복잡도", "url": "/posts/TimeComplexity/", "categories": "algorithm", "tags": "algorithm, python", "date": "2023-06-26 00:00:00 +0800", "snippet": "복잡도복잡도는 알고리즘의 성능을 나타내는 척도다. 복잡도는 시간복잡도와 공간복잡도로 나눌 수 있다.시간복잡도시간 복잡도란 알고리즘을 위해 필요한 연산의 횟수를 말한다. 시간 복잡도라고 해서 프로그램이 실행되는 시간을 나타내는 것 같지만, 주요로직의 반복횟수에 중점으로 측정된다.예를 들어 아래의 코드가 실행되는 시간을 측정해보자.sum =0start =...", "content": "복잡도복잡도는 알고리즘의 성능을 나타내는 척도다. 복잡도는 시간복잡도와 공간복잡도로 나눌 수 있다.시간복잡도시간 복잡도란 알고리즘을 위해 필요한 연산의 횟수를 말한다. 시간 복잡도라고 해서 프로그램이 실행되는 시간을 나타내는 것 같지만, 주요로직의 반복횟수에 중점으로 측정된다.예를 들어 아래의 코드가 실행되는 시간을 측정해보자.sum =0start = time.time()for i in range(1,10000):\t\tsum+=1end = time.time()print(f\"{end - start:.5f} sec\")# 첫번째 실행 결과 : 0.00133 sec# 두번째 실행 결과 : 0.00154 sec# 세번쨰 실행 결과 : 0.00201 sec위의 결과를 보면 실행할 때마다 측정되는 값이 달라진다. 이는 컴퓨터 사양이나 실행될때 매번 달라지며 이것으로 시간복잡도를 측정하기 애매하다. 그래서 시간 복잡도는 반복횟수에 중점을 맞춰서 측정하는 것이다.시간 복잡도 표기시간 복잡도를 표현할 때는 빅오 표기법을 사용한다. 이 빅오 표기법은 함수의 상한만을 나타낸다예를 들어 N개의 데이터가 있을 때, 모든 데이터의 값을 더한 결과를 출력하는 프로그램을 생각해보자array = [3, 5, 1, 2, 4]sum = 0for x in array: sum +=xprint(sum)# 결과 : 15이 부분에서 반복 횟수는 array에 있는 요소 개수와 비례하여, 만약 배열의 요소 개수를 n이라고 하면 n이 커짐에 따라 연산을 수행하므로 시간 복잡도는 O(N)이라고 표기한다.array = [3, 5, 1, 2, 4]for i in array: for j in array: temp = i*j print(temp)이 소스코드는 데이터의 개수가 N개일 때 O(N제곱)의 시간 복잡도를 가진다. 이는 반복문이 2중 반복문이라서 반복횟수가 N * N 만큼 연산이 필요한 것이다. 일반적으로 코딩테스에서는 최악의 경우에 대한 연산 횟수가 가장 중요하다공간 복잡도공간 복잡도는 입력 크기에 대해 어떠한 알고리즘이 실행되는데 필요한 메모리 공간의 양이다. 공간 복잡도를 표기할 때도 빅오 표기법을 이용한다.다음은 C언어에서의 배열 선언 코드이다.int a[N];여기서 int 자료형은 4byte이며, N개의 요소를 선언했으므로 공간은 4N byte가 필요할 것이다. 이것을 빅오 표기법으로 나타내면 O(4N) = O(N)여서 공간 복잡도는 O(N)이다.파이썬에서는 int형에 자료가 없어, getsizeof()함수를 사용하여 알 수 있다.import sysn = int(input())print(sys.getsizeof(n)) # 객체의 크기 출력이 함수는 파이썬 객체의 메모리 크기를 바이트 단위로 반환한다.📖 references 이것이 코딩테스다 with 파이썬 [한빛미디어]" }, { "title": "[자바의 정석] 다형성", "url": "/posts/Java_Polymorphism/", "categories": "java", "tags": "java", "date": "2023-06-05 00:00:00 +0800", "snippet": "다형성이란?객체지향개념에서 다형성이란 여러가지 형태를 가질 수 있는 능력을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현한 것이다.예제를 통해 알아보자.class Tv { \t\tboolean power;\t\tint channel;\t\tvoid power() { power = !power...", "content": "다형성이란?객체지향개념에서 다형성이란 여러가지 형태를 가질 수 있는 능력을 의미하며, 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현한 것이다.예제를 통해 알아보자.class Tv { \t\tboolean power;\t\tint channel;\t\tvoid power() { power = !power; }\t\tvoid channelUp() { ++channel; } \t\tvoid channelDown() { --chanell; } }class CaptionTv extends Tv {\t\t\tString text;\t\t\tvoid caption(){}} Tv클래스와 CaptionTv클래스가 위와 같이 정의되어 있을 때, 두 클래스간의 관계를 그림으로 나타내면 아래와 같다.여기서 인스턴스를 생성하려면 다음과 같은 코드를 작성해야 한다.Tv t = new Tv();CaptionTv c = new CaptionTv();위의 예처럼 인스턴스의 타입과 참조변수의 타입이 일치하는 것이 보통이지만, Tv와 CaptionTv클래스가 서로 상속관계에 있을 경우, 다음과 같이 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능하다!Tv t = new CaptionTv(); //조상 타입의 참조변수로 자손 인스턴스를 참조그러면 이렇게 쓰는게 가능한데, 인스턴스랑 참조변수의 타입이 같을 때랑 조상 타입의 참조변수로 참조하는 것은 어떤 차이가 있는지 알아보자.CaptionTv c = new CaptionTv();Tv t = new CaptionTv();위의 코드를 그림으로 나타내면 다음과 같다.Tv타입의 참조변수로는 CaptionTv 인스턴스 중에서 Tv클래스의 멤버들만 사용할 수 있다. 따라서 생성된 CaptionTv 인스턴스의 멤버 중에서 Tv클래스에 정의 되지 않은 멤버, text와 caption()은 참조변수 t로 사용이 불가능하다. 둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 불가능하다!!CaptionTv c = new Tv();자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 불가능한 이유는 실제 인스턴스 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기 때문이다. 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.참조변수의 형변환기본형 변수와 같이 참조변수도 형변환이 가능하다. 자손타입의 참조변수를 조상타입의 참조변수로, 조상타입의 참조변수를 자손타입의 참조변수의 형변환만 가능하다.조상타입의 참조변수를 자손타입의 참조변수로 변환하는 것을 다운캐스팅(down-casting)이라고 하며, 자손타입의 참조변수를 조상타입의 참조변수로 변환하는 것을 업캐스팅이(up-casting)라고한다.예를 들어 Car, FireEngine, Amubulane클래스가 있다고 해보자.class Car {\t\t\tString color;\t\t\tint door;\t\t\tvoid drive() {}\t\t\tvoid stop() {}}class FireEngine extends Car {\t\t\tvoid water() {}}class Ambulance extends Car{\t\t\tvoid siren(){}}여기서 Car타입 참조변수와 FireEngine타입 참조변수 간의 형변환을 하면Car car = null;FireEngine fe = new FireEngine();FireEngine fe2 = null;car = fe; //업캐스팅fe2 = (FireEngine)car; //다운 캐스팅여기서 자손타입의 참조변수를 조상타입의 참조변수에 할당할 경우 형변환을 생략할 수 있어서car = fe;라고 해도된다. 반대로 조상타입의 참조변수를 자손타입의 참조변수에 저장할 경우 형변환을 생략할 수 없어 fe = (FireEngine) car;와 같이 명시적으로 형변환을 해주어야 한다.그렇다면 조상타입의 참조변수를 자손타입의 참조변수로 변환하는 것은 명시적으로 캐스팅해주어야하고, 자손타입의 참조변수를 조상타입의 참조변수로 변환하는 것은 생략가능할까?예를 들어 Car타입의 참조변수 c를 Car타입의 조상인 Object타입의 참조변수로 형변환 하는 것은 참조변수가 다룰수 있는 멤버의 개수가 실제 인스턴스가 갖고 있는 멤버의 개수보다 적을 것이 분명해 문제가 되지 않는다!반대로 Car타입의 참조변수 c를 자손인 FireEngine타입으로 변환하는 것은 참조변수가 다룰 수 있는 멤버의 개수를 늘리는 것으로, 실제 인스턴스의 멤버 개수보다 참조변수가 사용할 수 있는 멤버의 개수가 더 많아지므로 문제가 발생할 가능성이 있다! 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위를 조절하는 것뿐이다.instanceof 연산자참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용한다.예를 들어 살펴보자ch7/InstanceofTest.javaclass InstanceofTest {\tpublic static void main(String args[]) {\t\tFireEngine fe = new FireEngine();\t\tif(fe instanceof FireEngine) {\t\t\tSystem.out.println(\"This is a FireEngine instance.\");\t\t} \t\tif(fe instanceof Car) {\t\t\tSystem.out.println(\"This is a Car instance.\");\t\t} \t\tif(fe instanceof Object) {\t\t\tSystem.out.println(\"This is an Object instance.\");\t\t} \t\tSystem.out.println(fe.getClass().getName()); // 클래스의 이름 출력\t}} // classclass Car {}class FireEngine extends Car {}//실행결과This is a FireEngine instance.This is a Car instance.This is an Object instance.FireEngine여기서 innstanceof 를 사용해 fe의 타입을 알아보니 모두 true가 되어 if문이 실행되었다.그 이유는 FireEngine클래스는 Object클래스와 Car클래스의 자손 클래스이므로 조상이 멤버들을 상속받았기 때문에, FireEngine인스턴스는 Object인스턴스와 Car인스턴스를 포함하고 있는 셈이다. 어떤 타입에 대한 instanceof 연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.참조변수와 인스턴스의 연결메서드의 경우 조상 클래스의 메서드를 자손의 클래스에서 오버라이딩한 경우에도 참조변수의 타입에 관계없이 항상 실제 인스턴스의 메서드가 호출되지만, 멤버변수의 경우 참조변수의 타입에 따라 달라진다.이말을 이해하기 위해 예제를 들어보자.ch7/BindingTest.javaclass BindingTest{\tpublic static void main(String[] args) {\t\tParent p = new Child();\t\tChild c = new Child();\t\tSystem.out.println(\"p.x = \" + p.x);\t\tp.method();\t\tSystem.out.println(\"c.x = \" + c.x);\t\tc.method();\t}}class Parent {\tint x = 100;\tvoid method() {\t\tSystem.out.println(\"Parent Method\");\t}}class Child extends Parent {\tint x = 200;\tvoid method() {\t\tSystem.out.println(\"Child Method\");\t}}//실행결과p.x = 100Child Methodc.x = 200Child Method위의 코드로 실행해보면 우선 메서드들을 조상타입의 참조변수와 자식타입의 참조변수로 접근해서 메서드를 호출하면 똑같은 결과가 나오지만, 멤버변수들은 참조변수에 따라 값이 다르게 나온다. 메서드의 경우 조상 클래스의 메서드를 자손의 클래스에서 오버라이딩한 경우에도 참조변수의 타입에 관계없이 항상 실제 인스턴스의 메서드가 호출되지만, 멤버변수의 경우 참조변수의 타입에 따라 달라진다.매개변수의 다형성참조변수의 다형적인 특징은 메서드의 매개변수에 유용하게 적용할 수 있다.언제 유용한지 알기 위해 Product, Tv, Computer, Audio, Buyer 클래스가 정의되어 있다고 예를 들어보자.class Product {\t\t\tint price;\t\t\tint bonusPoint;}class Tv extends Product{}class Computer extends Product{}class Audio extends Product{}class Buyer {\t\t\tint money = 100;\t\t\tint bonusPoint = 0;}Product 클래스는 Tv, Audio, Computer 클래스의 조상이며, Buyer클래스는 제품을 구입하는 사람을 클래스로 표현한 것이다.여기서 Buyer 클래스에 물건을 구입하는 기능의 메서드를 추가할거다. 구입할 대상이 필요하므로 매개변수로 구입할 제품을 넘겨받도록 할 것이다.void buy(Tv t) { \t\t\tmoney = money - t.price;\t\t\tbonusPoint = bonusPoint + t.bonusPoint;}이런식으로 메서드를 작성하였지만, 지금 현재 매개변수로 Tv 타입의 인스턴스만 받을 수 있도록 되어있는데 만약 여기서 상품들이 더 들어난다면 그 개수만큼 메서드를 만들어야할 것이다. 이때 매개변수에 다형성을 적용하면 다음과 같이 하나의 메서드로 간단히 처리할 수 있다.void buy(Product p) { \t\t\tmoney = money - p.price;\t\t\tbonusPoint = bonusPoint + p.bonusPoint;}이렇게 하면 Product타입의 참조변수로 Product 클래스의 자손 타입의 참조변수들을 매개변수로 받아들일 수 있어 훨씬 간단하게 코드를 구성할 수 있게 됐다.📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[자바의 정석] 오버라이딩", "url": "/posts/Java_Overriding/", "categories": "java", "tags": "java", "date": "2023-05-03 00:00:00 +0800", "snippet": "오버라이딩이란?조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩(overriding)이라 한다.오버라이딩의 조건자손 클래스에서 오버라이딩하는 메서드와 조상 클래스의 메서드의 이름이 같아야 한다. 매개변수가 같아야 한다. 반환타입이 같아야 한다. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다. 조상 클래스...", "content": "오버라이딩이란?조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩(overriding)이라 한다.오버라이딩의 조건자손 클래스에서 오버라이딩하는 메서드와 조상 클래스의 메서드의 이름이 같아야 한다. 매개변수가 같아야 한다. 반환타입이 같아야 한다. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다. 조상 클래스의 메서브보다 많은 수의 예외를 선언할 수 없다. 인스턴스 메서드를 static 메서드로 또는 그 반대로 변경할 수 없다.오버라이딩의 예로 2차원 좌표계에 점을 표현하기 위한 Point 클래스와 Point클래스를 상속받은 Point3D클래스가 있다고 하자.class Point {\t\t\tint x;\t\t\tint y;\t\t\tString getLocation() {\t\t\t\t\treturn \"x : \" + x + \", y : \" + y;\t\t\t}}class Point3D extends Point {\t\t\tint z;\t\t\tString getLocation() {\t\t\t\t\treturn \"x : \" + x + \", y : \" + y + \", z: \" + z;\t\t\t}}이 두 클래스는 서로 상속관계를 가지고있어 Point3D 클래스는 Point클래스의 getLocation()을 상속받아 사용할 수 있지만 3차원 좌표계의 한 점을 표현하기 위한 클래스 이므로 조상 클래스의 getLocation()의 로직에 맞지 않는다.따라서 Point3D클래스에서 getLocation()을 자신에 맞게 z축에 좌표값도 포함하여 반환하도록 오버라이딩 한것이다. 이렇게 하여 새로운 메서드를 작성하는 것보다는 오버라이딩하여 코드를 구성할 수 있다.supersuper는 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.조상 클래스로부터 상속받은 멤버도 자손 클래스 자신의 멤버이므로 super 대신 this를 사용할 수 있다. 그래도 조상 클래스의 멤버와 자손 클래스의 멤버가 중복 정의되어 서로 구별해야하는 경우에만 super를 사용하는 것이 좋다.ch7/SuperTest.javaclass SuperTest {\tpublic static void main(String args[]) {\t\tChild c = new Child();\t\tc.method();\t}}class Parent {\tint x=20;}class Child extends Parent {\tvoid method() {\t\tSystem.out.println(\"x=\" + x);\t\tSystem.out.println(\"this.x=\" + this.x);\t\tSystem.out.println(\"super.x=\"+ super.x);\t}}//실행결과x = 20this.x = 20super.x = 10이처럼 조상 클래스에 선언된 멤버변수와 같은 이름의 멤버변수를 자손 클래스에서 중복해서 정의하는것이 가능하며 참조변수 super를 이용해서 구별할 수 있다.super() - 조상 클래스의 생성자this()와 마찬가지로 super() 역시 생성자이다. this()는 같은 클래스의 다른 생성자를 호출하는 데 사용되지만, super()는 조상 클래스의 생성자를 호출하는데 사용된다.생성자의 첫 줄에서 조상 클래스의 생성자를 호출해야 하는 이유는?자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야 하기 때문이다.class PointTest {\tpublic static void main(String argsp[]) {\t\tPoint3D p3 = new Point3D();\t\tSystem.out.println(\"p3.x=\" + p3.x);\t\tSystem.out.println(\"p3.y=\" + p3.y);\t\tSystem.out.println(\"p3.z=\" + p3.z);\t}}class Point {\tint x=10;\t\tint y=20;\tPoint(int x, int y) {\t\t//컴파일러는 super()를 한다. 여기서 super()는 Object의 생성자를 말한다. \t\tthis.x = x;\t\tthis.y = y;\t}}class Point3D extends Point {\tint z=30;\tPoint3D() {\t\tthis(100, 200, 300);\t// Point3D(int x, int y, int z)¸Ś ČŁĂâÇŃ´Ů.\t}\tPoint3D(int x, int y, int z) {\t\tsuper(x, y);\t\t\t// Point(int x, int y)¸Ś ČŁĂâÇŃ´Ů.\t\tthis.z = z;\t}}컴파일러는 다음과 같이 자동적으로 super()를 Point클래스에 넣어준다.위의 예제에서 Point3D p3 = new Point3D();를 실행하면 다음과같은 순서로 생성자가 호출된다.Point3D() → Point3D(int x, int y, int z) → Point(int x, int y) → Object()📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[자바의 정석] 상속", "url": "/posts/Java_Inheritance/", "categories": "java", "tags": "java", "date": "2023-04-04 00:00:00 +0800", "snippet": "상속이란?상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.class 자손클래스 extends 조상클래스{} 상속받을 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 extends 를 함께 써주면 된다. 상속해주는 클래스를 “조상 클래스”, 상속 받는 클래스를 “자손 클래스”라고 한다. 자손 클래스는 조상 클래스의 ...", "content": "상속이란?상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.class 자손클래스 extends 조상클래스{} 상속받을 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 extends 를 함께 써주면 된다. 상속해주는 클래스를 “조상 클래스”, 상속 받는 클래스를 “자손 클래스”라고 한다. 자손 클래스는 조상 클래스의 모든 멤버를 상속 받는다.Point와 Point3D가 있다고 해보자class Point{\t\t\tint x;\t\t\tint y}class Point3D{\t\t\tint x;\t\t\tint y;\t\t\tint z;}Point3D 클래스의 멤벼변수는 3개를 가지고 있고 Point는 멤버 변수 2개를 가지고 있는 상황에서, int x, int y의 코드가 중복되는 것을 볼 수 있다. 이때 상속관계를 이용하여 코드를 작성하면 훨씬 간결하게 구성할 수 있다.이처럼 클래스간의 상속관계를 맺어 주면 자손 클래스들의 공통적인 부분은 조상 클래스에서 관리되고 자손 클래스는 자신에 정의된 멤버들만 관리하면 되므로 각 클래스의 코드가 적어져서 관리가 쉬어진다.상속관계를 이용한 Point3Dclass Point3D extends Point{\t\t\tint z;}여기서 Point와 Point3D의 관계를 그림으로 나타내면 다음과 같다.자손 클래스는 조상 클래스의 모든 멤버를 상속 받으므로 항상 조상 클래스보다 같거나 많은 멤버를 갖는다. 즉, 상속에 상속을 거듭할수록 상속받는 클래스의 멤버 개수는 점점 늘어나게 된다.그래서 상속을 받는다는 것은 조상 클래스를 확장(extend)한다는 의미로 해석할 수 있다. 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다. 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다. ch7/CaptionTvTest.javaclass Tv {\tboolean power; \t// 전원상태(on/off)\tint channel;\t// 채널\tvoid power() { power = !power; }\tvoid channelUp() { \t ++channel; }\tvoid channelDown() {\t --channel;\t }}class CaptionTv extends Tv {\tboolean caption;\t\t// 캡션상태(on/off)\tvoid displayCaption(String text) {\t\tif (caption) {\t// 캡션 상태가 on(true)일 때만 text를 보여 준다.\t\t\tSystem.out.println(text);\t\t}\t}}class CaptionTvTest {\tpublic static void main(String args[]) {\t\tCaptionTv ctv = new CaptionTv();\t\tctv.channel = 10;\t\t\t\t// 조상 클래스로부터 상속받은 멤버\t\tctv.channelUp();\t\t\t\t// 조상 클래스로부터 상속받은 멤버\t\tSystem.out.println(ctv.channel);\t\tctv.displayCaption(\"Hello, World\");\t\t\tctv.caption = true;\t\t\t\t // 캡션기능을 켠다.\t\tctv.displayCaption(\"Hello, World\");\t// 캡션을 화면에 보여 준다.\t}}자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버도 함께 생성되기 때문에 따로 조상 클래스의 인스턴스를 생성하지 않고도 조상 클래스의 멤버들을 사용할 수 있다. 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성한다.클래스간의 관계 설정하기(포함 OR 상속)클래스를 작성하는데 “~은 이다” 와 “~은 ~을 가지고 있다”의 문자을 이용하여 클래스간의 관계가 포함관계인지 상속관계인지 정의하면 명확해진다.ch7/DrawShape.javaclass DrawShape {\tpublic static void main(String[] args) {\t\tPoint[] p = { new Point(100, 100), new Point(140, 50), new Point(200, 100)\t\t\t\t\t};\t\tTriangle t = new Triangle(p);\t\tCircle c = new Circle(new Point(150, 150), 50);\t\tt.draw(); // 삼각형을 그린다.\t\tc.draw(); // 원을 그린다.\t}}class Shape {\tString color = \"black\";\tvoid draw() {\t\tSystem.out.printf(\"[color=%s]%n\", color);\t}}class Point {\tint x;\tint y;\tPoint(int x, int y) {\t\tthis.x = x;\t\tthis.y = y;\t}\tPoint() {\t\tthis(0,0);\t}\tString getXY() { \t\treturn \"(\"+x+\",\"+y+\")\"; // x와 y의 값을 문자열로 반환\t}}class Circle extends Shape {\tPoint center;\t// 원의 원점좌표\tint r;\t\t\t// 반지름\tCircle() {\t\t\t\tthis(new Point(0, 0), 100); // Circle(Point center, int r)를 호출\t}\tCircle(Point center, int r) {\t\tthis.center = center;\t\tthis.r = r;\t}\tvoid draw() { // 원을 그리는 대신에 원의 정보를 출력하도록 했다.\t\tSystem.out.printf(\"[center=(%d, %d), r=%d, color=%s]%n\", center.x, center.y, r, color);\t}}class Triangle extends Shape {\tPoint[] p = new Point[3];\tTriangle(Point[] p) {\t\tthis.p = p;\t}\tvoid draw() { \t\tSystem.out.printf(\"[p1=%s, p2=%s, p3=%s, color=%s]%n\", p[0].getXY(), p[1].getXY(), p[2].getXY(), color);\t}}위의 예제에서 Circle클래스와 Point클래스를 보면 “원은 점이다.” 와 “원은 점을 가지고 있다.”을 보면 첫번째 문장보다 두번째 문장이 더 옳다는 것을 알 수있다. 이럴 때는 Circle클래스와 Point클래스의 관계는 포함관계를 맺어주어야 한다. 또한 Shape클래스와 Circle클래스의 관계를 설정하는거를 보면 “원은 도형이다”가 맞기 때문에 Shape와 Circle클래스의 관계는 상속관계로 맺어주어야 한다. 상속관계 : “~은 이다.”(is-a)포홤관계 : “~은 ~을 가지고 있다”(has-a)단일상속(Single inheritance)자바에서는 단일 상속만을 허용한다.다중상속을 허용하면 여러 클래스로부터 상속을 받을 수 있기 때문에 복합적인 기능을 가진 클래스를 쉽게 작성할 수 있다는 장점이 있지만, 클래스간의 관계가 매우 복잡해진다는 것과 서로 다른 클래스로부터 상속받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없다는 단점을 가지고 있다.만일 아래 코드처럼 TVCR클래스가 TV클래스와 VCR클래스를 모두 조상으로 하여 두 클래스의 멤버들을 상속받는다고 가정하자.class TVCR extends TV, VCR{}TV클래스와 VCR클래스에 power()라는 메서드가 있을 때, 자손인 TVCR클래스는 어느 조상 클래스의 power()를 받아야 되나?만약 인스턴스 메서드의 경우 선언부가 같은 두 메서드를 구별할 수 있는 방법은 없다. 이를 해결하려면 조상 클래스의 메서드의 이름이나 매개변수를 바꾸는 방법 밖에 없다. 그러나, 이렇게 하면 조상 클래스의 power()메서드를 사용하는 모든 클래스들도 변경해야 하므로 그리 간단한 문제가 아니다.이 때문에 자바는 다중상속을 지원하지 않는다!!Object 클래스 - 모든 클래스의 조상Object클래스는 모든 클래스 상속계층도의 최상위에 있는 조상 클래스이다. 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object클래스로부터 상속받게 함으로써 이것을 가능하게 한다.만약 다음과 같은 Tv클래스가 있다고 가정하자.class Tv{}위의 코드를 컴파일 하면 컴파일러는 위의 코드를 다음과 같이 자동적으로 extends Object를 추가하여 Tv클래스가 Object클래스로부터 상속받도록 한다.class Tv extends Object{}이 때문에 toString()이나 equals()와 같은 메서드를 따로 정의하지 않고도 사용할 수 있었던 이유는 이 메서드들이 Object클래스에 정의된 것들이기 때문이다.📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[자바의 정석] 변수의 초기화", "url": "/posts/Java_Variable_Init/", "categories": "java", "tags": "java", "date": "2023-04-02 00:00:00 +0800", "snippet": "변수의 초기화멤버변수 초기화를 하지 않고도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어지므로 초기화 하지 않고 사용해도 되지만, 지역변수는 사용하기 전에 반드시 초기화해야 한다.멤버변수의 초기화 방법에는 다음과 같이 3가지가 있다. 명시적 초기화(explict initialization) 생성자(Constructor) 초기화 블럭(...", "content": "변수의 초기화멤버변수 초기화를 하지 않고도 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어지므로 초기화 하지 않고 사용해도 되지만, 지역변수는 사용하기 전에 반드시 초기화해야 한다.멤버변수의 초기화 방법에는 다음과 같이 3가지가 있다. 명시적 초기화(explict initialization) 생성자(Constructor) 초기화 블럭(initialization block)명시적 초기화변수의 선언과 동시에 초기화 하는 방법class Car{\t\tint door = 4; //기본형 변수의 초기화 \t\tEngine e = new Engine(); //참조형 변수의 초기화}초기화 블럭초기화 블럭에는 클래스와 인스턴스 초기화 블럭 두 가지 종류가 있다. 클래스 초기화 블럭은 클래스변수의 초기화에 사용되고, 인스턴스 초기화 블럭은 인스턴스변수의 초기화에 사용된다.class BlockTest {\tstatic { // 클래스 초기화 블럭\t\tSystem.out.println(\"static { }\");\t}\t{ //인스턴스 초기화 블럭\t\tSystem.out.println(\"{ }\");\t}\tpublic BlockTest() { \t\tSystem.out.println(\"ťýźşŔÚ\");\t}\tpublic static void main(String args[]) {\t\tSystem.out.println(\"BlockTest bt = new BlockTest(); \");\t\tBlockTest bt = new BlockTest();\t\tSystem.out.println(\"BlockTest bt2 = new BlockTest(); \");\t\tBlockTest bt2 = new BlockTest();\t}}클래스 초기화 블럭은 앞에 static을 붙이고, 인스턴스 블럭은 {}만 만들어주면 된다.클래스 초기화 블럭은 처음 메모리에 로딩될 때 한번만 수행되지만, 인스턴스 초기화 블럭은 인스턴스가 생성될 때 마다 수행된다.멤버변수의 초기화 시기와 순서 클래스변수의 초기화 순서 : 기본값 → 명시적 초기화 → 클래스 초기화 블럭 인스턴스변수의 초기화 순서 : 기본값 → 명시적 초기화 → 인스턴스 초기화 블럭 → 생성자class InitTest {\t\tstatic int cv=1;\t\tint iv=1;\t\tstatic { cv=2;}\t\t{ iv= 2;}\t\tInitTest() {\t\t\t\tiv=3;\t\t}} cv가 메모리에 생성되고, cv에는 int형의 기본값인 0이 cv에 저장된다. 그 다음에는 명시적 초기화(int cv=1)에 의해 cv에 1이 저장된다. 마지막으로 클래스 초기화 블럭(cv=2)이 수행되어 cv에는 2가 저장된다. InitTest클래스의 인스턴스가 생성되면서 iv가 메모리에 존재하게 된다.iv 역시 int형 변수이므로 기본값 0이 저장된다. 명시적 초기화에 의해서 iv에 1이 저장되고 인스턴스 초기화 블럭이 수행되어 iv에 2가 저장된다. 마지막으로 생성자가 수행되어 iv에는 3이 저장된다.📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[자바의 정석] 생성자", "url": "/posts/Java_Constructor/", "categories": "java", "tags": "java", "date": "2023-02-23 00:00:00 +0800", "snippet": "생성자란?생성자는 인스턴스가 생성될 때 호출되는 ‘인스턴스 초기화 메서드’이다. 인스턴스 생성 시에 실행되어야 할 작업을 위해서도 사영된다.생성자의 조건은 다음과 같다. 생성자의 이름은 클래스의 이름과 같아야 한다. 생성자는 리턴 값이 없다.Card c = new Card();1. 연산자에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성...", "content": "생성자란?생성자는 인스턴스가 생성될 때 호출되는 ‘인스턴스 초기화 메서드’이다. 인스턴스 생성 시에 실행되어야 할 작업을 위해서도 사영된다.생성자의 조건은 다음과 같다. 생성자의 이름은 클래스의 이름과 같아야 한다. 생성자는 리턴 값이 없다.Card c = new Card();1. 연산자에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다.2. 생성자 Card()가 호출되어 수행된다.3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다.인스턴스를 생성할 때는 반드시 클래스 내에 정의된 생성자 중의 하나를 선택하여 지정해주어야 한다.기본 생성자컴파일 할 때, 소스파일(.java)의 클래스에 생성자가 하나도 정의되지 않은 경우 컴파일러는 자동적으로 아래와 같은 내용의 기본 생성자를 추가하여 컴파일 한다.클래스 이름(){}Card(){}ch6/ConstructorTest.javaclass Data1 {\tint value;}class Data2 {\tint value;\tData2(int x) { \t// 매개변수가 있는 생성자.\t\tvalue = x;\t}}class ConstructorTest {\tpublic static void main(String[] args) {\t\tData1 d1 = new Data1();\t\tData2 d2 = new Data2();\t\t// compile error발생\t}}위와 같이 코드를 작성하면 d2 = new Data2()에서 에러가 발생한다. 그 이유는 Data2에는 이미 생성자 Data2(int x)가 정의되어 있기 때문에 기본 생성자가 추가되지 않는다.따라서 올바르게 인스턴스를 생성하려면 d2 = new Data2(10)과 같은 형태로 작성해야 한다. 기본 생성자가 컴파일러에 의해 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을때 뿐이다.!매개변수가 있는 생성자인스턴스는 각기 다른 값으로 초기화되어야하는 경우가 많기 때문에 매개변수를 사영한 초기화는 매우 유용하다.예제를 들어 유용한지 확인해보자class Car {\tString color;\t\t// 색상\tString gearType;\t// 변속기 종류 - auto(자동), manual(수동)\tint door;\t\t\t// 문의 개수\tCar() {}\tCar(String c, String g, int d) {\t\tcolor = c;\t\tgearType = g;\t\tdoor = d;\t}}class CarTest {\tpublic static void main(String[] args) {\t\tCar c1 = new Car();\t\tc1.color = \"white\";\t\tc1.gearType = \"auto\";\t\tc1.door = 4;\t\tCar c2 = new Car(\"white\", \"auto\", 4);\t\tSystem.out.println(\"c1의 color=\" + c1.color + \", gearType=\" + c1.gearType+ \", door=\"+c1.door);\t\tSystem.out.println(\"c2의 color=\" + c2.color + \", gearType=\" + c2.gearType+ \", door=\"+c2.door);\t}}위의 예제에서 c1과 c2의 속성에 값을 초기화 하는거는 같지만 c1은 인스턴스를 생성한 다음 값을 초기화 했고, c2는 인스턴스를 생성하는 동시에 값을 대입했다 .c1이 가르키는 객체보다 c2가르키는 객체 의 생성 방식의 코드가 더 간결하고 직관적이다. 이처럼 클래스를 작성할 때 다양한 생성자를 제공함으로써 인스턴스 생성 후에 별도로 초기화를 하지 않아도 되도록하는게 좋다.생성자에서 다른 생성자 호출하기 - this(), this같은 클래스의 멤버들 간에 서로 호출할 수 있는 것처럼 생성자 간에도 서로 호출이 가능하다. 그러기 위해서는 다음과 두 조건을 만족시켜야 한다. 생성자의 이름으로 클래스 이름 대신 this를 사용한다. 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.class Car {\tString color;\t\t// 색상\tString gearType;\t// 변속기 종류 - auto(자동), manual(수동)\tint door;\t\t\t// 문의 개수\tCar() {\t\tthis(\"white\", \"auto\", 4);\t\t}\tCar(String color) {\t\tthis(color, \"auto\", 4);\t}\tCar(String color, String gearType, int door) {\t\tthis.color = color;\t\tthis.gearType = gearType;\t\tthis.door = door;\t}}class CarTest2 {\tpublic static void main(String[] args) {\t\tCar c1 = new Car();\t\t\tCar c2 = new Car(\"blue\");\t\tSystem.out.println(\"c1의 color=\" + c1.color + \", gearType=\" + c1.gearType+ \", door=\"+c1.door);\t\tSystem.out.println(\"c2의 color=\" + c2.color + \", gearType=\" + c2.gearType+ \", door=\"+c2.door);\t}}위의 예제에서 생성자 Car()에서 또 다른 생성자 Car(String color, String gearType, int door)를 호출하였다. 이처럼 생성자간의 호출에는 생성자의 이름 대신 this를 사용해야만 하므로 ‘Car’대신 ‘this’를 사용하였다. 그리고 첫줄에서 호출하여 다른 생성자를 불렀다.Car(String color, String gearType, int door) {\t\tthis.color = color;\t\tthis.gearType = gearType;\t\tthis.door = door;\t}위의 코드처럼 생성자의 매개변수로 인스턴스 변수들의 초기값을 제공받는 경우가 많아 인스턴스변수의 이름과 일치하는 경우가 자주 있다. 이때 구별하기 위해 this를 사용하여 구별한다.this는 참조변수로, 인스턴스 자신을 가르킨다. 참조변수를 통해 인스턴스의 멤버에 접근할 수 있는 것처럼 thi로 인스턴스변수에 접근할 수 있는 것이다.또한 this을 사용할 수 있는 것은 인스턴스 멤버뿐이다. static 메서드에서는 인스턴스 멤버들을 사용할 수 없는 것처럼 this 역시 사용할 수 없다. this : 인스턴스 자신을 가르키는 참조변수, 인스턴스의 주소가 저장되어있다모든 인스턴스 메서드에 지역변수에 숨겨진 채로 존재한다.this() : 같은 클래스의 다른 생성자를 호출할 때 사용된다.📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[자바의 정석] 오버로딩", "url": "/posts/Java_OverLoading/", "categories": "java", "tags": "java", "date": "2023-02-04 00:00:00 +0800", "snippet": "오버로딩이란?한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 ‘메서드 오버로딩(method overloading)’ 또느 간단히 오버로딩이라고 한다.오버로딩의 조건같은 이름의 메서드를 정의한다고 무조건 오버로딩이 아니다. 오버로딩이 성립하기 위해서는 다음과 같은 조건을 만족해야 한다. 메서드 이름이 같아야 한다. 매개변수의 개수 또는 ...", "content": "오버로딩이란?한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 ‘메서드 오버로딩(method overloading)’ 또느 간단히 오버로딩이라고 한다.오버로딩의 조건같은 이름의 메서드를 정의한다고 무조건 오버로딩이 아니다. 오버로딩이 성립하기 위해서는 다음과 같은 조건을 만족해야 한다. 메서드 이름이 같아야 한다. 매개변수의 개수 또는 타입이 달라야 한다.메서드의 이름이 같다 해도 매개변수가 다르면 서로 구별될 수 있기 때문에 오버로딩이 가능한 것이다.ex1)int add(int a, int b) { return a+b;}int add(int x, int y) { return x+y;}위의 두 메서드는 매개변수의 이름만 다른 뿐 매개변수의 타입이 같기 때문에 오버로딩이 성립하지 않는다.ex2)int add(int a, int b) { return a+b;}long add(int a, int b) { return (long) (a+b);}위의 예제는 리턴 타입만 다를 뿐 매개변수의 타입과 개수가 일치하기 때문에 오버로딩이 성립하지 않는다.ex3)long add(int a, long b) { return a+b;}long add(long a, int b) { return a+b;}두 메서드 모두 int형과 long형 매개변수가 하나씩 선언되어 있지만, 서로 순서가 다른 경우 호출 시 매개변수의 값에 의해 호출될 메서드가 구분될 수 있으므로 중복된 메서드가 아닌 오버로딩으로 간주한다. 오버로딩의 장점 메서드를 사용하는 쪽에서는 이름을 일일이 구분해서 기억 안해도되고 기억하기 쉽다. 메서드의 이름 절약가능 같은 일을 하지만 매개변수를 달리해야하는 경우에, 이와 같이 이름은 같고 매개변수를 다르게 하여 오버로딩을 구현한다.가변인자 오버로딩기존에는 메서드의 매개변수 개수가 고정적이었으나 JDK1.5부터 동적으로 지정해 줄 수 있게 되었으며, 이기능을 가변인자(variable arguments)라고 한다.가변인자는 “타입..변수명”과 같은 형식으로 선언하며, PrintStream클래스의 printf()가 대표적인 예다.public PrintStream printf(String format, Object.. args) {...}위와 같이 가변인자 외에도 매개변수가 더 있다면, 가변인자를 매개변수 중에서 제일 마지막에 선언해야 한다. 그렇지 않으면, 컴파일 에러가 난다. 가변인자인지 아닌지를 구별할 방법이 없기 때문에 허용하지 않는 것이다.//컴파일 에러 발생 - 가변인자는 항상 마지막 매개변수여야 한다.public PrintStream printf(Object... args, String format) { ...}ch6/VarArgsEx.javaclass VarArgsEx {\tpublic static void main(String[] args) {\t\tString[] strArr = { \"100\", \"200\", \"300\" };\t\t\t\tSystem.out.println(concatenate(\"\", \"100\", \"200\", \"300\"));\t\tSystem.out.println(concatenate(\"-\", strArr));\t\tSystem.out.println(concatenate(\",\", new String[]{\"1\", \"2\", \"3\"}));\t\tSystem.out.println(\"[\"+concatenate(\",\", new String[0])+\"]\");\t\tSystem.out.println(\"[\"+concatenate(\",\")+\"]\");\t}\tstatic String concatenate(String delim, String... args) {\t\tString result = \"\";\t\tfor(String str : args) {\t\t\tresult += str + delim;\t\t}\t\t\t\treturn result;\t}/*\tstatic String concatenate(String... args) {\t\treturn concatenate(\"\",args);\t}*/} // class가변인자는 내부적으로 배열을 이용한다. 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생긴다.만약 주석처리된 concatenate을 주석을 풀게 되면 컴파일 에러가 발생한다.가변인자를 선언한 메서드를 오버로딩하면, 메서드를 호출했을 때 이와 같이 구별되지 못하는 경우가 발생하기 쉽기 때문에 주의해야 한다. 가능하면 가벼인자를 사용한 메서드는 오버로딩하지 않는 것이 좋다.📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[자바의 정석] 변수와 메서드", "url": "/posts/Java_Variable_Method/", "categories": "java", "tags": "java", "date": "2023-01-27 00:00:00 +0800", "snippet": "선언위치에 따른 변수의 종류변수는 변수의 선언된 위치에 따라 3가지로 나뉜다. 클래스 변수 인스턴스 변수 지역변수멤버변수를 제외한 나머지 변수들은 모두 지역변수이며, 멤버변수 중 static이 붙은 것은 클래스변수, 붙지 않은 것은 인스턴스 변수이다.class Variables{\t\tint iv; //인스턴스 변수\t\tstatic int cv; /...", "content": "선언위치에 따른 변수의 종류변수는 변수의 선언된 위치에 따라 3가지로 나뉜다. 클래스 변수 인스턴스 변수 지역변수멤버변수를 제외한 나머지 변수들은 모두 지역변수이며, 멤버변수 중 static이 붙은 것은 클래스변수, 붙지 않은 것은 인스턴스 변수이다.class Variables{\t\tint iv; //인스턴스 변수\t\tstatic int cv; //클래스 변수\t\tvoid method(){\t\t\t\tint lv=0; //지연 변수\t\t}} 변수의 종류 선언위치 생성시기 클래스 변수 클래스 영역 클래스가 메모리에 올라갈 때 인스턴스 변수 클래스 영역 인스턴스가 생성되었을 때 지역 변수 클래스 영역 외의 영역 변수 선언문이 수행되었을 때 클래스변수와 인스턴스변수클래스변수와 인스턴스변수의 차이를 이해하기 위한 예로 카드 게임에 사용되는 카드를 클래스로 정의해보자.class Card {\tString kind ;\t\t\t\t// 카드의 무늬 - 인스턴스 변수\tint number;\t\t\t\t // 카드의 숫자 - 인스턴스 변수\tstatic int width = 100;\t\t// 카드의 폭 - 클래스 변수\tstatic int height = 250;\t// 카드의 높이 - 클래스 변수}각 Card인스턴스는 자신만의 무늬와 숫자가 있어서 인스턴스 변수로 선언해야 하고, 각 카드의 폭과 높이는 모든 인스턴스가 공통적으로 같은 값을 유지해야 하므로 클래스 변수로 선언한것이다.ch6/CardTest.javaclass CardTest{\tpublic static void main(String args[]) {\t\tSystem.out.println(\"Card.width = \" + Card.width);\t\tSystem.out.println(\"Card.height = \" + Card.height);\t\tCard c1 = new Card();\t\tc1.kind = \"Heart\";\t\tc1.number = 7;\t\tCard c2 = new Card();\t\tc2.kind = \"Spade\";\t\tc2.number = 4;\t\tSystem.out.println(\"c1은 \" + c1.kind + \", \" + c1.number + \"이며, 크기는 (\" + c1.width + \", \" + c1.height + \")\" );\t\tSystem.out.println(\"c2는 \" + c2.kind + \", \" + c2.number + \"이며, 크기는 (\" + c2.width + \", \" + c2.height + \")\" );\t\t\t\tSystem.out.println(\"c1의 width와 height를 각각 50, 80으로 변경합니다.\");\t\tc1.width = 50;\t\tc1.height = 80;\t\tSystem.out.println(\"c1은 \" + c1.kind + \", \" + c1.number + \"이며, 크기는 (\" + c1.width + \", \" + c1.height + \")\" );\t\tSystem.out.println(\"c2는 \" + c2.kind + \", \" + c2.number + \"이며, 크기는 (\" + c2.width + \", \" + c2.height + \")\" );\t} }위와 같이 Card.width, c1.width, c2.width 모두 같은 저장공간을 참조하므로 항상 같은 값을 갖게 된다. 클래스 변수를 사용할 때는 Card.width와 같이 ‘클래스이름.클래스변수’의 형태로 하는 것이 좋다. 참조변수 c1,c2를 통해서도 클래스변수를 사용할 수 있지만 이렇게 하면 클래스변수를 인스턴스변수로 오해하기 쉽기 때문이다.메서드메서드는 크게 두 부분 선언부와 구현부로 이루어져 있다.반환타입 메서드이름 (타입 변수명, 타입 변수명, ...){ //선언부\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//구현부}int add(int a, int b) { //선언부\tint result = a+b ; //구현부\treturn result;\t\t\t}\t\t 메서드 선언부는 메서드 이름, 매배변수 선언, 반환타입으로 구성되어 있다. 구현부에는 수행할 문장들을 넣으면 된다. 반환타입과 return할 변수의 타입은 같아야 하고, return 문은 저장된 변수 값을 호출한 메서드로 반환한다.JVM의 메모리 구조응용 프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다. 그 중 3가지 주요 영역에 대해서 알아보자JVM의 메모리 구조 Method Area 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(.class)을 읽어서 분석하여 클래스에 대한 정보를 이곳에 저장한다. 이 때, 그 클래스의 클래스변수도 이 영역에 저장된다. Heap 인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다. 인스턴수의 변수들이 생성되는 공간이다. 호출스택(Call stack 또는 execution stack) 호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리 공간은 반환되어 비워진다. 호출스택을 예제로 살펴보자class CallStackTest {\tpublic static void main(String[] args) {\t\tfirstMethod();\t}\tstatic void firstMethod() {\t\tsecondMethod();\t}\tstatic void secondMethod() {\t\tSystem.out.println(\"secondMethod()\");\t\t\t}}위의 실행결과를 그림으로 살펴보면예제를 실행하면 JVM이 main메서드를 호출하여 먼저 main이 실행되고, main이 firstMethod()를 호출하여 (3)처럼 호출스택에 firstMethod가 위에 쌓여 있는것을 볼 수 있다. firstMethod가 secondMethod()를 호출하여 secondMethod()가 실행되고 println을 호출하여 화면에 출력한다. 출력한 후 println()은 호출스택에서 사라지고 sceondMethod()도 종료하여 호출스택에서 제거된다. firstMethod()도 더 이상 실행할 코드가 없어 호출스택에서 제거되고 main도 더 이상 수행할 코드가 없어 종료되어 호출스택은 비워지고 프로그램은 종료하게 된다.기본형 매개변수와 참조형 매개변수메서드의 매개변수를 기본형으로 선언하면 단순히 저장된 값만 얻지만, 참조형으로 선언하면 값이 저장된 곳의 주소를 알 수 있기 때문에 값을 읽어 오는 것은 물론 값을 변경하는 것도 가능하다.ch6/PrimitiveParamEx.javaclass Data { int x; }class PrimitiveParamEx {\tpublic static void main(String[] args) {\t\tData d = new Data();\t\td.x = 10;\t\tSystem.out.println(\"main() : x = \" + d.x);\t\tchange(d.x);\t\tSystem.out.println(\"After change(d.x)\");\t\tSystem.out.println(\"main() : x = \" + d.x);\t}\tstatic void change(int x) { // ±âº»Çü ¸Å°³º¯¼ö\t\tx = 1000;\t\tSystem.out.println(\"change() : x = \" + x);\t}}//실행결과main() : x = 10change() : x = 1000After change(d.x)main() : x = 10위의 예제를 보면 change()에 매개변수로 넘겨준 x값을 1000을 대입했지만 대입한후 main함수에서 x의값을 출력하면 여전히 10이 출력되는 것을 볼 수 있다. 이처럼 기본형 매개변수는 변수에 저장된 값만 읽을 수만 있을 뿐 변경할 수 없다.ch6/ReferenceParamEx.javaclass Data { int x; }class ReferenceParamEx {\tpublic static void main(String[] args) {\t\tData d = new Data();\t\td.x = 10;\t\tSystem.out.println(\"main() : x = \" + d.x);\t\tchange(d);\t\tSystem.out.println(\"After change(d)\");\t\tSystem.out.println(\"main() : x = \" + d.x);\t}\tstatic void change(Data d) { // 참조형 매개변수\t\td.x = 1000;\t\tSystem.out.println(\"change() : x = \" + d.x);\t}}//실행결과main() : x = 10change() : x = 1000After change(d)main() : x = 1000이전 예제와 달리 change메서드를 호출한 후에 d.x의 값이 변경되었다. change메서드의 매개변수가 참조형이라서 값이 아니라 ‘값이 저장된 주소’를 change메서드에게 넘겨주었기 때문에 값을 읽어 오는것 뿐만 아니라 변경도 가능하다. 반환타입이 참조형이라는 것은 메서드가 ‘객체의 주소’를 반환한다는 것을 의미한다.클래스 메서드(Static 메서드)와 인스턴스 메서드인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는 즉, 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다. 반면에 메서드 중에서 인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드를 클래스 메서드(static 메서드)로 정의한다. static변수는 인스턴스를 생성하지 않아도 사용할 수 있다. static이 변수는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문이다. 클래스 메서드(static 메서드)는 인스턴스 변수를 사용할 수 없다. 인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스 메서드는 인스턴스 생성 없이 호출 가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다. 그래서 클래스 메서드에서 인스턴스 변수의 사용을 금지한다. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다. 메서드의 작업내영 중에서 인스턴스 변수를 필요로 한다면, static을 붙일 수 없다. 반대로 인스턴스변수를 필요로 하지 않는다면 static을 붙이자. 메서드 호출시간이 짧아지므로 성능이 향상된다. 클래스 멤버와 인스턴스 멤버간의 참조와 호출같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다. 단, 클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야한다.그 이유는 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다.ch6/MemberCall.javaclass MemberCall {\tint iv = 10;\tstatic int cv = 20;\tint iv2 = cv;//\tstatic int cv2 = iv;\t\t// 에러. 클래스변수는 인스턴스 변수를 사용할 수 없음.\tstatic int cv2 = new MemberCall().iv;\t // 이처럼 객체를 생성해야 사용가능.\tstatic void staticMethod1() {\t\tSystem.out.println(cv);//\t\tSystem.out.println(iv); // 에러. 클래스메서드에서 인스턴스변수를 사용불가.\t\tMemberCall c = new MemberCall();\t\t\tSystem.out.println(c.iv); // 객체를 생성한 후에야 인스턴스변수의 참조가능.}\tvoid instanceMethod1() {\t\tSystem.out.println(cv);\t\t\t\tSystem.out.println(iv); // 인스턴스메서드에서는 인스턴스변수를 바로 사용가능.}\tstatic void staticMethod2() {\t\tstaticMethod1();//\t\tinstanceMethod1(); // 에러. 클래스메서드에서는 인스턴스메서드를 호출할 수 없음.\t\tMemberCall c = new MemberCall();\t\tc.instanceMethod1(); // 인스턴스를 생성한 후에야 호출할 수 있음. \t}\t\tvoid instanceMethod2() {\t// 인스턴스메서드에서는 인스턴스메서드와 클래스메서드\t\tstaticMethod1();\t\t// 모두 인스턴스 생성없이 바로 호출이 가능하다.\t\tinstanceMethod1();\t}}위의 코드는 같은 클래스 내의 인스턴스 메서드와 static 메서드간의 호출에 대해서 설명하고 있다. 같은 클래스 내의 메서드는 서로 객체의 생성이나 참조변수 없이 직접 호출이 가능하지만 static 메서드는 인스턴스 메서드를 호출할 수 없다. 인스턴스 멤버는 반드시 객체를 생성한 후에만 참조 또는 호출이 가능하기 때문에 클래스멤버가 인스턴스멤버를 참조, 호출하기 위해서는 객체를 생성하여야 한다.📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[자바의 정석] 클래스와 객체", "url": "/posts/Java_Class/", "categories": "java", "tags": "java", "date": "2023-01-26 00:00:00 +0800", "snippet": "클래스와 객체클래스는 객체의 설계도 또는 틀이라고 정의하며, 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다.객체와 인스턴스객체와 인스턴스는 같은 의미이지만, 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖고 있으며. 인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미를 갖고 있다.ex) 책상은 인스턴스다. -&...", "content": "클래스와 객체클래스는 객체의 설계도 또는 틀이라고 정의하며, 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다.객체와 인스턴스객체와 인스턴스는 같은 의미이지만, 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖고 있으며. 인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미를 갖고 있다.ex) 책상은 인스턴스다. -&gt; 책상은 객체다.\t\t책상은 클래스의 객체이다 -&gt; 책상은 클래스의 인스턴스이다.객체의 구성요소 - 속성과 기능객체는 속성과 기능의 집합Tv의 속성과 기능을 예로 들어보자. Tv를 나타내는 속성으로는 크기, 길이, 높이, 색상 등이 있고 Tv의 기능에는 켜기/끄기, 볼륨 높이기/낮추기, 채널 변경하기 등이 있다.이 속성과 기능은 프로그래밍으로는 변수와 메서드로 나타낼 수 있으며 Tv 클래스를 만들어보면 아래와 같다.class Tv {\t\tString color;\t\tboolean power;\t\tint channel;\t\tvoid power() { power != power;}\t\tvoid channelUp(); { channel++;}\t\tvoid channelDown(); { channel--;}}인스턴스의 생성과 사용클래스를 선언한 것은 설계도를 작성한 것이고, 객체를 생성해야 사용할 수 있다.클래스명 변수명;변수명 = new 클래스명();ch6/TvTest.javaclass Tv { // Tv의 속성(멤버변수) String color; \t// 색상 boolean power; \t// 전원상태(on/off) int channel; \t// 채널 // Tv의 기능(메서드) void power() { power = !power; } // TV를 켜거나 끄는 기능을 하는 메서드 void channelUp() { ++channel; } // TV의 채널을 높이는 기능을 하는 메서드 void channelDown() { --channel; } // TV의 채널을 낮추는 기능을 하는 메서드 }class TvTest { public static void main(String args[]) { Tv t; // Tv인스턴스를 참조하기 위한 변수 t를 선언 t = new Tv(); // Tv인스턴스를 생성한다. t.channel = 7; // Tv인스턴스의 멤버변수 channel의 값을 7로 한다. t.channelDown(); // Tv인스턴스의 메서드 channelDown()을 호출한다. System.out.println(\"현재 채널은 \" + t.channel + \" 입니다.\"); } }인스턴스 생성 과정 Tv t; Tv 클래스 타입의 참조변 수 t를 선언한다. 메모리에 참조변수 t를 위한 공간이 마련된다. 아직 인스턴스가 생성되지 않았으므로 참조변수로 아무것도 할 수 없다. t = new Tv(); 연산자 new에 의해 Tv 클래스의 인스턴스가 메모리의 빈 공간에 생성 된다. 주소가 0x100인 곳에 생성되었다고 가정하자. 이때, 멤버 변수가 각 자료형에 해당하는 기본값으로 초기화 된다. 이 후 =(대입연산자)에 의해 생성된 객체의 주소값이 참조변수 t에 저장된다. 이제는 참조변수 t를 통해 Tv인스턴스를 접근할 수 있다. t.channel=7, t.channelDown(); t.channel=7은 참조변수 t에 저장된 주소에 있는 인스턴스의 멤버변수 channel에 7을 저장한다. t.channelDown()은 참조변수 t가 참조하고 있는 Tv인스턴스의 channelDown()을 호출하여 멤버변수 channel을 감소시킨다. 인스턴스 공유 같은 클래스로부터 생성되도 각 인스턴스의 속성은 서로 다른 값을 유지할 수 있으며, 메서드의 내용은 모든 인스턴스에 대해 동일하다.ch6/TvTest3.javaclass Tv { // Tv의 속성(멤버변수) String color; // 색상 boolean power; // 전원상태(on/off) int channel; \t // 채널 // Tv의 기능(메서드) void power() { power = !power; } // TV를 켜거나 끄는 기능을 하는 메서드 void channelUp() { ++channel; } // TV의 채널을 높이는 기능을 하는 메서드 void channelDown() { --channel; } // TV의 채널을 낮추는 기능을 하는 메서드 }class TvTest3 {\tpublic static void main(String args[]) {\t\tTv t1 = new Tv();\t\tTv t2 = new Tv();\t\tSystem.out.println(\"t1의 channel값은 \" + t1.channel + \"입니다.\");\t\tSystem.out.println(\"t2의 channel값은 \" + t2.channel + \"입니다.\");\t\tt2 = t1;\t\t// t1이 저장하고 있는 값(주소)을 t2에 저장한다.\t\tt1.channel = 7;\t// channel 값을 7로 한다.\t\tSystem.out.println(\"t1의 channel값을 7로 변경하였습니다.\");\t\tSystem.out.println(\"t1의 channel값은 \" + t1.channel + \"입니다.\");\t\tSystem.out.println(\"t2의 channel값은 \" + t2.channel + \"입니다.\");\t}}이 예제에 실행과정을 그림으로 보면 다음과 같다.t1과 t2는 처음에 각각 다른 인스턴스의 주소를 가지고 있다가, t2=t2;을 실행하면 t2가 가지고있던 참조값은 잃어버리게 되고 t1에 저장되어 있던 값이 t2에 저장되게 된다. 그러면 t2와 t1은 동일한 인스턴스를 가르키게 된다.위처럼 자바에서는 참조변수를 통해서 객체를 다른 변수와 공유할 수 있다." }, { "title": "[JPA] JPA란?", "url": "/posts/JPA/", "categories": "JPA", "tags": "java, ORM, JPA", "date": "2023-01-25 00:00:00 +0800", "snippet": "SQL 중심적인 개발의 문제점데이터베이스에서는 관계형 DB, 어플리케이션에서는 객체지향언어인 자바를 사용한다 했을 때, 자바에서 사용하는 객체를 SQL문으로 관계형 DB에 저장해야 한다. 그러기 위해서 자바에서는 객체를 SQL문으로 변환하여 DB에 접근하고, SQL을 자바 객체로 변환해야 하는데, 이 작업은 상당히 지루하고 반복적인 코드가 나오게 된...", "content": "SQL 중심적인 개발의 문제점데이터베이스에서는 관계형 DB, 어플리케이션에서는 객체지향언어인 자바를 사용한다 했을 때, 자바에서 사용하는 객체를 SQL문으로 관계형 DB에 저장해야 한다. 그러기 위해서 자바에서는 객체를 SQL문으로 변환하여 DB에 접근하고, SQL을 자바 객체로 변환해야 하는데, 이 작업은 상당히 지루하고 반복적인 코드가 나오게 된다.위의 사진은 만약 요구사항중에 회원 객체에 전화번호 속성이 추가되었다면, 개발자들은 직접 SQL문에 전화번호 속성들을 추가해야 하는 작업이 생기게 된다. 개발자들은 이런식으로 일일이 다 SQL문으로 다 바꿔서 DB에 저장하면 시간도 오래걸리고 단순반복의 코드가 늘어날 것이다. 이처럼 SQL에 의존적인 개발은 좋지 않다!!이 자바 객체와 관계형 데이터베이스사이에 SQL변환하는 과정에서 어려움이 생기는 이유는 바로 객체와 관계형 데이터베이스간의 패러다임이 일치하지 않아서 생기는 문제이다.패러다임의 불일치 객체 VS 관계형 DB객체와 관계형 DB는 크게 2가지의 차이점이 존재한다. 상속 연관관계상속 객체지향에서는 객체사이에 상속관계가 존재하지만, 관계형 데이터베이스 테이블에 상속관계라는 것이 존재하지 않는다. 데이터베이스에는 상속관계와 유사한 Table 슈퍼타입과 서브타입 관계가 있긴하지만 자바의 상속관계랑 개념이 똑같지가 않아 이 객체를 DB에 저장할 때 어려움이 있다.연관관계 객체는 참조를 사용한다. ex) member.getTeam(); 테이블은 외래키를 사용한다. ex) JOIN ON M.TEAM_ID = T.TEAM_ID 이 때문에 객체의 참조로 맺는 연관관계를 DB에 저장할때 굉장히 까다롭다.자바 객체와 DB의 매핑 작업이 매우 많아지기 때문에 자바 컬렉션처럼 DB에 저장할 수 있는 개념이 바로 JPA이다.JPA란?Java Persistence API로 자바 진영의 ORM 표준 기술이다. 그럼 여기서 ORM은 뭘까?ORM은 Object Relational Mapping의 약자로 객체랑 관계형 DB를 서로 매핑해주는 프레임워크다.위의 그림과 같이 JPA는 어플리케이션과 JDBC사이에서 동작한다. 즉, 완전히 새로운 기술이 아니라 원래 자바가 JDBC로 DB랑 통신을 했지만 JPA도 JDBC사이에서 동작하는 것이다.만약 회원 객체를 저장하면, JPA는 이 회원 객체(Entity)를 분석 후 INSERT문 SQL문을 직접 생성해서 JDBC API를 이용해서 데이터베이스에 저장한다.JPA는 표준 명세(인터페이스의 모음)이고 어플리케이션은 JPA의 구현체들을 사용하여 ORM 프레임워크를 사용해야 한다. 그 중 JPA 구현체인 Hibernate를 많이 쓴다.JPA를 사용해야 하는 이유SQL 중심적인 개발에서 이제는 객체 중심으로 설계를 하면 JPA가 알아서 SQL문을 작성해주기 때문에 생산성, 유지보수 측면에서 높은 효율을 얻을 수 있다.위의 사진처럼 개발자는 jpa.persist한줄의 코드로 album객체를 넣어주면 쿼리문은 JPA가 알아서 처리를 해준다.JPA의 성능 최적화 기능 1차 캐시와 동일성(identity) 보장 트랜잭션을 지원하는 쓰기 지연(transactional write-behind) 지연 로딩(Lazy Loading)1차 캐시와 동일성(identity) 보장 같은 트랜잭션 안에서는 같은 엔티티를 반환한다 - 약간의 조회 성능 향상 DB Isolation Level이 Read Commit이어도 애플리케이션에서 Repeatable Read 보장한다.String memberId = \"100\";Member m1 = jpa.find(Member.class, memberId); //SQLMember m2 = jpa.find(Member.class, memberId); //캐시println(m1 == m2) //true위와 같은 문장에서 DB로부터 2번의 조회 문장이 있는 것 같지만 실제로는 SQL문이 한번만 나간다.트랜잭션을 지원하는 쓰기 지연 - INSERT 트랜잭션을 커밋할 때까지 INSERT SQL을 모으고 JDBC BATCH SQL 기능을 사용해서 한번에 SQL을 전송한다.transaction.begin(); // [트랜잭션] 시작em.persist(memberA);em.persist(memberB);em.persist(memberC);//여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.//커밋하는 순간 데이터베이스에 INSERT SQL을 모아서 보낸다.transaction.commit(); // [트랜잭션] 커밋위와 같은 코드로 구성하면 commit 시점에 insert문 sql이 나가 쿼리를 한번만 질의할 수 있게 된다. 이로써 네트워크 통신 비용을 줄일 수 있다.지연 로딩(Lazy Loading) 지연로딩은 객체가 실제 사용될 때 로딩되는거를 말하고 즉시 로딩은 JOIN SQL로 한번에 연관된 객체까지 미리 조회하는 것을 말한다.위의 사진과 같이 지연로딩은 객체가 실제 사용될때 쿼리문이 나가는 것이고, 즉시 로딩은 sql문이 나갈때 객체와 연관된 테이블까지 다 같이 조회하는 것을 말한다.📖 references 자바 ORM 표준 JPA 프로그래밍 -기본편 by 김영한" }, { "title": "[자바의 정석] 배열", "url": "/posts/Java_Array/", "categories": "java", "tags": "java", "date": "2023-01-24 00:00:00 +0800", "snippet": "배열이란?같은 타입의 여러 변수를 하나의 묶음으로 다루는 것을 배열이라고 한다.배열의 선언과 생성 선언방법 선언 예 타입 [] 변수이름; int [] score; String [] name;   타입 변수이름[]; int...", "content": "배열이란?같은 타입의 여러 변수를 하나의 묶음으로 다루는 것을 배열이라고 한다.배열의 선언과 생성 선언방법 선언 예 타입 [] 변수이름; int [] score; String [] name;   타입 변수이름[]; int score[]; String name[];   배열의 생성배열의 선언은 생성된 배열을 다루기 위한 참조변수를 위한 공간이 만들어질 뿐이고, 배열을 생성해야만 비로소 값을 저장할 수 있는 공간이 만들어지는 것이다.배열을 생성하기 위해서는 연산자 ‘new’와 함께 배열의 타입과 길이를 지정해줘야 한다.👉 타입 [] 변수이름; //배열 선언변수이름 = new 타입[길이]; //배열 생성배열 생성 과정int [] score;score = new int[5]; int [] score; int형 배열 참조변수 score를 선언한다. 데이터를 저장할 수 있는 공간은 아직 마련되지 않았다. score = new int[5]; 연산자 ‘new’에 의해서 메모리의 빈 공간에 5개의 int형 데이터를 저장할 수 있는 공간이 마련된다. 각 배열 요소는 자동적으로 int의 기본값(default)인 0으로 초기화 된다. 끝으로 대입 연산자’=’에 의해 배열의 주소가 int형 배열 참조변수 score에 저장된다. 배열의 길이와 인덱스생성된 배열의 각 저장공간을 배열의 요소(element)라고 하며, 배열이름[인덱스]의 형식으로 배열에 요소에 접근한다. 인덱스(index)는는 배열의 요소마다 붙여진 일련번호로 각 요소를 구별하는데 사용된다.👉 인덱스(index)**의 범위는 0부터 ‘배열길이-1’까지배열 예제public static void main(String[] args) { \t\tint[] score = new int[5];\t\tint k = 1;\t\tscore[0] = 50;\t\tscore[1] = 60;\t\tscore[k+1] = 70; // score[2] = 70\t\tscore[3] = 80;\t\tscore[4] = 90;\t\tint tmp = score[k+2] + score[4]; // int tmp = score[3] + score[4]\t // for문으로 배열의 모든 요소를 출력한다.\t\tfor(int i=0; i &lt; 5; i++) {\t\t\tSystem.out.printf(\"score[%d]:%d%n\",i, score[i]);\t\t\t\t}\t\tSystem.out.printf(\"tmp:%d%n\", tmp);\t\tSystem.out.printf(\"score[%d]:%d%n\",7,score[7]); //index의 범위를 벗어난 값\t} // main//실행결과score[0]:50score[1]:60score[2]:70score[3]:80score[4]:90tmp:170Exception in thread \"main\" java.lang.ArrayIndexOutOfBoundsException: Index 7 out of bounds for length 5\tat OperatorEx22.main(OperatorEx22.java:20)배열 인덱스 범위에 속하지 않는 7을 배열의 인덱스로 해서 값을 출력하면 에러가 발생한다. 컴파일 시에는 아무런 문제가 없지만 실행 시에는 에러가 발생한다.배열의 길이 배열의 길이는 int 범위의 양의 정수(0도 포함)이어야 한다. JVM에서는 모든 배열의 길이를 별도로 관리하며 ‘배열이름.length’를 통해 배열의 길이를 알 수 있다. int [] arr = new int[5]; int tmp = arr.length; 배열은 한번 생성하면 길이를 변경할 수 없기 대문에, 이미 생성된 배열의 길이는 변하지 않느다. 배열의 초기화int [] score = new int[]{50,60,70,80,90}; //배열의 생성과 초기화를 동시에int [] score = {50,60,70,80,90}; //new int[] 생략 가능int [] score = {}; //길이가 0인 배열, new int[]가 생략됨위와 같이 배열의 초기화는 생성과 동시에 가능하며, 배열의 선언과 생성을 따로 하는 경우는 new int[]를 생략할 수 없다.int [] score;score = {50,60,70,80,90}; //에러, new int[]를 생략할 수 없음배열의 출력배열을 출력하면 배열의 주소가 아닌 ‘타입@주소’형태로 출력된다.int [] Arr = {100, 95, 90, 70, 60};System.out.println(Arr); //[I@14318bb와 같은 형식의 문자열이 출력된다.다차원 배열 선언 방법 선언 예 타입[][] 변수이름; int [][] score; 타입 변수이름[][]; int score[][]; 타입[] 변수이름[]; int [] score[]; 2차원 배열 예제class ArrayEx18 {\tpublic static void main(String[] args) {\t\t int[][] score = {\t\t\t\t\t\t\t{ 100, 100, 100}\t\t\t\t\t\t\t, { 20, 20, 20}\t\t\t\t\t\t\t, { 30, 30, 30}\t\t\t\t\t\t\t, { 40, 40, 40}\t\t\t\t\t\t};\t\tint sum = 0;\t\tfor(int i=0;i &lt; score.length;i++) {\t\t\tfor(int j=0;j &lt; score[i].length;j++) {\t\t\t\tSystem.out.printf(\"score[%d][%d]=%d%n\", i, j, score[i][j]);\t\t\t}\t\t}\t\tfor (int[] tmp : score) { \t\t\t for (int i : tmp) { \t\t\t\tsum += i;\t\t\t } \t\t} \t\tSystem.out.println(\"sum=\"+sum);\t}}//실행결과score[0][0]=100score[0][1]=100score[0][2]=100score[1][0]=20score[1][1]=20score[1][2]=20score[2][0]=30score[2][1]=30score[2][2]=30score[3][0]=40score[3][1]=40score[3][2]=40sum=570위와 같이 자바는 2차원 이상의 배열은 배열의 배열 형태로 처리된다.📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[자바의 정석] 연산자", "url": "/posts/Java_Operator/", "categories": "java", "tags": "java", "date": "2023-01-23 00:00:00 +0800", "snippet": "연산자의 종류 종류 연산자 설명       산술 연산자 + - * / &amp; « » 사칙연산과 나머지 연산       비교 연산자 &gt; &lt; ≤ ≥ == ≠ 크고...", "content": "연산자의 종류 종류 연산자 설명       산술 연산자 + - * / &amp; « » 사칙연산과 나머지 연산       비교 연산자 &gt; &lt; ≤ ≥ == ≠ 크고 작음과 같고 다름을 비교       논리 연산자 &amp;&amp;   ! &amp; ^ ~ 그리고와 또는으로 조건을 연결 대입 연산자 = 우변의 값을 좌변에 저장       기타 (type) ?: instanceof 형변환 연산자, 삼항 연산자, instanceof 연산자       단항 연산자증감연산자 ++ — 증감 연산자는 피연산자에 저장된 값을 1증가 또는 감소 시킨다. 증가 연산자(++) 피연산자의 값을 1 증가시킨다.감소 연산자(—) 피연산자의 값을 1 감소시킨다.피연산자의 왼쪽에 위치하면 전위형(prefix), 오른쪽에 위치하면 후위형(postfix)라고 한다. 타입 설명 사용예 전위형 값이 참조되기 전에 증가시킨다. j= ++i; 후위형 값이 참조된 후에 증가시킨다. j= i++; 전위/후위 연산자의 예제class OperatorEx1 {\tpublic static void main(String args[]) {\t\tint i=5;\t\ti++;\t\t // i=i+1;과 같은 의미이다. ++i;로 바꿔 써도 결과는 같다. \t\tSystem.out.println(i);\t\ti=5;\t\t //\t결과를 비교하기 위해 i값을 다시 5로 변경.\t\t++i;\t\tSystem.out.println(i);\t}} 식을 계산하기 위해서는 식에 포함된 변수의 값을 읽어 와야 하는데, 전위형은 변수의 값을 먼저 증가시킨 후에 변수의 값을 읽어오는 반면, 후위형은 변수의 값을 먼저 읽어온 후 증가시킨다.증감 연산자를 사용하면 코드가 간결해지지만 지나치면 코드가 복잡해져 이해하기가 어렵다.👉 증감연산자는 식에 두 번 이상 포함된 변수에 증감연산자를 사용하는 것은 피해야 한다.부호 연산자 부호 연산자 ‘-’는 피연삱의 부호를 반대로 변경한 결과를 반환한다.비교 연산자두 피연산자를 비교하는데 사용되는 연산자며, 연산결과는 오직 true와 false를 반환한다.등가비교 연산자 두 피연산의 값이 같은지 또는 다른지를 비교하는 연산자(==, ≠) 기본형의 경우 변수에 저장되어 있는 값이 같은지를 알 수 있고, 참조형의 경우 객체의 주소값을 저장하기 때문에 두 개의 피연산자가 같은 객체를 가리키고 있는지를 알 수 있다. 기본형과 참조형은 서로 형변환이 불가능하므로 등가비교로 기본형과 참조형은 비교할 수 없다.등가비교 예제class OperatorEx22 {\tpublic static void main(String args[]) { \t\tfloat f = 0.1f;\t\tdouble d = 0.1;\t\tdouble d2 = (double)f;\t\tSystem.out.printf(\"10.0==10.0f %b\\n\", 10.0==10.0f);\t\tSystem.out.printf(\"0.1==0.1f %b\\n\", 0.1==0.1f);\t\tSystem.out.printf(\"f =%19.17f\\n\", f);\t\tSystem.out.printf(\"d =%19.17f\\n\", d);\t\tSystem.out.printf(\"d2=%19.17f\\n\", d2);\t\tSystem.out.printf(\"d==f %b\\n\", d==f);\t\tSystem.out.printf(\"d==d2 %b\\n\", d==d2);\t\tSystem.out.printf(\"d2==f %b\\n\", d2==f);\t\tSystem.out.printf(\"(float)d==f %b\\n\", (float)d==f);\t}}//실행결과10.0==10.0f true0.1==0.1f falsef =0.10000000149011612d =0.10000000000000000d2=0.10000000149011612d==f falsed==d2 falsed2==f true(float)d==f true실행결과에서 d==f에서 false가 나온것을 볼 수 있다. 10.0 == 10.0f는 true로 나왔지만, 0.1 == 0.1f는 false가 나왔다. 이 이유는 정수형과 달리 실수향은 근사값으로 저장되기 때문에 오차가 발생했기 때문이다.0.1f는 저장할때 2진수로 변환하는 과정에서 오차가 발생한다. 따라서 dobule형과 float형을 비교할때 false가 나온다.따라서 float형과 double형을 비교할때는 double형을 float형으로 형변환 후 비교해야 한다.문자열의 비교두 문자열을 비교할 때는 비교 연산자==대신 equals()라는 메서드를 사용해야 한다. 비교 연산자는 두 문자열이 완전히 같은 것인지 비교할 뿐이므로, 문자열의 내용이 같은지 비교하기 위해서는 equals()를 사용하는 것이다.문자열 비교 예제class OperatorEx23 {\tpublic static void main(String[] args) {\t\tString str1 = \"abc\";\t\tString str2 = new String(\"abc\");\t\tSystem.out.printf(\"\\\"abc\\\"==\\\"abc\\\" ? %b%n\", \"abc\"==\"abc\");\t\tSystem.out.printf(\" str1==\\\"abc\\\" ? %b%n\", str1==\"abc\");\t\tSystem.out.printf(\" str2==\\\"abc\\\" ? %b%n\", str2==\"abc\");\t\tSystem.out.printf(\"str1.equals(\\\"abc\\\") ? %b%n\", str1.equals(\"abc\"));\t\tSystem.out.printf(\"str2.equals(\\\"abc\\\") ? %b%n\", str2.equals(\"abc\"));\t\tSystem.out.printf(\"str2.equals(\\\"ABC\\\") ? %b%n\", str2.equals(\"ABC\"));\t\tSystem.out.printf(\"str2.equalsIgnoreCase(\\\"ABC\\\") ? %b%n\", str2.equalsIgnoreCase(\"ABC\"));\t}}//실행결과\"abc\"==\"abc\" ? true str1==\"abc\" ? true str2==\"abc\" ? falsestr1.equals(\"abc\") ? truestr2.equals(\"abc\") ? truestr2.equals(\"ABC\") ? falsestr2.equalsIgnoreCase(\"ABC\") ? truestr2와 “abc”의 내용이 같은데도 “==”로 비교하면, false를 결과로 얻는다. 내용은 같지만 서로 다른 객체라서 false를 반환한다. 그러나 equals()는 객체가 달라도 내용이 같으면 true를 반환한다. 그래서 문자열을 비교할 때는 항상 equals()를 사용해야 한다. equalsIgnore()는 대소문자를 구분하리 않고 구별할 때 사용한다.📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[자바의 정석] 변수", "url": "/posts/Java_Variable/", "categories": "java", "tags": "java", "date": "2023-01-06 00:00:00 +0800", "snippet": "변수란?단 하나의 값을 저장할 수 있는 메모리 공간하나의 변수에 단 하나의 값만 저장할 수 있으므로, 새로운 값을 저장하면 기존의 값은 사라진다.변수의 선언과 초기화 변수선언 : 변수타입 변수이름 ex) int age; 변수선언은, 메모리의 빈 공간에 변수타입에 맞게 알맞은 크기의 저장공간이 확보되고, 이 저장공간은 변수이름을 통해...", "content": "변수란?단 하나의 값을 저장할 수 있는 메모리 공간하나의 변수에 단 하나의 값만 저장할 수 있으므로, 새로운 값을 저장하면 기존의 값은 사라진다.변수의 선언과 초기화 변수선언 : 변수타입 변수이름 ex) int age; 변수선언은, 메모리의 빈 공간에 변수타입에 맞게 알맞은 크기의 저장공간이 확보되고, 이 저장공간은 변수이름을 통해 사용할 수 있다. 변수의 초기화 → 변수를 사용하기 전에 처음으로 값을 저장하는 것 변수명명 규칙 클래스 이름의 첫글자는 항상 대문자(파스칼 케이스), 변수와 메소드의 이름의 첫 글자는 항상 소문자(카멜 케이스)로 한다. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다. 상수의 이름은 모두 대문자로 하고, 여러 단어로 이루어진 경우 ‘_’로 구분한다.변수의 타입값의 종류에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것이 자료형(data type)이다.자료형에는 문자형(char), 정수형(byte, short, int, long), 실수형(float, double) 등이 있다.기본형과 참조형기본형은 변수는 실제값을 저장, 참조형 변수는 어떤 값이 저장되어 있는 주소(memory address)를 값으로 갖는다.기본형👉 논리형(Boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double), 계산을 위한 실제 값을 저장한다. 모두 8개참조형👉 객체의 주소를 저장한다. 8개의 기본형을 제외한 나머지 타입기본형(primitive type) boolean은 true, false 두가지 값으로 표현, 가장 작은 크기인 1byte char는 자바에서 유니코드르 사용하므로 2byte byte는 1byte int는 4byte, short는 2byte, long은 8byte float는 4byte, double은 8byte👉 문자형인 char는 문자를 내부적으로 정수(유니코드)로 저장하기 때문에 정수형과 별반 다르지 안으며, 정수형, 실수형과 연산이 가능하다. but, boolean은 연산 불가 boolean을 제외한 나머지 7개의 기본형은 서로 연산과 변환이 가능하다.상수와 리터럴상수는 값을 저장할 수 있는 공간이지만, 변수와 달리 한번 값을 저장하면 다른 값으로 변경할 수 없다.리터럴은 상수의 다른 이름으로 그 자체로 값을 의미한다.👉 final int MAX_SPEED = 100; //MAX_SPEED는 변수, 100은 리터럴상수는 반드시 선언과 동시에 초기화 하며 그 후 부터는 상수의 값을 변경하는 것이 허용되지 않는다. 상수를 사용하는 이유는 여러 곳을 수정할 필요없이 상수의 초기화만으로 다른 값으로 변경해주면 된다.형변환형변환이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것👉 (타입) 피연산자()는 캐스트 연산자, 형변환을 casting이라 한다.자동 형변환기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다. boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다. 기본형과 참조형은 서로 형변환할 수 없다. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[자바의 정석] 자바를 시작하기 전에", "url": "/posts/Java1/", "categories": "java", "tags": "java", "date": "2023-01-04 00:00:00 +0800", "snippet": "자바란?자바는 객체지향 프로그래밍 언어로, 자바의 가장 중요한 특징 중 하나로 운영체제에 독립된 언어로 프로그램을 작성할 수 있다는 것이다.JVM(Java Vitrtual Machine)자바를 실행하기 위한 가상 기계로, 자바로 작성된 어플리케이션은 모두 이 가상 컴퓨터(JVM)에서만 실행되기 때문에 자바 어플리케이션이 실행되기 위해서는 반드시 JVM...", "content": "자바란?자바는 객체지향 프로그래밍 언어로, 자바의 가장 중요한 특징 중 하나로 운영체제에 독립된 언어로 프로그램을 작성할 수 있다는 것이다.JVM(Java Vitrtual Machine)자바를 실행하기 위한 가상 기계로, 자바로 작성된 어플리케이션은 모두 이 가상 컴퓨터(JVM)에서만 실행되기 때문에 자바 어플리케이션이 실행되기 위해서는 반드시 JVM이 필요하다.자바 어플리케이션과 일반 어플리케이션 구조일반 어플리케이션은 OS와 바로 맞붙어 있기 때문에 OS종속적이다. 그래서 다른 OS에서 실행시키기 위해서는 애플리케이션을 해당 OS에 맞게 변경해야한다. 반면에 Java 애플리케이션은 JVM하고만 상호작용을 하기 때문에 OS와 하드웨어에 독립적이라 다른 OS에서도 프로그램의 변경없이 실행이 가능한 것이다.컴파일 과정자바컴파일러(javac.exe)를 사용해서 소스파일(Hello.java)로부터 클래스파일(Hello.class)을 생성해야한다. 그 다음 자바 인터프리터(java.exe)로 실행한다.👉 [Hello.java](http://Hello.java) 작성 → javac.exe를 사용해 Hello.java 컴파일 → Hello.class 생성 → java.exe로 실행 소스파일(.java)과 달리 클래스파일(.class)은 클래스마다 하나씩 만들어진다.java Hello의 내부적인 순서 프로그램의 실행에 필요한 클래스(.class)를 로드한다. 클래스파일을 검사한다. 지정된 클래스(Hello)에서 main을 호출한다. main메서드는 Java애플리케이션의 시작점이므로 main메서드 없이는 Java어플리케이션은 실행될 수 없다. 따라서 하나의 Java어플리케이션에는 main메서드를 포함한 클래스가 반드시 하나는 있어야 한다.📖 references Java의 정석(3판) [남궁 성/도우출판/2016]" }, { "title": "[Spring] 빈 스코프", "url": "/posts/Spring_Bean_Scope/", "categories": "Spring", "tags": "java, Spring", "date": "2023-01-03 00:00:00 +0800", "snippet": "빈 스코프란?빈이 존재할 수 있는 범위를 뜻한다.스프링은 다음과 같은 다양한 스코프를 지원한다. 싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다. 프로토타입: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는매우 짧은 범위의 스코프이다. 웹 관련 스코프 ...", "content": "빈 스코프란?빈이 존재할 수 있는 범위를 뜻한다.스프링은 다음과 같은 다양한 스코프를 지원한다. 싱글톤: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다. 프로토타입: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는매우 짧은 범위의 스코프이다. 웹 관련 스코프 request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프이다. session: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프이다. application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프이다. 프로토타입 스코프싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환한다.반면에 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다.싱글톤 빈 요청 싱글톤 스코프의 빈을 스프링 컨테이너에 요청한다. 스프링 컨테이너는 본인이 관리하는 스프링 빈을 반환한다. 이후에 스프링 컨테이너에 같은 요청이 와도 같은 객체 인스턴스의 스프링 빈을 반환한다. 프로토타입 빈 요청1 프로토타입 스코프의 빈을 스프링 컨테이너에 요청한다. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다. 프로토타입 빈 요청2 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환한다. 이후에 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환한다. 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다. 클라이언트에 빈을 반환하고, 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않는다. 프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있다. 그래서 @PreDestroy 같은 종료 메서드가 호출되지 않는다.public class PrototypeTest { @Test public void prototypeBeanFind() { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(PrototypeBean.class); System.out.println(\"PrototypeTest.prototypeBeanFind1\"); PrototypeBean bean1 = ac.getBean(PrototypeBean.class); System.out.println(\"PrototypeTest.prototypeBeanFind2\"); PrototypeBean bean2 = ac.getBean(PrototypeBean.class); System.out.println(\"bean1 = \" + bean1); System.out.println(\"bean2 = \" + bean2); Assertions.assertThat(bean1).isNotSameAs(bean2); ac.close(); } @Scope(\"prototype\") static class PrototypeBean { @PostConstruct public void init() { System.out.println(\"PrototypeBean.init\"); } @PreDestroy public void destroy() { System.out.println(\"PrototypeBean.destroy\"); } }} 스프링 컨테이너에 요청할 때 마다 새로 생성된다. 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다. 종료 메서드가 호출되지 않는다. 그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다. 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점clientBean이라는 싱글톤 빈이 의존관계 주입을 통해서 프로토타입 빈을 주입받아서 사용하는 예를 보자.싱글톤에서 프로토타입 빈 사용1 clientBean 은 싱글톤이므로, 보통 스프링 컨테이너 생성 시점에 함께 생성되고, 의존관계 주입도발생한다. clientBean 은 의존관계 자동 주입을 사용한다. 주입 시점에 스프링 컨테이너에 프로토타입 빈을요청한다. 스프링 컨테이너는 프로토타입 빈을 생성해서 clientBean 에 반환한다. 프로토타입 빈의 count 필드값은 0이다. 이제 clientBean 은 프로토타입 빈을 내부 필드에 보관한다. (정확히는 참조값을 보관한다.)싱글톤에서 프로토타입 빈 사용2 클라이언트 A는 clientBean 을 스프링 컨테이너에 요청해서 받는다.싱글톤이므로 항상 같은clientBean 이 반환된다. 클라이언트 A는 clientBean.logic() 을 호출한다. clientBean 은 prototypeBean의 addCount() 를 호출해서 프로토타입 빈의 count를 증가한다.count값이 1이 된다.싱글토에서 프로토타입 빈 사용3 클라이언트 B는 clientBean 을 스프링 컨테이너에 요청해서 받는다.싱글톤이므로 항상 같은 clientBean 이 반환된다. 여기서 중요한 점이 있는데, clientBean이 내부에 가지고 있는 프로토타입 빈은 이미 과거에 주입이 끝난빈이다. 주입 시점에 스프링 컨테이너에 요청해서 프로토타입 빈이 새로 생성이 된 것이지, 사용 할 때마다새로 생성되는 것이 아니다! 클라이언트 B는 clientBean.logic() 을 호출한다. clientBean 은 prototypeBean의 addCount() 를 호출해서 프로토타입 빈의 count를 증가한다.원래 count 값이 1이었으므로 2가 된다.Testpublic class SingletonWithPrototypeTest1 { @Test void prototypeFind() { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(PrototypeBean.class); PrototypeBean bean1 = ac.getBean(PrototypeBean.class); bean1.addCount(); Assertions.assertThat(bean1.count).isEqualTo(1); PrototypeBean bean2 = ac.getBean(PrototypeBean.class); bean2.addCount(); Assertions.assertThat(bean2.count).isEqualTo(1); } @Test void singletonClientUsePrototype() { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(ClientBean.class, PrototypeBean.class); ClientBean bean1 = ac.getBean(ClientBean.class); int logic1 = bean1.logic(); Assertions.assertThat(logic1).isEqualTo(1); ClientBean bean2 = ac.getBean(ClientBean.class); int logic2 = bean2.logic(); Assertions.assertThat(logic2).isEqualTo(1); } @Scope(\"singleton\") static class ClientBean { private final PrototypeBean prototypeBean; //생성 시점에 주입 beacause 생성주입이기 때문에 @Autowired ClientBean(PrototypeBean prototypeBean) { this.prototypeBean = prototypeBean; } public int logic() { //PrototypeBean prototypeBean = prototypeBeanProvider.getObject(); PrototypeBean prototypeBean = prototypeBeanProvider.get(); prototypeBean.addCount(); int count = prototypeBean.getCount(); return count; } } @Scope(\"prototype\") static class PrototypeBean { private int count = 0; public void addCount() { count++; } public int getCount() { return count; } @PostConstruct public void init() { System.out.println(\"PrototypeBean.init\" + this); } @PreDestroy public void destroy() { System.out.println(\"PrototypeBean.destroy\"); } }}스프링은 일반적으로 싱글톤 빈을 사용하므로, 싱글톤 빈이 프로토타입 빈을 사용하게 된다. 그런데 싱글톤 빈은 생성 시점에만 의존관계 주입을 받기 때문에, 프로토타입 빈이 새로 생성되기는 하지만, 싱글톤 빈과 함께 계속 유지되는 것이 문제다.프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결ObjectFactory, ObjectProvider지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공하는 것이 바로 ObjectProvider 이다. 참고로 과거에는 ObjectFactory가 있었는데, 여기에 편의 기능을 추가해서 ObjectProvider가 만들어졌다.@Autowiredprivate ObjectProvider&lt;PrototypeBean&gt; prototypeBeanProvider;public int logic() { PrototypeBean prototypeBean = prototypeBeanProvider.getObject(); prototypeBean.addCount(); int count = prototypeBean.getCount(); return count;} 실행해보면 prototypeBeanProvider.getObject() 을 통해서 항상 새로운 프로토타입 빈이 생성되는것을 확인할 수 있다. ObjectProvider 의 getObject() 를 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서반환한다. (DL) 스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는훨씬 쉬워진다. ObjectProvider 는 지금 딱 필요한 DL 정도의 기능만 제공한다.👉 `ObjectProvider , JSR330 Provider` 등은 프로토타입 뿐만 아니라 DL이 필요한 경우는 언제든지 사용할 수 있다.웹 스코프웹 스코프는 웹 환경에서만 동작하는 스코프이다. 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서 종료 메서드가 호출된다.웹스코프 종류 request : HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈인스턴스가 생성되고, 관리된다. session : HTTP Session과 동일한 생명주기를 가지는 스코프 application : HTTP Session과 동일한 생명주기를 가지는 스코프 websocket : 웹 소켓과 동일한 생명주기를 가지는 스코프HTTP request 요청 당 각각 할당되는 request 스코프request 스코프 예제로그가 남도록 request 스코프를 활용해서 추가 기능을 개발하는 예를 들어 보자.로그를 출력하기 위한 MyLogger 클래스@Component@Scope(value = \"request\")public class MyLogger { private String uuid; private String requestURL; public void setRequestURL(String requestURL) { this.requestURL = requestURL; } public void log(String message) { System.out.println(\"[\" + uuid + \"]\" + \"[\" + requestURL + \"] \" + message); } @PostConstruct public void init() { uuid = UUID.randomUUID().toString(); System.out.println(\"[\" + uuid + \"]\" + \"request scope bean create : \" + this); } @PreDestroy public void close() { System.out.println(\"[\" + uuid + \"]\" + \"request scope bean close : \" + this); }} @Scope(value = \"request\")를 사용해서 request 스코프로 지정했다. 이제 이 빈은 HTTP 요청 당 하나씩 생성되고, HTTP 요청이 끝나는 시점에 소멸된다. 이 빈이 생성되는 시점에 자동으로 @PostConstruct 초기화 메서드를 사용해서 uuid를 생성해서저장해둔다. 이 빈은 HTTP 요청 당 하나씩 생성되므로, uuid를 저장해두면 다른 HTTP 요청과 구분할 수있다. 이 빈이 소멸되는 시점에 @PreDestroy 를 사용해서 종료 메시지를 남긴다.LogDemoController@Controller@RequiredArgsConstructorpublic class LogDemoController { private final LogDemoService logDemoService; private final MyLogger myLogger; @RequestMapping(\"log-demo\") @ResponseBody public String logDemo(HttpServletRequest request) { String requestURL = request.getRequestURL().toString(); myLogger.setRequestURL(requestURL); myLogger.log(\"controller test\"); Thread.sleep(100); logDemoService.logic(\"testId\"); return \"OK\"; }} Logger가 잘 작동하는지 확인하는 테스트용 컨트롤러다. 여기서 HttpServletRequest를 통해서 요청 URL을 받았다. requestURL 값 http://localhost:8080/log-demo 이렇게 받은 requestURL 값을 myLogger에 저장해둔다. myLogger는 HTTP 요청 당 각각 구분되므로다른 HTTP 요청 때문에 값이 섞이는 걱정은 하지 않아도 된다.LogDemoService@Service@RequiredArgsConstructorpublic class LogDemoService { private final MyLogger myLogger; public void logic(String id) { myLogger.log(\"service id=\" + id); }}위와 같은 코드로 실행시키면 다음과 같은 오류가 발생한다.Error creating bean with name ‘myLogger’: Scope ‘request’ is not active for the current thread; consider defining a scoped proxy for this bean if you intend to refer to it from a singleton; 스프링 애플리케이션을 실행하는 시점에 싱글톤 빈은 생성해서 주입이 가능하지만, request 스코프 빈은 아직 생성되지 않는다. 이 빈은 실제 고객의 요청이 와야 생성할 수 있다!스코프와 Provider첫번째 해결방안은 앞서 배운 Provider를 사용하는 것이다.LogDemoController@Controller@RequiredArgsConstructorpublic class LogDemoController { private final LogDemoService logDemoService; private final ObjectProvider&lt;MyLogger&gt; myLoggerProvider; @RequestMapping(\"log-demo\") @ResponseBody public String logDemo(HttpServletRequest request){ String requestURL = request.getRequestURL().toString(); MyLogger myLogger = myLoggerProvider.getObject(); myLogger.setRequestURL(requestURL); myLogger.log(\"controller test\"); Thread.sleep(100); logDemoService.logic(\"testId\"); return \"OK\"; }}LogDemoService@Service@RequiredArgsConstructorpublic class LogDemoService { private final ObjectProvider&lt;MyLogger&gt; myLoggerProvider; public void logic(String id) { MyLogger myLogger = myLoggerProvider.getObject(); myLogger.log(\"service id=\" + id); }} ObjectProvider을 이용해서 ObjectProvider.getObject()를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있다. ObjectProvider.getObject()를 호출하시는 시점에는 HTTP 요청이 진행중이므로 request scope 빈의 생성이 정상 처리된다. ObjectProvider.getObject()를 LogDemoController , LogDemoService 에서 각각 한번씩 따로 호출해도 같은 HTTP 요청이면 같은 스프링 빈이 반환된다스코프와 프록시MyLogger 클래스에 proxyMode = ScopedProxyMode.TARGET_CLASS 를 추가해주자.@Component @Scope(value = \"request\", proxyMode = ScopedProxyMode.TARGET_CLASS) public class MyLogger { }이렇게 하면 MyLogger의 가짜 프록시 클래스를 만들어두고 HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있다.이후 나머지 코드들을 Provider 사용 전으로 돌려놓으면 된다.LogDemoController@Controller@RequiredArgsConstructorpublic class LogDemoController { private final LogDemoService logDemoService; private final MyLogger myLogger; @RequestMapping(\"log-demo\") @ResponseBody public String logDemo(HttpServletRequest request) { String requestURL = request.getRequestURL().toString(); myLogger.setRequestURL(requestURL); myLogger.log(\"controller test\"); Thread.sleep(100); logDemoService.logic(\"testId\"); return \"OK\"; }}LogDemoService@Service@RequiredArgsConstructorpublic class LogDemoService { private final ObjectProvider&lt;MyLogger&gt; myLoggerProvider; public void logic(String id) { MyLogger myLogger = myLoggerProvider.getObject(); myLogger.log(\"service id=\" + id); }}실행되면 잘 동작한다.웹 스코프와 프록시 동작 원리@Scope 의 proxyMode = ScopedProxyMode.TARGET_CLASS) 를 설정하면 스프링 컨테이너는 CGLI라는 바이트코드를 조작하는 라이브러리를 사용해서, MyLogger를 상속받은 가짜 프록시 객체를생성한다 결과를 확인해보면 우리가 등록한 순수한 MyLogger 클래스가 아니라 MyLogger$$EnhancerBySpringCGLIB 이라는 클래스로 만들어진 객체가 대신 등록된 것을 확인할 수 있다.프록시 동작 원리가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있다. 가짜 프록시 객체는 내부에 진짜 myLogger를 찾는 방법을 알고 있다. 클라이언트가 myLogger.logic() 을 호출하면 사실은 가짜 프록시 객체의 메서드를 호출한 것이다. 가짜 프록시 객체는 request 스코프의 진짜 myLogger.logic() 를 호출한다. 가짜 프록시 객체는 원본 클래스를 상속 받아서 만들어졌기 때문에 이 객체를 사용하는 클라이언트입장에서는 사실 원본인지 아닌지도 모르게, 동일하게 사용할 수 있다(다형성)👉 Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점이다.📖 references 스프링 핵심원리 -기본편 by 김영한" }, { "title": "[Spring] 빈 생명주기 콜백", "url": "/posts/Spring_BeanLifecycle/", "categories": "Spring", "tags": "java, Spring", "date": "2023-01-02 00:00:00 +0800", "snippet": "빈 생명주기 콜백스프링 빈은 간단하게 다음과 같은 라이프사이클을 가진다. 객체 생성 → 의존관계 주입 스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가완료된다. 따라서 초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 한다. 그런데 개발자가 의존관계 주입이 모두 완료된 시점을 어...", "content": "빈 생명주기 콜백스프링 빈은 간단하게 다음과 같은 라이프사이클을 가진다. 객체 생성 → 의존관계 주입 스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가완료된다. 따라서 초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 한다. 그런데 개발자가 의존관계 주입이 모두 완료된 시점을 어떻게 알 수 있을까? 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공한다. 또한 스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다. 따라서 안전하게 종료 작업을 진행할 수 있다.스프링 빈의 이벤트 라이프사이클👉 **스프링컨테이너생성 → 스프링빈생성 → 의존관계주입 → 초기화콜백 → 사용 → 소멸전콜백 → 스프링 종료**스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원한다. 인터페이스(InitializingBean, DisposableBean) 설정 정보에 초기화 메서드, 종료 메서드 지정 @PostConstruct, @PreDestroy 애노테이션 지원인터페이스 InitializingBean, DisposableBeanpublic class NetworkClient implements InitializingBean, DisposableBean{ private String url; public NetworkClient() { System.out.println(\"url = \" + url); } public void setUrl(String url) { this.url = url; } //서비스 시작시 호출 public void connect() { System.out.println(\"connect : \" + url); } public void call(String message) { System.out.println(\"call : \" + url + \"message = \" + message); } //서비스 종료시 호출 public void disconnect() { System.out.println(\"close : \" + url); }\t\t@Override public void afterPropertiesSet() throws Exception { //의존관계 주입이 끝나면 호출 connect(); call(\"초기화 연결 메세지\"); }\t @Override public void destroy() throws Exception { disconnect(); } InitializingBean 은 afterPropertiesSet() 메서드로 초기화를 지원한다. DisposableBean 은 destroy()메서드로 소멸을 지원한다. 인터페이스를 사용하는 초기화, 종료 방법은 스프링 초창기에 나온 방법들이고, 지금은 다음의 더 나은 방법들이 있어서 거의 사용하지 않는다.빈 등록 초기화, 소멸 메서드 지정설정 정보에 @Bean(initMethod = \"init\", destroyMethod = \"close\") 처럼 초기화, 소멸 메서드를지정할 수 있다.public class NetworkClient { private String url; public NetworkClient() { System.out.println(\"url = \" + url); } public void setUrl(String url) { this.url = url; } //서비스 시작시 호출 public void connect() { System.out.println(\"connect : \" + url); } public void call(String message) { System.out.println(\"call : \" + url + \"message = \" + message); } //서비스 종료시 호출 public void disconnect() { System.out.println(\"close : \" + url); } public void init() { //의존관계 주입이 끝나면 호출 connect(); call(\"초기화 연결 메세지\"); } public void close() { disconnect(); }}@Configurationstatic class LifeCycleConfig { @Bean(initMethod = \"init\", destroyMethod = \"close\") public NetworkClient networkClient() { NetworkClient networkClient = new NetworkClient(); networkClient.setUrl(\"http://hello-spring.dev\"); return networkClient; }} 메서드 이름을 자유롭게 줄 수 있다. 스프링 빈이 스프링 코드에 의존하지 않는다. 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료메서드를 적용할 수 있다.애노테이션 @PostConstruct, @PreDestroypublic class NetworkClient { private String url; public NetworkClient() { System.out.println(\"url = \" + url); } public void setUrl(String url) { this.url = url; } //서비스 시작시 호출 public void connect() { System.out.println(\"connect : \" + url); } public void call(String message) { System.out.println(\"call : \" + url + \"message = \" + message); } //서비스 종료시 호출 public void disconnect() { System.out.println(\"close : \" + url); } @PostConstruct public void init() { //의존관계 주입이 끝나면 호출 connect(); call(\"초기화 연결 메세지\"); } @PreDestroy public void close() { disconnect(); }}@Configurationstatic class LifeCycleConfig { @Bean public NetworkClient networkClient() { NetworkClient networkClient = new NetworkClient(); networkClient.setUrl(\"http://hello-spring.dev\"); return networkClient; }} 최신 스프링에서 가장 권장하는 방법이다. 애노테이션 하나만 붙이면 되므로 매우 편리하다. 패키지를 잘 보면 javax.annotation.PostConstruct이다. 스프링에 종속적인 기술이 아니라 JSR-250라는 자바 표준이다. 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다. 컴포넌트 스캔과 잘 어울린다. 유일한 단점은 외부 라이브러리에는 적용하지 못한다는 것이다. 외부 라이브러리를 초기화, 종료 해야 하면@Bean의 기능을 사용하자.👉 `@PostConstruct, @PreDestroy` 애노테이션을 사용하자**코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 `@Bean` 의 initMethod , destroyMethod를 사용하자.📖 references 스프링 핵심원리 -기본편 by 김영한" }, { "title": "[Spring] 의존관계 자동주입", "url": "/posts/dependency_Autowired/", "categories": "Spring", "tags": "java, Spring", "date": "2023-01-01 00:00:00 +0800", "snippet": "다양한 의존관계 주입 방법 생성자 주입 수정자 주입(setter 주입) 필드 주입 일반 메서드 주입(잘 사용 X)생성자 주입@Componentpublic class OrderServcieImpl implements OrderService { private final MemberRepository memberRepository; pri...", "content": "다양한 의존관계 주입 방법 생성자 주입 수정자 주입(setter 주입) 필드 주입 일반 메서드 주입(잘 사용 X)생성자 주입@Componentpublic class OrderServcieImpl implements OrderService { private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy; @Autowired public OrderServcieImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; }} 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입 된다. 물론 스프링 빈에만 해당한다.수정자 주입(setter 주입) setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법@Component public class OrderServiceImpl implements OrderService { private MemberRepository memberRepository; private DiscountPolicy discountPolicy;\t\t\t@Autowired public void setMemberRepository(MemberRepository memberRepository) { this.memberRepository = memberRepository; } @Autowired public void setDiscountPolicy(DiscountPolicy discountPolicy) { this.discountPolicy = discountPolicy; }} 선택, 변경 가능성이 있는 의존관계에 사용된다.👉 • `@Autowired` 의 기본 동작은 주입할 대상이 없으면 오류가 발생한다. 주입할 대상이 없어도 동작하게하려면 `@Autowired(required = false)`로 지정하면 된다.필드 주입@Component public class OrderServiceImpl implements OrderService { @Autowired private MemberRepository memberRepository; @Autowired private DiscountPolicy discountPolicy;} 코드가 간결해서 많은 개발자들을 유혹하지만 외부에서 변경이 불가능해서 테스트 하기 힘들다는치명적인 단점이 있다. DI 프레임워크가 없으면 아무것도 할 수 없다. 사용하지 말것!옵션 처리 주입할 스프링 빈이 없어도 동작해야 할 때가 있다. 그런데 @Autowired 만 사용하면 required 옵션의 기본값이 true 로 되어 있어서 자동 주입 대상이없으면 오류가 발생한다.public class AutoWiredTest { @Test void AutoWiredOption() { ApplicationContext ac = new AnnotationConfigApplicationContext(TestBean.class); } static class TestBean { @Autowired(required = false) public void setNoBean1(Member noBean1) { System.out.println(\"noBean1 = \" + noBean1); } @Autowired public void setNoBean2(@Nullable Member noBean2) { System.out.println(\"noBean2 = \" + noBean2); } @Autowired public void setNoBean3(Optional&lt;Member&gt; noBean3) { System.out.println(\"noBean3 = \" + noBean3); } }} @Autowired(required=false) : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨 org.springframework.lang.@Nullable : 자동 주입할 대상이 없으면 null이 입력된다. Optional&lt;&gt; : 자동 주입할 대상이 없으면 Optional.empty 가 입력된다.👉 다양한 의존관계 주입 방법이 있지만, 생성자 주입 방법을 선택해야함! 생성자 주입 방식을 선택하는 이유는 여러가지가 있지만, 프레임워크에 의존하지 않고, 순수한 자바 언어의특징을 잘 살리는 방법이기도 하다. 기본으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 된다.생성자 주입과 수정자 주입을 동시에 사용할 수 있다. 항상 생성자 주입을 선택해라! 그리고 가끔 옵션이 필요하면 수정자 주입을 선택해라. 필드 주입은 사용하지않는게 좋다.조회 빈이 2개 이상 - 문제@Autowired는 타입(Type)으로 조회한다.@Autowiredprivate DiscountPolicy discountPolicy타입으로 조회하기 때문에, 마치 ac.getBean(DiscountPolicy.class)와 유사하게 동작한다. (실제로는 더 많은 기능을 제공한다.)근데 만약 타입으로 조회했을 시 선택된 빈이 2개 이상일 때 문제가 발생한다. 이 문제를 의존관계 자동 주입으로 해결할 수 있는 방법 3가지가 있다. @Autowired 필드명 @Qualifier @Primary**@Autowired 필드 명 매칭 @Autowired 는 타입 매칭을 시도하고, 이때 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.기존코드@Autowiredprivate DiscountPolicy discountPolicy필드 명을 빈 이름으로 변경@Autowiredprivate DiscountPolicy rateDiscountPolicy@AutoWired는 타입을 먼저 매칭하고, 타입 매칭의 결과가 2개 이상일 때 필드 명, 파라미터 명으로 빈 이름 매칭@Qualifier 사용 @Qualifier는 추가 구분자를 붙여주는 방법이다. 주입시 추가적인 방법을 제공하는 것이지 빈 이름을 변경하는 것은 아니다.빈 등록시 @Qualifier를 붙여 준다.@Component@Qualifier(\"mainDiscountPolicy\")public class RateDiscountPolicy implements DiscountPolicy {}주입시에 @Qualifier를 붙여주고 등록한 이름을 적어준다.@Autowired public OrderServiceImpl(MemberRepository memberRepository, @Qualifier(\"mainDiscountPolicy\") DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy;}@Primary 사용 @Primary 는 우선순위를 정하는 방법이다. @Autowired 시에 여러 빈이 매칭되면 @Primary가 우선권을 가진다.RateDiscountPolicy가 우선권을 가진 코드@Component@Primarypublic class RateDiscountPolicy implements DiscountPolicy {}@Componentpublic class FixDiscountPolicy implements DiscountPolicy {} @Primary, @Qualifier활용코드에서 자주 사용하는 메인 데이터베이스의 커넥션을 획득하는 스프링 빈이 있고, 코드에서 특별한 기능으로 가끔 사용하는 서브 데이터베이스의 커넥션을 획득하는 스프링 빈이 있다고 생각해보자. 메인 데이터베이스의 커넥션을 획득하는 스프링 빈은 @Primary 를 적용해서 조회하는 곳에서 @Qualifier지정 없이 편리하게 조회하고, 서브 데이터베이스 커넥션 빈을 획득할 때@Qualifier를 지정해서 명시적으로 획득 하는 방식으로 사용하면 코드를 깔끔하게 유지할 수 있다. 물론 이때 메인 데이터베이스의 스프링 빈을 등록할 때 @Qualifier를 지정해주는 것은 상관없다.조회한 빈이 모두 필요할 때, List, Map예를 들어서 할인 서비스를 제공하는데, 클라이언트가 할인의 종류(rate, fix)를 선택할 수 있다고 가정해보자. 스프링을 사용하면 소위 말하는 전략 패턴을 매우 간단하게 구현할 수 있다.public class AllBeanTest { @Test void findAllBean() { ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class, DiscountService.class); DiscountService discountService = ac.getBean(DiscountService.class); Member member = new Member(1L, \"userA\", Grade.VIP); int discountPrice = discountService.discount(member, 10000, \"fixDiscountPolicy\"); assertThat(discountService).isInstanceOf(DiscountService.class); assertThat(discountPrice).isEqualTo(1000); int rateDiscountPrice = discountService.discount(member, 20000, \"rateDiscountPolicy\"); assertThat(rateDiscountPrice).isEqualTo(2000); } static class DiscountService { private final Map&lt;String, DiscountPolicy&gt; policyMap; private final List&lt;DiscountPolicy&gt; policies; @Autowired public DiscountService(Map&lt;String, DiscountPolicy&gt; policyMap, List&lt;DiscountPolicy&gt; policies) { this.policyMap = policyMap; this.policies = policies; System.out.println(\"policyMap = \" + policyMap); System.out.println(\"policies = \" + policies); } public int discount(Member member, int price, String discountCode) { DiscountPolicy discountPolicy = policyMap.get(discountCode); return discountPolicy.discount(member, price); } }} Map&lt;String, DiscountPolicy&gt; : map의 키에 스프링 빈의 이름을 넣어주고, 그 값으로 DiscountPolicy 타입으로 조회한 모든 스프링 빈을 담아준다. List : DiscountPolicy 타입으로 조회한 모든 스프링 빈을 담아준다. 만약 해당하는 타입의 스프링 빈이 없으면, 빈 컬렉션이나 Map을 주입한다.👉 애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 딱! 설정 정보에 바로나타나게 하는 것이 유지보수 하기 좋다.📖 references 스프링 핵심원리 -기본편 by 김영한" }, { "title": "[Spring] 컴포넌트 스캔", "url": "/posts/Spring_ComponentScan/", "categories": "Spring", "tags": "java, Spring", "date": "2022-12-31 00:00:00 +0800", "snippet": "컴포넌트 스캔과 의존관계 자동 주입 시작하기 스프링 빈을 @Bean을 사용하여 스프링 컨테이너에 등록했지만, 만약 등록해야 할 빈이 수백개가 넘는다면 설정 정보도 커지고, 누락하는 문제도 발생할 수 있다. 이 때문에 스프링은 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다. 또 의존관계도 자동으로 주입하는 @Autowired 라...", "content": "컴포넌트 스캔과 의존관계 자동 주입 시작하기 스프링 빈을 @Bean을 사용하여 스프링 컨테이너에 등록했지만, 만약 등록해야 할 빈이 수백개가 넘는다면 설정 정보도 커지고, 누락하는 문제도 발생할 수 있다. 이 때문에 스프링은 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다. 또 의존관계도 자동으로 주입하는 @Autowired 라는 기능도 제공한다.AutoAppConfig@Configuration@ComponentScan( excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = Configuration.class))public class AutoAppConfig {} 컴포넌트 스캔을 사용하려면 먼저 @ComponentScan 을 설정 정보에 붙여주면 된다. 기존의 AppConfig와는 다르게 @Bean으로 등록한 클래스가 하나도 없다!👉 컴포넌트 스캔을 사용하면 `@Configuration` 이 붙은 설정 정보도 자동으로 등록되기 때문에, AppConfig, TestConfig 등 앞서 만들어두었던 설정 정보도 함께 등록되고, 실행되어 버린다. 그래서 excludeFilters 를 이용해서 설정정보는 컴포넌트 스캔 대상에서 제외했다.컴포넌트 스캔은 이름 그대로 @Component 어노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록한다.@Componentpublic class MemoryMemberRepository implements MemberRepository {}@Componentpublic class RateDiscountPolicy implements DiscountPolicy {}@Componentpublic class MemberServiceImpl implements MemberService { private final MemberRepository memberRepository; @Autowired public MemberServiceImpl(MemberRepository memberRepository) { this.memberRepository = memberRepository; }}AutoAppConfig Testpublic class AutoAppConfigTest { @Test void basicScan() { ApplicationContext ac = new AnnotationConfigApplicationContext(AutoAppConfig.class); MemberService bean = ac.getBean(MemberService.class); assertThat(bean).isInstanceOf(MemberService.class); }}컴포넌트 스캔과 자동 주입 동작원리 컴포넌트 스캔 @ComponentScan 은 @Component 가 붙은 모든 클래스를 스프링 빈으로 등록한다. 이때 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다. 빈 이름 기본 전략: MemberServiceImpl 클래스 memberServiceImpl 빈 이름 직접 지정: 만약 스프링 빈의 이름을 직접 지정하고 싶으 @Component(\"memberService2\") 이런식으로 이름을 부여하면 된다. **@AutoWired 의존관계 자동 주입** 생성자에 @Autowired 를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다. getBean(MemberRepository.class)를 이용해서 한다고 생각하면 된다.탐색 위치와 기본 스캔 대상탐색할 패키지의 시작 위치 지정@ComponentScan( basePackages = \"hello.core\",} basePackages : 탐색할 패키지의 시작 위치를 지정한다. 이 패키지를 포함해서 하위 패키지를 모두 탐색한다. basePackages = {“hello.core”, “hello.service”} 이렇게 여러 시작 위치를 지정할 수도 있다. basePackageClasses : 지정한 클래스의 패키지를 탐색 시작 위치로 지정한다. 만약 지정하지 않으면 @ComponentScan 이 붙은 설정 정보 클래스의 패키지가 시작 위치가 된다.컴포넌트 스캔 기본 대상 컴포넌트 스캔은 @Component 뿐만 아니라 다음과 내용도 추가로 대상에 포함한다. @Component : 컴포넌트 스캔에서 사용 @Controlller : 스프링 MVC 컨트롤러에서 사용 @Service : 스프링 비즈니스 로직에서 사용 @Repository : 스프링 데이터 접근 계층에서 사용 @Configuration : 스프링 설정 정보에서 사용 필터 includeFilters : 컴포넌트 스캔 대상을 추가로 지정한다. excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정한다.중복 등록과 충돌컴포넌트 스캔에서 만약 빈의 이름이 같으면 어떻게 될까?case1) 자동 빈 등록 vs 자동 빈 등록컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 그 이름이 같은 경우 스프링은 오류를 발생시킨다. ConflictingBeanDefinitionException 예외 발생case2) 수동 빈 등록 vs 자동 빈 등록 이 경우 수동 빈 등록이 우선권을 가진다. 그러나 최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본 값을 바꾸었다.📖 references 스프링 핵심원리 -기본편 by 김영한" }, { "title": "[Spring] 싱글톤 컨테이너", "url": "/posts/Spring_SingletonContainer/", "categories": "Spring", "tags": "java, Spring", "date": "2022-12-30 00:00:00 +0800", "snippet": "웹 애플리케이션과 싱글톤웹 어플리케이션 구조에서 고객은 보통 동시에 요청이 온다. 순수한 DI 컨테이너는 요청이 올때마다 객체를 새로 생성해서 반환해주게 된다.스프링없는 순수한 DI컨테이너 테스트public class SingletonTest { @Test @DisplayName(\"스프링 없는 순수한 DI 컨테이너\") void pur...", "content": "웹 애플리케이션과 싱글톤웹 어플리케이션 구조에서 고객은 보통 동시에 요청이 온다. 순수한 DI 컨테이너는 요청이 올때마다 객체를 새로 생성해서 반환해주게 된다.스프링없는 순수한 DI컨테이너 테스트public class SingletonTest { @Test @DisplayName(\"스프링 없는 순수한 DI 컨테이너\") void pureContainer() { AppConfig appconfig = new AppConfig(); MemberService memberService1 = appconfig.memberService(); MemberService memberService2 = appconfig.memberService(); System.out.println(\"memberServic1 = \" + memberService1); System.out.println(\"memberServic2 = \" + memberService2); assertThat(memberService1).isNotSameAs(memberService2); }} 스프링 없는 순수한 DI컨테이너는 요청이 올때마다 새로운 객체를 반환해서 만약 고객의 요청이 많을 경우 메모리낭비가 어마어마하게 많을 것이다. 이를 위해 해당 객체를 딱 1개만 생성하여 공유하도록 설계해야 한다.(싱글톤 패턴)싱글톤 패턴클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴public class SingletonService { private static final SingletonService instance = new SingletonService(); public static SingletonService getInstance() { return instance; } private SingletonService() {} public void logic() { System.out.println(\"싱글톤 객체 로직 호출\"); }} static 영엑에 객체 instance를 미리 하나 생성한다. 이 객체 인스턴스가 필요하면 오직 getInstance() 메서드를 통해서만 조회할 수 있다. 이 메서드를호출하면 항상 같은 인스턴스를 반환한다. 딱 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 private으로 막아서 혹시라도 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막는다.싱글톤 패턴을 사용하는 테스트 코드@Test@DisplayName(\"싱글톤 패턴을 적용한 객체 사용\")void singletonServiceTest() { SingletonService instance1 = SingletonService.getInstance(); SingletonService instance2 = SingletonService.getInstance(); System.out.println(\"instance1 = \" + instance1); System.out.println(\"instance2 = \" + instance2); assertThat(instance1).isSameAs(instance2);}But, 싱글톤 패턴은 다음과 같은 문제점들이 있다. 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다. 의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다. 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다. 테스트하기 어렵다. 내부 속성을 변경하거나 초기화 하기 어렵다. private 생성자로 자식 클래스를 만들기 어렵다. 결론적으로 유연성이 떨어진다. 안티패턴으로 불리기도 한다.싱글톤 컨테이너 스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다. 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤레지스트리라 한다. 스프링 컨테이너의 이런 기능 덕분에 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수있다. 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다. DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다. 스프링 컨테이너를 사용하는 테스트 코드@Test@DisplayName(\"스프링 컨테이너와 싱글톤\")void springContainer() { ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); MemberService memberService1 = ac.getBean(\"memberService\", MemberService.class); MemberService memberService2 = ac.getBean(\"memberService\", MemberService.class); System.out.println(\"memberService1 = \" + memberService1); System.out.println(\"memberService2 = \" + memberService2); assertThat(memberService1).isSameAs(memberService2);}스프링 컨테이너 적용 후 스프링 컨테이너 덕분에 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 재사용할 수 있다.싱글톤 방식의 주의점 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다. 무상태(stateless)로 설계해야 한다! 특정 클라이언트에 의존적인 필드가 있으면 안된다. 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다! 가급적 읽기만 가능해야 한다. 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다. 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다!!!상태를 유지할 경우 발생하는 문제점 예시public class StatefulService { private int price; public void order(String name, int price){ System.out.println(\"name = \" + name + \" price = \" + price); this.price = price; } public int getPrice() { return price; }}문제점 테스트public class SingletonServiceTest { ApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class); @Test void statefulServiceSingleton() { StatefulService bean1 = ac.getBean(StatefulService.class); StatefulService bean2 = ac.getBean(StatefulService.class); bean1.order(\"userA\", 10000); bean2.order(\"userB\", 20000); int price = bean1.getPrice(); System.out.println(\"price = \" + price); assertThat(price).isEqualTo(20000); } static class TestConfig { @Bean public StatefulService statefulService() { return new StatefulService(); } }} StatefulService 의 price 필드는 공유되는 필드인데, 특정 클라이언트가 값을 변경한다. 사용자A의 주문금액은 10000원이 되어야 하는데, 20000원이라는 결과가 나왔다. 진짜 공유필드는 조심해야 한다! 스프링 빈은 항상 무상태(stateless)로 설계하자. int price;를 지역변수에 두면 해결할 수 있다.@Configuration과 바이트코드 조작의 마법스프링 컨테이너는 스프링 빈이 싱글톤이 되도록 보장해주어야 한다. 그래서 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용한다.@Testvoid configurationDeep() {\t ApplicationContext ac = new\t AnnotationConfigApplicationContext(AppConfig.class);\t //AppConfig도 스프링 빈으로 등록된다.\t AppConfig bean = ac.getBean(AppConfig.class);\t System.out.println(\"bean = \" + bean.getClass());\t //출력: bean = class hello.core.AppConfig$$EnhancerBySpringCGLIB$$bd479d70}bean객체를 println으로 출력하게 되면 xxxCGLIB가 붙으면서 상당히 복잡하게 출력되는것을 볼 수 있다. 이것은 내가 만든 클래스가 아니라 스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고, 그 다른 클래스를 스프링 빈으로 등록한 것이다! 이렇게 바이트 코드를 조작하여 스프링 컨테이너는 싱글톤을 보장해준다.AppConfig@CGLIB 예상 코드@Bean public MemberRepository memberRepository() { if (memoryMemberRepository가 이미 스프링 컨테이너에 등록되어 있으면 ?){ return 스프링 컨테이너에서 찾아서 반환; } else{ //스프링 컨테이너에 없으면 기존 로직을 호출해서 MemoryMemberRepository를 생성하고 스프링 컨테이너에 등록 return 반환 } }@Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다. @Configuration 을 붙이면 바이트코드를 조작하는 CGLIB 기술을 사용해서 싱글톤을 보장한다. 만약 @Bean만 사용할 경우 스프링 빈으로는 등록되지만, 싱글톤을 보장해주지 않는다.📖 references 스프링 핵심원리 -기본편 by 김영한" }, { "title": "[Spring] 컨테이너와 빈", "url": "/posts/Spring-Container-Bean/", "categories": "Spring", "tags": "java, Spring", "date": "2022-12-29 00:00:00 +0800", "snippet": "스프링 컨테이너 생성ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);\t\t\t\t\t\t\t\t\tApplicationContext를 스프링 컨테이너라고 한다.스프링 컨테이너 생성 과정new AnnotationConfigApplicationCo...", "content": "스프링 컨테이너 생성ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class);\t\t\t\t\t\t\t\t\tApplicationContext를 스프링 컨테이너라고 한다.스프링 컨테이너 생성 과정new AnnotationConfigApplicationContext(AppConfig.class)을 이용해 컨테이너를 생성하고 \t\tAppConfig.class를 활용해서 빈 저장소를 구성한다.스프링 빈 등록설정 클래스 정보를 사용해서 스프링 빈을 등록한다.스프링 빈 의존관계 설정 - 준비스프링 빈 의존관계 설정 - 완료스프링 컨테이너는 빈을 등록한 후 빈끼리 의존관계를 주입해준다. 스프링은 빈을 생성하고, 의존관계를 주입하는 단계가 나누어져 있다. 그런데 이렇게 자바 코드로 스프링 빈을 등록하면 생성자를 호출하면서 의존관계 주입도 한번에 처리된다.빈 출력하기모든 빈 출력public class ApplicationContextInfoTest { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); @Test @DisplayName(\"모든 빈 출력하기\") void findAllBean() { String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) { Object bean = ac.getBean(beanDefinitionName); System.out.println(\"name = \" + beanDefinitionName + \" object = \"+ bean); } }}ac.getBeanDefinitionNames(): 스프링에 등록된 모든 빈 이름을 조회ac.getBean() : 빈 이름으로 빈 객체를 조회어플리케이션 빈 출력public class ApplicationContextInfoTest { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); @Test @DisplayName(\"어플리케이션 빈 출력하기\") void findApplicationBean() { String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) { BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName); if(beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION){ Object bean = ac.getBean(beanDefinitionName); System.out.println(\"name = \" + beanDefinitionName + \" object = \" + bean); } } }} 스프링 내부에서 사용하는 빈은 getRole()로 구분할 수 있다. ROLE_APPLICATION : 일반적으로 사용자가 정의한 빈 ROLE_INFRASTRUCTURE : 스프링이 내부에서 사용하는 빈 ac.getBeanDefinition(): Bean에 대한 meta data 정보들을 반환한다. 코드에서는 스프링이 내부에서 사용하는 빈을 getRole()로 구분하기 위해 사용함.스프링 빈 조회 - 기본public class ApplicationContextBasicFindTest { ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); @Test @DisplayName(\"빈 이름으로 조회\") void findBeanByName() { MemberService memberService = ac.getBean(\"memberService\", MemberService.class); assertThat(memberService).isInstanceOf(MemberServiceImpl.class); } @Test @DisplayName(\"이름 없이 타입으로만 조회\") void findBeanByType() { MemberService bean = ac.getBean(MemberService.class); assertThat(bean).isInstanceOf(MemberServiceImpl.class); } @Test @DisplayName(\"구체 타입으로 조회\") void findBeanBySpecificType() { MemberServiceImpl bean = ac.getBean(MemberServiceImpl.class); assertThat(bean).isInstanceOf(MemberServiceImpl.class); } @Test @DisplayName(\"빈 이름으로 조회했는데 없을 경우\") void findBeanByNameX() { Assertions.assertThrows(NoSuchBeanDefinitionException.class, () -&gt; ac.getBean(\"xxxxx\", MemberService.class)); }}ac.getBean(빈이름, 타입) , ac.getBean(타입)으로 조회스프링 빈 조회 - 동일한 타입이 2개 있을 때, 타입으로 조회했을 시 타입으로 조회시 같은 타입의 스프링 빈이 둘 이상이면 오류가 발생한다. 이때는 빈 이름을 지정하자.public class ApplicationContextSameBeanFindTest { ApplicationContext ac = new AnnotationConfigApplicationContext(SameBeanConfig.class); @Test @DisplayName(\"타입으로 조회시 같은 타입이 둘 이상 있으면, 중복 오류가 발생한다.\") void findBeanByTypeDuplicate() { assertThrows(NoUniqueBeanDefinitionException.class, () -&gt; ac.getBean(MemberRepository.class)); } @Test @DisplayName(\"타입으로 조회시 같은 타입이 둘 이상 있으면, 빈 이름을 지정하면 된다.\") void findBeanByName() { MemberRepository memberRepository = ac.getBean(\"memberRepository1\", MemberRepository.class); assertThat(memberRepository).isInstanceOf(MemberRepository.class); } @Test @DisplayName(\"특정 타입을 모두 조회하기\") void findAllBeanByType() { Map&lt;String, MemberRepository&gt; beansOfType = ac.getBeansOfType(MemberRepository.class); for (String key : beansOfType.keySet()) { System.out.println(\"key = \" + key + \" value = \" + beansOfType.get(key)); System.out.println(\"beansOfType = \" + beansOfType); assertThat(beansOfType.size()).isEqualTo(2); } } @Configuration static class SameBeanConfig { @Bean public MemberRepository memberRepository1() { return new MemoryMemberRepository(); } @Bean public MemberRepository memberRepository2() { return new MemoryMemberRepository(); } }}ac.getBeansOfType(타입)을 사용하면 타입에 해당하는 모든 빈을 조회할 수 있다.스프링 빈 조회 - 상속 관계 부모 타입으로 빈을 조회하면 자식 타입도 모두 조회된다. 자바 객체의 부모인 Object타입으로 조회하면 모든 스프링 빈이 조회된다.public class ApplicationContextExtendsFindTest { ApplicationContext ac = new AnnotationConfigApplicationContext(TestConfig.class); @Test @DisplayName(\"부모 타입으로 조회시, 자식이 둘 이상 있으면, 중복 오류가 발생한다\") void findBeanByParentTypeDuplicate() { assertThrows(NoUniqueBeanDefinitionException.class, () -&gt; ac.getBean(DiscountPolicy.class)); } @Test @DisplayName(\"부모 타입으로 조회시, 자식이 둘 이상 있으면, 빈 이름을 지정하면 된다\") void findBeanByParentTypeBeanName() { DiscountPolicy rateDiscountPolicy = ac.getBean(\"rateDiscountPolicy\", DiscountPolicy.class); assertThat(rateDiscountPolicy).isInstanceOf(DiscountPolicy.class); } @Test @DisplayName(\"특정 하위 타입으로 조회\") void findBeanBySubType() { RateDiscountPolicy bean = ac.getBean(RateDiscountPolicy.class); assertThat(bean).isInstanceOf(RateDiscountPolicy.class); } @Test @DisplayName(\"부모 타입으로 모두 조회하기\") void findAllBeanByParentType() { Map&lt;String, DiscountPolicy&gt; beansOfType = ac.getBeansOfType(DiscountPolicy.class); assertThat(beansOfType.size()).isEqualTo(2); for (String key : beansOfType.keySet()) { System.out.println(\"key = \" + key + \" value = \" + beansOfType.get(key)); } } @Test @DisplayName(\"부모 타입으로 모두 조회하기 - Object\") void findAllBeanByObject() { Map&lt;String, Object&gt; beansOfType = ac.getBeansOfType(Object.class); for (String key : beansOfType.keySet()) { System.out.println(\"key = \" + key + \" value = \" + beansOfType.get(key)); } } @Configuration static class TestConfig { @Bean public DiscountPolicy fixDiscountPolicy() { return new FixDiscountPolicy(); } @Bean public DiscountPolicy rateDiscountPolicy() { return new RateDiscountPolicy(); } }}BeanFactory와 ApplicationContext BeanFactory 스프링 컨테이너의 최상위 인터페이스 스프링 빈을 관리하고 조회하는 역할을 담당한다. getBean()을 제공 ApplicationContext BeanFactory의 기능을 모두 상속받아서 제공한다. ApplicationContext는 BeanFactory가 제공하는 기능 외에 부가기능까지 제공한다. ApplicationContext MessageSource 메세지 소스를 활용한 국제화 기능 EnvironmentCapable 환경변수 ApplicationEventPublisher 어플리케이션 이벤트 ResourceLoader 편리한 리소스 조회 다양한 설정 형식 지원스프링 컨테이너는 자바코드, XML 등 다양한 형식의 설정 정보를 받아드릴 수 있게 유연하게 설계되어 있다.스프링 빈 설정 메타 정보 - BeanDefinition스프링은 BeanDefinition이라는 추상화가 있어 다양한 설정형식을 지원한다.BeanDefinition을 빈 설정 메타 정보라 하며, 스프링 컨테이너는 이 메타 정보를 기반으로 스프링 빈을 생성한다.코드레벨 BeanDefinitionAnnotationConfigApplicationContext 는 AnnotatedBeanDefinitionReader 를 사용해서AppConfig.class 를 읽고 BeanDefinition 을 생성한다.BeanDefinition 정보 BeanClassName: 생성할 빈의 클래스 명(자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음) factoryBeanName: 팩토리 역할의 빈을 사용할 경우 이름, 예) appConfig factoryMethodName: 빈을 생성할 팩토리 메서드 지정, 예) memberService Scope: 싱글톤(기본값) lazyInit: 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때 까지 최대한생성을 지연처리 하는지 여부 InitMethodName: 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명 DestroyMethodName: 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명 Constructor arguments, Properties: 의존관계 주입에서 사용한다. (자바 설정 처럼 팩토리 역할의빈을 사용하면 없음)public class BeanDefinitionTest { AnnotationConfigApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class); @Test @DisplayName(\"빈 설정 메타정보 확인\") void findApplicationBean() { String[] beanDefinitionNames = ac.getBeanDefinitionNames(); for (String beanDefinitionName : beanDefinitionNames) { BeanDefinition beanDefinition = ac.getBeanDefinition(beanDefinitionName); if (beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION) { System.out.println(\"beanDefinitionName = \" + beanDefinitionName + \" beanDefinition = \" + beanDefinition); } } }}📖 references 스프링 핵심원리 -기본편 by 김영한" }, { "title": "[Spring] 이해를 위한 예제", "url": "/posts/Spring-Ex/", "categories": "Spring", "tags": "java, Spring", "date": "2022-12-28 00:00:00 +0800", "snippet": "비즈니스 요구사항 회원 회원을 가입하고 조회할 수 있다. 회원은 일반과 VIP 등급이 있다. 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. 회원 클래스 다이어그램회원 객체 다이어그램 주문 회원은 상품을 주문할 수 있다. 회원 등급에 따라 할인 정책을 ...", "content": "비즈니스 요구사항 회원 회원을 가입하고 조회할 수 있다. 회원은 일반과 VIP 등급이 있다. 회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. 회원 클래스 다이어그램회원 객체 다이어그램 주문 회원은 상품을 주문할 수 있다. 회원 등급에 따라 할인 정책을 적용할 수 있다. 할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용한다.(나중에 변경 가능) 주문 클래스 다이어그램주문public class OrderServcieImpl implements OrderService {\t private final MemberRepository memberRepository = new MemoryMemberRepository();\t private final DiscountPolicy discountPolicy = new FixDiscountPolicy(); private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy; public OrderServcieImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; } @Override public Order createOrder(Long memberId, String itemName, int itemPrice) { Member member = memberRepository.findById(memberId); int discount = discountPolicy.discount(member, itemPrice); return new Order(memberId, itemName, itemPrice, discount); }}주문 객체 다이어그램만약, 여기서 할인 정책이 고정 정책 할인이 아니라 비율에 따른 정책으로 바꾸게 된다면 OrderServiceImpl의 코드는 다음과 같이 수정된다.OrderServiceImplpublic class OrderServiceImpl implements OrderService { //private final DiscountPolicy discountPolicy = new FixDiscountPolicy();\t\tprivate final DiscountPolicy discountPolicy = new RateDiscountPolicy();👉 이와 같이 클라이언트인 OrderServiceImpl을 수정해야 되는데, 이는 OCP와 DIP를 위반하게 되는 것이다.OrderServiceImpl은 지금 인터페이스(DiscountPolicy)를 의존하면서 동시에 구현 클래스(RateDiscountPolicy)도 의존하고 있기 때문에 DIP(Dependency Inersion Principle)를 지키지 못했고, RateDiscountDisplay의 기능을 추가하면 기존의 코드를 수정해야 하므로 OCP(Open Closed Principle)에도 위배되는 것이다.기대했던 의존 관계실제 의존 관계 다이어그램 이를 해결하기 위해서는 누군가가 클라이언트인 OrderServiceImpl에 DiscountPolicy의 구현 객체를 대신 생성하고 주입해주어야 한다.관심사의 분리어플리케이션을 하나의 공연이라 생각해보자. 각각의 인터페이스를 배역(배우 역할)이라 하면 실제 배역을 맞는 배우를 선택하는 것은 누가 하는가?앞서 코드에서는 배우가 직접 상대역의 배역과 배우를 직접 고르는것과 같다. 마치 로미오 역할(인터페이스)을 하는 레오나르도 디카프리오(구현체, 배우)가 줄리엣(인터페이스)을 하는 여자 주인공(구현체, 배우)을 직접 초빙하는 것과 같은 것이다. 이처럼 디카프리오는 공연도 해야하고, 여자 주인공을 직접 초빙해야 한다는 다양한 책임을 갖고 있는 것이다.(SRP 위반)이처럼, 배우는 본인의 역할인 배역에만 집중해야 하며, 배역에 맞는 배우를 캐스팅 하는것은 공연 기획자가 담당해야 한다. 공연 기획자를 만들고 배우와 공연 기획자의 책임을 분리해야 한다.AppConfig어플리케이션의 전체 동작 방식을 구성하고, 구현 객체를 생성하고, 연결하는 책임을 갖는 클래스이다.public class AppConfig { public MemberService memberService() { return new MemberServiceImpl(getMemberRepository()); } private static MemoryMemberRepository getMemberRepository() { return new MemoryMemberRepository(); } public OrderService orderService() { return new OrderServiceImpl(getMemberRepository(), discountPolicy()); } public DiscountPolicy discountPolicy() { return new FixDiscountPolicy(); }} AppConfig는 어플리케이션의 실제 동작에 필요한 구현 객체를 생성한다. AppConfig는 생성한 객체 인스턴스의 레퍼런스를 생성자를 통해서 주입해준다.OrderServiceImplpublic class OrderServcieImpl implements OrderService { private final MemberRepository memberRepository; private final DiscountPolicy discountPolicy; public OrderServcieImpl(MemberRepository memberRepository, DiscountPolicy discountPolicy) { this.memberRepository = memberRepository; this.discountPolicy = discountPolicy; } @Override public Order createOrder(Long memberId, String itemName, int itemPrice) { Member member = memberRepository.findById(memberId); int discount = discountPolicy.discount(member, itemPrice); return new Order(memberId, itemName, itemPrice, discount); }}이렇게 되면 OrderServiceImpl 코드는 구현제에 직접 의존하지 않고 생성자를 통해 Appconfig가 구현체를 주입해주게 된다.👉 AppConfig의 등장으로 애플리케이션이 크게 **사용 영역**과, 객체를 생성하고 **구성(Configuration)하는영역**으로 분리IOC, DI 컨테이너IOC(Inversion of Control) 기존에 클라이언트에서 직접 객체를 생성해서 연결하고 실행한 것은 구현 객체가 스스로 프로그램의 제어 흐름을 스스로 조종한 것이다. AppConfig 클래스를 생성한 후 객체는 자신이 담당하는 로직만 실행할 수 있게 되었다. 프로그램의 제어 흐름은 AppConfig에서 담당하였다.(공연 기획자) AppConfig는 OrderServiceImpl이 아닌 OrderService 인터페이스의 다른 구현 객체를 생성하고 실행할 수도 있다. 이렇게 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IOC)라고 한다.프레임워크 vs 라이브러리 프레임워크는 내가 작성한 코드를 제어하고, 실행의 흐름을 제어해준다면 프레임워크(JUnit) 라이브러리는 내가 작성한 코드가 직접 제어의 흐름을 담당하면 라이브러리DI(Dependency Inversion) 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서클라이언트와 서버의 실제 의존관계가 연결 되는 것을 의존관계 주입이라 한다.📖 references 스프링 핵심원리 -기본편 by 김영한" }, { "title": "[Spring] AOP", "url": "/posts/Spring-AOP/", "categories": "Spring", "tags": "java, Spring", "date": "2022-12-27 00:00:00 +0800", "snippet": "AOP(Aspect Oriented Programming)란?AOP is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does this by adding additional behavior to ...", "content": "AOP(Aspect Oriented Programming)란?AOP is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does this by adding additional behavior to existing code without modifying the code itself.https://www.baeldung.com 에 따르면 AOP는 횡단 관심사를 분리하여 모듈성을 증가시키기 위해 맞춰진 프로그래밍 패라다임이라고 나와있다. 코드 자체를 수정하지 않고 기존 코드에 추가 동작을 추가하여 이를 수행하도록 한다고 나와 있는데, 여기서 횡단 관심사는 뭘까?횡단 관심사의 예시로는 로깅, 인증, 트랜잭션과 같은 공통적이고 중복되는 내용들이 있다. 이는 중복코드를 발생 시키고 Method의 핵심 로직을 파악하기 어렵게 하고, 코드 가독성을 떨어뜨리며, 유지보수의 난이도를 높이는 요소들이다. 이를 해결 하기 위해 AOP(Aspect Oriented Programming) 이라는 개념이 탄생하였다.예를 들어 모든 메소드에 호출 시간을 측정을 한다고 가정하자.그러면 MemberSerivce의 코드는 다음과 같다.@Transactionalpublic class MemberService { /*** 회원가입*/ public Long join(Member member) { long start = System.currentTimeMillis();\t\ttry {\t\t\t\tvalidateDuplicateMember(member); //중복 회원 검증 memberRepository.save(member); return member.getId(); } finally { long finish = System.currentTimeMillis(); long timeMs = finish - start; System.out.println(\"join \" + timeMs + \"ms\");} }/***전체 회원 조회*/ public List&lt;Member&gt; findMembers() { long start = System.currentTimeMillis(); try { return memberRepository.findAll(); } finally { long finish = System.currentTimeMillis(); long timeMs = finish - start; System.out.println(\"findMembers \" + timeMs + \"ms\");} }}모든 메소드에다 시간을 측정하는 로직을 다 추가해줘야 하는 번거로움이 있다. 이때 사용하는 것이 AOP이다.AOP는 공통 관심 사항과 핵심 관심 사항을 분리해주는 기능을 가지고 있다. 여기서 공통 관심 사항은 시간을 측정하는 기능이고, 핵심 관심 사항은 비즈니스 로직이 된다.공통 관심 사항(cross-cutting concern) vs 핵심 관심 사항(core concern) 분리AOP 등록@Aspect@Componentpublic class TimeTraceAop { @Around(\"execution(* hello.hellospring..*(..))\") public Object execute(ProceedingJoinPoint joinPoint) throws Throwable { long start = System.currentTimeMillis(); System.out.println(\"start = \" + joinPoint.toString()); try { return joinPoint.proceed(); } finally { long finish = System.currentTimeMillis(); long timeMs = finish - start; System.out.println(\"End = \" + joinPoint.toString() + \" \" + timeMs + \"ms\"); } }}이렇게 하여 회원가입, 회원 조회 등 핵심 관심 사항과 시간을 측정하는 공통 관심 사항을 분리했다.시간을 측정하는 로직을 별도의 공통 로직으로 만들었다.횡단 관심사와 핵심로직결국 위의 예제에서 공통 관심사인 시간을 측정하는 로직이 횡단 관심사가 되며 , 여러 모듈들이 시간 측정하는 로직을 사용할 수 있게 되는 것이다.AOP 동작 방식AOP 적용 전 의존관계AOP 적용 후 의존관계AOP를 등록하면 스프링 컨테이너에 프록시 memberService빈이 등록되고 memberController는 프록시 memberService와 연관관계를 맺게 된다. 이후 joinPoint.proceed()를 실행하면 실제 memberService가 실행되게 된다. 이렇게 하여 공통 관심 사항을 메소드마다 적용할 수 있게 되어 핵심 관심 사항을 분리할 수 있게 된다.📖 references 스프링 입문 -코드로 배우는 스프링 부트, 웹 MVC, DB접근 기술 by 김영한[https://jaehun2841.github.io/2018/07/20/2018-07-20-spring-aop2/#AOP의-등장배경]" }, { "title": "[Spring] 데이터베이스 접근방식", "url": "/posts/Spring-DB-Acess/", "categories": "Spring", "tags": "java, Spring", "date": "2022-12-26 00:00:00 +0800", "snippet": "순수 JDBC과거에 사용하던 방식이어서 사용하는 방식만 살펴보자save 메소드에서 사용된 jdbc 로직public class JDBCMemberRepository implements MemberRepository { private final DataSource dataSource; public JDBCMemberRepository(DataS...", "content": "순수 JDBC과거에 사용하던 방식이어서 사용하는 방식만 살펴보자save 메소드에서 사용된 jdbc 로직public class JDBCMemberRepository implements MemberRepository { private final DataSource dataSource; public JDBCMemberRepository(DataSource dataSource) { this.dataSource = dataSource; } @Override public Member save(Member member) { String sql = \"insert into member(name) values(?)\"; Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try { conn = getConnection(); pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS); pstmt.setString(1, member.getName()); pstmt.executeUpdate(); rs = pstmt.getGeneratedKeys(); if (rs.next()) { member.setId(rs.getLong(1)); } else { throw new SQLException(\"id 조회 실패\"); } return member; } catch (Exception e) { throw new IllegalStateException(e); } finally { close(conn, pstmt, rs); } }}스프링 통합 테스트스프링 컨테이너와 DB까지 연결한 통합 테스트@SpringBootTest@Transactionalclass MemberServiceIntegrationTest { @Autowired MemberService memberService; @Autowired MemberRepository repository; @Test void 회원가입() { //given Member member = new Member(); member.setName(\"spring\"); //when Long saveId = memberService.join(member); //then Member findMember = memberService.findOne(saveId).get(); assertThat(member.getName()).isEqualTo(findMember.getName()); } @Test public void 중복_회원_예외() { //given Member member1 = new Member(); member1.setName(\"spring\"); Member member2 = new Member(); member2.setName(\"spring\"); //when memberService.join(member1); IllegalStateException e = assertThrows(IllegalStateException.class, () -&gt; memberService.join(member2)); assertThat(e.getMessage()).isEqualTo(\"이미 존재하는 회원입니다.\");}@SpringBootTest는 스프링 컨테이너와 테스트를 함께 실행한다.@Transactional은 테스트 시작 전에 트랜잭션을 시작하고 테스트 완료 후 항상 롤백을 해준다. 이렇게 하면 DB에 데이터가 남지 않기 때문에 다음 테스트에 영향을 주지 않는다.스프링 Jdbc Template기존 순수 jdbc에서 템플릿 메소드 패턴을 적용하여 중복된 코드를 줄여 순수 jdbc보다 단순한 형태로 코드를 구성할 수 있다.public class JDBCTemplateMemberRepository implements MemberRepository { private final JdbcTemplate jdbcTemplate; public JDBCTemplateMemberRepository(DataSource dataSource) { jdbcTemplate = new JdbcTemplate(dataSource); } @Override public List&lt;Member&gt; findAll() { return jdbcTemplate.query(\"select * from member\", memberRowMapper()); }\t\tprivate RowMapper&lt;Member&gt; memberRowMapper() { return (rs, rowNum) -&gt; { Member member = new Member(); member.setId(rs.getLong(\"id\")); member.setName(rs.getString(\"name\")); return member;\t\t\t\t}; \t\t}}findAll메소드만 살펴보면 jdbcTemplate 객체를 이용하여 sql문을 작성하면 데이터베이스에서 데이터를 가져올 수 있는 것을 볼 수 있다.JPA(Java Persistence Api)JPA는 반복적인 코드를 줄일 수 있고 기본적인 sql도 JPA가 직접 만들어서 실행해준다.Member 클래스를 @Entity 어노테이션으로 매핑해주고 회원 레포지토리를 JPA를 이용하여 구성하면 다음과 같이 구성된다.public class JpaMemberRepository implements MemberRepository { private final EntityManager em; public JpaMemberRepository(EntityManager em) { this.em = em; } @Override public Member save(Member member) { em.persist(member); return member; } @Override public Optional&lt;Member&gt; findById(Long id) { Member member = em.find(Member.class, id); return Optional.ofNullable(member); } @Override public Optional&lt;Member&gt; findByName(String name) { List&lt;Member&gt; result = em.createQuery(\"select m from Member m where m.name = :name\", Member.class) .setParameter(\"name\", name) .getResultList(); return result.stream().findAny(); } @Override public List&lt;Member&gt; findAll() { return em.createQuery(\"select m from Member m\", Member.class) .getResultList(); }}코드가 전에 사용한 Jdbc보다 확연하게 줄어든 것을 볼 수 있다.이 후 서비스 계층에 트랜잭션을 추가해줘야 한다.@Transactionalpublic class MemberService {}JPA를 통한 모든 데이터 변경은 트랜잭션 안에서 실행해야 한다.스프링 데이터 JPA레포지토리에 구현 클래스 없이 인터페이스만으로 개발을 할 수 있다.public interface SpringDataJpaMemberRepository extends JpaRepository&lt;Member, Long&gt;, MemberRepository { @Override Optional&lt;Member&gt; findByName(String name);}📖 references 스프링 입문 -코드로 배우는 스프링 부트, 웹 MVC, DB접근 기술 by 김영한" }, { "title": "[Spring] 빈과 의존관계", "url": "/posts/Spring-Bean/", "categories": "Spring", "tags": "java, Spring", "date": "2022-12-25 00:00:00 +0800", "snippet": "Bean이란?the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise m...", "content": "Bean이란?the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container.Spring 공식문서에 bean의 정의를 보면 spring 컨테이너에 의해 제어받는 어플리케이션의 구조인 객체를 뜻한다고 나와있다. 근데 여기서 IoC란 뭘까?IoC(Inversion of Control)란?→Inversion of Control(IoC) is a process in which an object defines its dependencies without creating them.IoC란 객체가 의존성을 생성하지 않고 정의하는 프로세스를 뜻한다. 이와 같은 기법을 DI(Dependency injection)이라고 하며 객체의 생성이나 값을 대입하는 경우 외부에서 주입하는 경우를 말한다.컴포넌트 스캔과 자동 의존관계 설정회원 컨트롤러에 회원 서비스와 회원 리포지토리를 사용할 수 있게 의존관계를 설정하는 코드를 보면@Controllerpublic class MemberController { private final MemberService memberService; @AutoWired public MemberController(MemberService memberService) { this.memberService = memberService; }}생성자에 @AutoWired가 있으면 스프링이 연관관계가 맺어진 객체를 찾아서 스프링 컨테이너 안에 넣어준다. 이렇게 객체 의존관계를 외부에서 넣어주는 것을 DI(Dependency Inversion), 의존성 주입이라고 한다.하지만 memberService가 스프링 빈으로 등록되지 않아 오류가 발생한다.스프링 빈을 등록하는 2가지 방법 컴포넌트 스캔과 자동 의존관계 설정 자바 코드로 직접 스프링 빈 등록하기컴포넌트 스캔 원리@Component 어노테이션이 있으면 스프링 빈으로 자동 등록된다. 이 때문에 @Controller도 컨트롤러가 자동 등록된 이유도 컴포넌트 스캔 때문이다.@Controller, @Service, @Repository 모두 @Component를 포함하므로 자동으로 스프링 빈에 등록된다.@Servicepublic class MemberService { private final MemberRepository memberRepository; @Autowired public MemberService(MemberRepository memberRepository) { this.memberRepository = memberRepository; }}생성자에 @Autowired를 사용하면 객체 생성 시점에 스프링 컨테이너에서 해당 스프링 빈을 찾아서 주입한다.어노테이션을 사용한 결과 memberService와 memberRepository가 스프링 컨테이너에 스프링 빈으로 등록된 것을 볼 수 있다. 스프링은 스프링 컨테이너에 스프링 빈을 등록할 때, 기본으로 싱글톤으로 등록한다(유일하게 하나만 등록해서 공유한다) 따라서 같은 스프링 빈이면 모두 같은 인스턴스다. 설정으로 싱글톤이 아니게 설정할 수 있지만, 특별한 경우를 제외하면 대부분 싱글톤을 사용한다.자바 코드로 직접 스프링 빈 등록하기기존 자동 의존관계설정 방식에서 사용한 어노테이션을 Controller만 제외하여 다 제거 후 자바 코드로 빈을 등록하면 다음과 같이 작성한다.@Configurationpublic class SpringConfig { @Bean public MemberService memberService() { return new MemberService(memberRepository()); } @Bean public MemberRepository memberRepository() { return new MemoryMemberRepository(); }}@Configuration 어노테이션과 @Bean 어노테이션을 사용하여 작성자가 직접 스프링 컨테이너에 빈을 등록할 수 있다.📖 references 스프링 입문 -코드로 배우는 스프링 부트, 웹 MVC, DB접근 기술 by 김영한" }, { "title": "[Spring] 회원 관리 예제", "url": "/posts/Spring-memberManageEX/", "categories": "Spring", "tags": "java, Spring", "date": "2022-12-23 00:00:00 +0800", "snippet": "비즈니스 요구사항 데이터 : 회원ID, 이름 기능 : 회원등록, 조회일반적인 웹 어플리케이션 구조 컨트롤러 : 웹 MVC의 컨트롤러 역할 서비스 : 핵심 비즈니스 로직 구현 리포지토리 : 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리 도메인 : 비즈니스 도메인 객체 ex)회원, 주문, 쿠폰 등 주로 데이터베이스에 저장하고 관리됨회...", "content": "비즈니스 요구사항 데이터 : 회원ID, 이름 기능 : 회원등록, 조회일반적인 웹 어플리케이션 구조 컨트롤러 : 웹 MVC의 컨트롤러 역할 서비스 : 핵심 비즈니스 로직 구현 리포지토리 : 데이터베이스에 접근, 도메인 객체를 DB에 저장하고 관리 도메인 : 비즈니스 도메인 객체 ex)회원, 주문, 쿠폰 등 주로 데이터베이스에 저장하고 관리됨회원(도메인)public class Member { private Long id; private String name; public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; }}회원 리포지토리 인터페이스public interface MemberRepository { Member save(Member member); Optional&lt;Member&gt; findById(Long id); Optional&lt;Member&gt; findByName(String name); List&lt;Member&gt; findAll();}회원 리포지토리 메모리 구현체public class MemoryMemberRepository implements MemberRepository { private static Map&lt;Long, Member&gt; store = new HashMap&lt;&gt;(); private static long sequence = 0L; @Override public Member save(Member member) { member.setId(++sequence); store.put(member.getId(), member); return member; } @Override public Optional&lt;Member&gt; findById(Long id) { return Optional.ofNullable(store.get(id)); } @Override public Optional&lt;Member&gt; findByName(String name) { return store.values().stream() .filter(member -&gt; member.getName().equals(name)) .findAny(); } @Override public List&lt;Member&gt; findAll() { return new ArrayList&lt;&gt;(store.values()); } public void clearStore() { store.clear(); }}회원 서비스 개발public class MemberService { private final MemberRepository memberRepository = new MemoryMemberRepository(); public Long join(Member member) { //같은 이름이 있는 중복 회원 X validateDuplicatedMember(member); //중복 회원 검증 memberRepository.save(member); return member.getId(); } private void validateDuplicatedMember(Member member) { memberRepository.findByName(member.getName()) .ifPresent(m -&gt; { throw new IllegalStateException(\"이미 존재하는 회원입니다.\"); } ); } //전체 회원 조회 public List&lt;Member&gt; findMembers() { return memberRepository.findAll(); } public Optional&lt;Member&gt; findOne(Long memberId) { return memberRepository.findById(memberId); }}회원 레포지토리 테스트 케이스 작성class MemoryMemberRepositoryTest { MemoryMemberRepository repository = new MemoryMemberRepository(); @AfterEach public void afterEach(){ repository.clearStore(); } @Test public void save() {\t\t\t\t//given Member member = new Member(); member.setName(\"spring\");\t\t\t\t\t\t\t\t//when repository.save(member);\t\t\t\t//then Member result = repository.findById(member.getId()).get(); //Assertions.assertEquals(member, result); assertThat(member).isEqualTo(result); } @Test public void findByName() { Member member1 = new Member(); member1.setName(\"spring1\"); repository.save(member1); Member member2 = new Member(); member2.setName(\"spring2\"); repository.save(member2); Member result = repository.findById(member1.getId()).get(); assertThat(member1).isEqualTo(result); } @Test public void findAll() { Member member1 = new Member(); member1.setName(\"spring1\"); repository.save(member1); Member member2 = new Member(); member2.setName(\"spring2\"); repository.save(member2); List&lt;Member&gt; result = repository.findAll(); assertThat(result.size()).isEqualTo(2); }}test case는 given, when, then 구조로 생각하면 쉽게 작성할 수 있다.given에는 데이터를 넣는 과정, when은 테스트하려는 메소드를 입력하고, then에는 실제 구현해놓은 코드가 잘 동작되는지 검증하는 로직을 넣으면 된다.assertThat을 이용하여 isEqualTo()로 작성한 로직이 맞는지 테스트가 가능하다. 테스트는 각각 독립적으로 실행하여 테스트 순서간에 의존성을 갖으면 안된다. @AfterEach 어노테이션은 각 테스트가 종료될 때 마다 이 기능을 실행하므로, 위의 예제에서는 메모리 DB에 저장된 데이터를 삭제한다.회원 서비스 테스트class MemberServiceTest { MemberService memberService; MemoryMemberRepository repository; @BeforeEach public void beforeEach() { repository = new MemoryMemberRepository(); memberService = new MemberService(repository); } @AfterEach public void afterEach() { repository.clearStore(); } @Test void 회원가입() { //given Member member = new Member(); member.setName(\"hello\"); //when Long saveId = memberService.join(member); //then Member findMember = memberService.findOne(saveId).get(); assertThat(member.getName()).isEqualTo(findMember.getName()); } @Test public void 중복_회원_예외() { //given Member member1 = new Member(); member1.setName(\"spring\"); Member member2 = new Member(); member2.setName(\"spring\"); //when memberService.join(member1); IllegalStateException e = assertThrows(IllegalStateException.class, () -&gt; memberService.join(member2)); assertThat(e.getMessage()).isEqualTo(\"이미 존재하는 회원입니다.\");\t\t}}@BeforeEach : 각 테스트 실행 전에 호출된다. 테스트가 서로 영향이 없도록 항상 새로운 객체를 생성하고, 의존관계도 새로 맺어준다.📖 references 스프링 입문 -코드로 배우는 스프링 부트, 웹 MVC, DB접근 기술 by 김영한" }, { "title": "[Spring] 웹 개발 기초", "url": "/posts/Spring_Web_Basic/", "categories": "Spring", "tags": "java, Spring", "date": "2022-12-22 00:00:00 +0800", "snippet": "Spring 웹 어플리케이션에서 브라우저에게 응답하는 방식은 다음과 같이 크게 3가지로 나눌 수 있다. Static Content MVC APIStatic Content 웹 브라우저가 /hello-static.html url을 요청하면 톰켓 내장서버는 스프링 컨테이너에 hello-static에 관련된 컨트롤러를 찾아달라고 한다. 만약 관련된 ...", "content": "Spring 웹 어플리케이션에서 브라우저에게 응답하는 방식은 다음과 같이 크게 3가지로 나눌 수 있다. Static Content MVC APIStatic Content 웹 브라우저가 /hello-static.html url을 요청하면 톰켓 내장서버는 스프링 컨테이너에 hello-static에 관련된 컨트롤러를 찾아달라고 한다. 만약 관련된 컨트롤러가 없으면 톰켓 내장서버는 resources: statc/hello-static.html을 찾고 이를 웹 브라우저에게 응답해준다.MVC 웹 브라우저는 /hello-mvc를 요청하고 내장 톰켓 서버는 스프링 컨터이너에 helloController에게 넘겨서 /hello-mvc에 매핑되어있는 메소드를 호출하고 “hello-template”을 return한다. viewResolver는 return한 “hello-template”을 templates밑에 찾고 템플릿 엔진에게 넘긴다. 템플릿 엔진은 변환한 html을 웹 브라우저에게 응답한다.API 웹 브라우저가 /hello-api를 요청하면 내장 톰켓 서버는 스프링에 helloController에게 넘겨서 helloController는 /hello-api와 매핑되어있는 메소드가 있다면 해당 메소드를 호출한다. 만약 해당 메소드에 @ReponseBody 라고 어노테이션이 있다면 viewResolver 대신 HttpMessageConverter에게 return 값을 반환한다. HttpMessageConverter는 만약 반환값이 문자열이라면 StringConverter가 동작되고, 만약 반환값이 객체라면 JsonConverter가 동작된다. hello라는 객체가 반환되었으므로 JsonConverter가 동작되어 웹 브라우제에게 Json형태로 데이터가 응답된다. 기본 문자처리: StringHttpMessageConverter 기본 객체처리: MappingJackson2HttpMessageConverter 📖 references 스프링 입문 -코드로 배우는 스프링 부트, 웹 MVC, DB접근 기술 by 김영한" }, { "title": "[Spring] 프로젝트 환경설정", "url": "/posts/SpringProjectSetting/", "categories": "Spring", "tags": "java, Spring", "date": "2022-12-21 00:00:00 +0800", "snippet": "https://start.spring.io 에서 스프링 부트의 환경 설정이 가능하며, 버전선택, 패키지 이름, 라이브러리 추가 등 스프링 부트에 필요한 설정들을 추가할 수 있다.dependencies 추가 내용 : Spring Web, Thymeleaf(html을 만들어주는 template 엔진)환경설정 build.gradle rep...", "content": "https://start.spring.io 에서 스프링 부트의 환경 설정이 가능하며, 버전선택, 패키지 이름, 라이브러리 추가 등 스프링 부트에 필요한 설정들을 추가할 수 있다.dependencies 추가 내용 : Spring Web, Thymeleaf(html을 만들어주는 template 엔진)환경설정 build.gradle repositories{ mavenCentral()} : mavenCentral()이라는 곳에서 라이브러리 다운하라는 명령어 dependencies {implementaion ~} : 프로젝트 생성할 때 추가했던 라이브러리들 라이브러리dependencies : 라이브러리와의 의존관계 spring-boot-starter-web spring-boot-starter-tomcat: 톰캣 (웹서버) spring-webmvc: 스프링 웹 MVC spring-boot-starter-thymeleaf: 타임리프 템플릿 엔진(View) spring-boot-starter(공통): 스프링 부트 + 스프링 코어 + 로깅 spring-boot spring-core spring-boot-starter-logging logback, slf4j Spring 동작 환경 웹 브라우저가 8080포트에 접속하면 톰켓서버를 거쳐 스프링 컨테이너에게 /hello에 관한 처리를 요청한다. helloController는 model에 data : hello!를 삽입하고 “hello”를 return하면 viewResolver가 templates 밑에 hello.html를 찾는다. ViewResolver는 hello.html을 찾아서 Thymeleaf가 템플릿을 처리하여 웹 브라우저에게 응답한다. 스프링 부트 템플릿엔진 기본 viewName 매핑 resources:templates/ +{ViewName}+ .html 웹 템플릿 엔진은 view code(html)와 data logic code(db connection)를 분리해주는 기능을 한다.📖 references 스프링 입문 -코드로 배우는 스프링 부트, 웹 MVC, DB접근 기술 by 김영한" }, { "title": "[Design Pattern] 컴포지트 패턴", "url": "/posts/Composite_Pattern/", "categories": "Design Pattern", "tags": "java, design pattern", "date": "2022-12-19 00:00:00 +0800", "snippet": "부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성한다. 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴택배 박스안에 있는 물품들의 비용을 계산하는 예로 보자. 박스안에는 양말과 바지가 있다고 했을 때 클래스 구조는 다음과 같다.Boxpublic class Box { private List&lt;...", "content": "부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성한다. 사용자로 하여금 개별 객체와 복합 객체를 모두 동일하게 다룰 수 있도록 하는 패턴택배 박스안에 있는 물품들의 비용을 계산하는 예로 보자. 박스안에는 양말과 바지가 있다고 했을 때 클래스 구조는 다음과 같다.Boxpublic class Box { private List&lt;Trousers&gt; trousers = new ArrayList&lt;&gt;(); private List&lt;Socks&gt; socks = new ArrayList&lt;&gt;(); public int price() { int tPrice = 0; int sPrice = 0; for (Trousers t : trousers) { tPrice += t.price(); } for (Socks s : socks) { sPrice += s.price(); } return tPrice + sPrice; } public void addSocks(Socks s) { socks.add(s); } public void addTrousers(Trousers t) { trousers.add(t); }}Trouserspublic class Trousers { private int weight; public Trousers(int weight) { this.weight = weight; } public int price() { return this.weight/100*200; }}Sockspublic class Socks { private int weight; public Socks(int weight) { this.weight = weight; } public int price() { return this.weight/100*200; }}Mainpublic class Main { public static void main(String[] args) { Box box1 = new Box(); Socks s1 = new Socks(200); Socks s2 = new Socks(300); Trousers t1 = new Trousers(600); box1.addSocks(s1); box1.addSocks(s2); box1.addTrousers(t1); System.out.println(box1.price()); }}여기에서 박스에 만약 gold라는 아이템을 추가한다면 클래스 다이어그램은 다음과 같이 된다.Goldpublic class Gold { private int weight; public Gold(int weight) { this.weight = weight; } public int price() { return this.weight/100*200; }}수정 된 Boxpublic class Box { private List&lt;Trousers&gt; trousers = new ArrayList&lt;&gt;(); private List&lt;Socks&gt; socks = new ArrayList&lt;&gt;(); private List&lt;Gold&gt; golds = new ArrayList&lt;&gt;(); public int price() { int tPrice = 0; int sPrice = 0; for (Trousers t : trousers) { tPrice += t.price(); } for (Socks s : socks) { sPrice += s.price(); } for (Gold g : golds) { gPrice += g.price(); } return tPrice + sPrice + gPrice; } public void addSocks(Socks s) { socks.add(s); } public void addTrousers(Trousers t) { trousers.add(t); } public void addGolds(Gold g) { golds.add(g); }}또한 박스안에 박스를 넣을 수 있기 때문에 박스 클래스는 자신과 집약관계를 맺을 수 있게 되고 클래스 다이어그램으로 나타내면 다음과 같다.자신과 집약관계를 맺는 Boxpublic class Box { private List&lt;Trousers&gt; trousers = new ArrayList&lt;&gt;(); private List&lt;Socks&gt; socks = new ArrayList&lt;&gt;(); private List&lt;Gold&gt; golds = new ArrayList&lt;&gt;(); private List&lt;Box&gt; boxes = new ArrayList&lt;&gt;(); public int price() { int tPrice = 0; int sPrice = 0; int gPrice = 0; int bPrice = 0; for (Trousers t : trousers) { tPrice += t.price(); } for (Socks s : socks) { sPrice += s.price(); } for (Gold g : golds) { gPrice += g.price(); } for (Box b : boxes) { bPrice += b.price(); } return tPrice + sPrice + gPrice + bPrice; } public void addSocks(Socks s) { socks.add(s); } public void addTrousers(Trousers t) { trousers.add(t); } public void addGolds(Gold g) { golds.add(g); } public void addBox(Box b) { boxes.add(b); }}클라이언트 코드 Mainpublic class Main { public static void main(String[] args) { Box box1 = new Box(); Socks s1 = new Socks(200); Socks s2 = new Socks(300); Trousers t1 = new Trousers(600); box1.addSocks(s1); box1.addSocks(s2); box1.addTrousers(t1); System.out.println(box1.price()); Box box2 = new Box(); Gold g1 = new Gold(800); box2.addBox(box1); box2.addGolds(g1); System.out.println(box2.price()); }}여기서 보면 벌써 새로운 아이템이 추가될 때마다 Box.java 클래스에서 새로운 아이템에 대한 가격 계산을 해야되므로 코드가 수정되어 OCP에 위배된다. 이럴때 사용하는 디자인 패턴이 컴포지트 패턴이고 택배에 넣을 수 있는 항목들을 포함하는 인터페이스 ParcelItem을 만들어 이를 상속하는 구조로 바꿔볼 수 있다.ParcelItem을 상속하여 구성된 구조ParcelItempublic abstract class ParcelItem { protected int weight; public ParcelItem(int weight) { this.weight = weight; } public abstract int price();}Trouserspublic class Trousers extends ParcelItem{ public Trousers(int weight) { super(weight); } public int price() { return this.weight/100*200; }}Sockspublic class Socks extends ParcelItem{ public Socks(int weight) { super(weight); } public int price() { return weight/100*200; }}Goldpublic class Gold extends ParcelItem{ public Gold(int weight) { super(weight); } public int price() { return this.weight/100*2000; }}Boxpublic class Box extends ParcelItem{ private List&lt;ParcelItem&gt; items = new ArrayList&lt;&gt;(); public Box(int weight) { super(weight); } public int price() { int totalPrice = 0; for (ParcelItem item : items) { totalPrice += item.price(); } return totalPrice; } public void addItems(ParcelItem item) { items.add(item); }}Mainpublic class Main { public static void main(String[] args) { Box box1 = new Box(0); Socks s1 = new Socks(200); Socks s2 = new Socks(300); Trousers t1 = new Trousers(600); box1.addItems(s1); box1.addItems(s2); box1.addItems(t1); System.out.println(box1.price()); Box box2 = new Box(0); Gold g1 = new Gold(800); box2.addItems(box1); box2.addItems(g1); System.out.println(box2.price()); }}Composite 패턴은 전체-부분을 가지는 객체들 간의 관계를 정의할때 유용하다. 클라이언트는 전체와 부분을 구분하지 않고 동일한 인터페이스를 사용할 수 있다. Component : 구체적인 부분, 즉 Leaf 클래스와 전체에 해당하는 Composite 클래스에 공통 인터페이스를 정의함. Leaf : 구체적인 부분클래스로 Composite 객체의 부품으로 설정 Composite : 전체 클래스로 복수 개의 Component를 갖도록 정의한다. 그러므로 복수 개의 Leaf, 심지어 복수 개의 Compostie 객체를 부분으로 가질 수 있다.📖 references 정인상, 「JAVA 객체지향 디자인 패턴」, 한빛미디어" }, { "title": "[Design Pattern] 브릿지 패턴", "url": "/posts/Bridge_Pattern/", "categories": "Design Pattern", "tags": "java, design pattern", "date": "2022-12-19 00:00:00 +0800", "snippet": "구현부에서 추상층에서 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴TV로 채널과 소리를 제어할 수있는 리모컨의 사용에 대한 예로 브릿지 패턴의 사용을 알아보자Tvpublic class Tv { private boolean on = false; private int volume = 30; private int channel = 1;...", "content": "구현부에서 추상층에서 분리하여 각자 독립적으로 변형할 수 있게 하는 패턴TV로 채널과 소리를 제어할 수있는 리모컨의 사용에 대한 예로 브릿지 패턴의 사용을 알아보자Tvpublic class Tv { private boolean on = false; private int volume = 30; private int channel = 1; public boolean isEnabled() { return on;} public void enable() { on = true; } public void disable() { on = false; } public int getVolume() { return volume; } public void setVolume(int volume) { if (volume &gt; 100) { this.volume = 100; } else if (volume &lt; 0) { this.volume = 0; } else { this.volume = volume; } }\t\tpublic int getChannel() { return channel; } public void setChannel(int channel) { this.channel = channel; } public void printStatus() { System.out.println(\"------------------------------------\"); System.out.println(\"| I'm TV set.\"); System.out.println(\"| I'm \" + (on ? \"enabled\" : \"disabled\")); System.out.println(\"| Current volume is \" + volume + \"%\"); System.out.println(\"| Current channel is \" + channel); System.out.println(\"------------------------------------\\n\"); }}Remotepublic class Remote { protected Tv device; public Remote(Tv device) { this.device = device; } public void power() { System.out.println(\"Tv Remote: power toggle\"); if (device.isEnabled()) { device.disable(); } else { device.enable(); } } public void volumeDown() { System.out.println(\"Tv Remote: volume down\"); device.setVolume(device.getVolume() - 10); } public void volumeUp() { System.out.println(\"Tv Remote: volume up\"); device.setVolume(device.getVolume() + 10); }\t\tpublic void channelDown() {\t\t\t\tSystem.out.println(\"Tv Remote: channel down\");\t\t\t\tdevice.setChannel(device.getChannel() - 1);\t\t}\t\tpublic void channelUp() {\t\t\t\tSystem.out.println(\"Tv Remote: channel up\");\t\t\t\tdevice.setChannel(device.getChannel() + 1);\t\t}}만약 여기서 remote의 기능을 TV가 아닌 Radio로 바꾸고 싶다면 Remote.java에서 device로 된것을 Radio로 다 바꿔줘야 되기때문에 OCP에 위배되는것을 알 수 있다.그래서 TV와 Radio를 포함할 수 있는 인터페이스 Device를 만들어 구성할 수 있다.클래스 다이어그램But, 만약 Device쪽에 변화가 일어나는것이 아닌 Remote쪽에 변화가 일어나면?예를 들어 Remote의 추가 기능중 Mute기능을 추가하고 싶다면 Remote 클래스를 상속받아 자식 클래스에서 정의하도록 구성할 수 있다.클래스 다이어그램Devicepublic interface Device { boolean isEnabled(); void enable(); void disable(); int getVolume(); void setVolume(int percent); int getChannel(); void setChannel(int channel); void printStatus();}Radiopublic class Radio implements Device { private boolean on = false; private int volume = 30; private int channel = 1; public boolean isEnabled() { return on;} public void enable() { on = true; } public void disable() { on = false; } public int getVolume() { return volume; } public void setVolume(int volume) { if (volume &gt; 100) { this.volume = 100; } else if (volume &lt; 0) { this.volume = 0; } else { this.volume = volume; } } public int getChannel() { return channel; } public void setChannel(int channel) { this.channel = channel; } public void printStatus() { System.out.println(\"------------------------------------\"); System.out.println(\"| I'm Radio set.\"); System.out.println(\"| I'm \" + (on ? \"enabled\" : \"disabled\")); System.out.println(\"| Current volume is \" + volume + \"%\"); System.out.println(\"| Current channel is \" + channel); System.out.println(\"------------------------------------\\n\"); }}TVpublic class Tv implements Device { private boolean on = false; private int volume = 30; private int channel = 1; public boolean isEnabled() { return on;} public void enable() { on = true; } public void disable() { on = false; } public int getVolume() { return volume; } public void setVolume(int volume) { if (volume &gt; 100) { this.volume = 100; } else if (volume &lt; 0) { this.volume = 0; } else { this.volume = volume; } } public int getChannel() { return channel; } public void setChannel(int channel) { this.channel = channel; } public void printStatus() { System.out.println(\"------------------------------------\"); System.out.println(\"| I'm TV set.\"); System.out.println(\"| I'm \" + (on ? \"enabled\" : \"disabled\")); System.out.println(\"| Current volume is \" + volume + \"%\"); System.out.println(\"| Current channel is \" + channel); System.out.println(\"------------------------------------\\n\"); }}BasicRemotepublic class BasicRemote { protected Device device; public BasicRemote(Device device) { this.device = device; } public void power() { System.out.println(\"Remote: power toggle\"); if (device.isEnabled()) { device.disable(); } else { device.enable(); } } public void volumeDown() { System.out.println(\"Remote: volume down\"); device.setVolume(device.getVolume() - 10); } public void volumeUp() { System.out.println(\"Remote: volume up\"); device.setVolume(device.getVolume() + 10); } public void channelDown() { System.out.println(\"Remote: channel down\"); device.setChannel(device.getChannel() - 1); } public void channelUp() { System.out.println(\"Remote: channel up\"); device.setChannel(device.getChannel() + 1); }}AdvanceRemoteWithMutepublic class AdvanceRemoteWithMute extends BasicRemote { public AdvanceRemoteWithMute(Device device) { super(device); } public void mute() { System.out.println(\"Remote: mute\"); device.setVolume(0); }}Mainpublic class Main { public static void main(String[] args) { Tv tv = new Tv(); BasicRemote r1 = new BasicRemote(tv); r1.power(); r1.channelUp(); tv.printStatus(); Radio radio = new Radio(); AdvanceRemoteWithMute r2 = new AdvanceRemoteWithMute(radio); r2.power(); r2.volumeUp(); radio.printStatus(); r2.mute(); radio.printStatus(); }}여기서 Remote의 기능은 TV에 의존된 기능을 제공을 하므로 상위 레벨 개념이고, TV는 하위 레벨 개념이 된다. Remote 객체는 기능을 실행하기 위해서는 구현부인 TV에서 그 기능을 실행하기 떄문에 추상부(Remote)에서 구현부로 기능을 실현하기 위해 위임한다고 볼 수 있다. 추상부 : AdvancedRemoteWithMute.java 구현부 : TV, Radio abstraction(BasicRemote) : 추상적 개념에 대한 인터페이스를 제공하고 객체 구현자(Implementor)에 대한 참조자를 관리한다. RefinedAbstraction(AdvanceRemoteWithMute) : 추상적 개념에 정의된 인터페이스를 확장한다. Implementor(Device) : 구현 클래스에 대한 인터페이스를 제공한다. 실질적인 구현을 제공한 서브 클래스들에 공통적인 연산의 시그니처만을 정의한다. 이 인터페이스는 Abstraction 클래스에 정의된 인터페이스에 정확하게 대응할 필요가 없다. 즉, 두 인터페이스는 서로 다른 형태일 수 있다. 일반적으로 Implemetor 인터페이스는 기본적인 구현 연산을 수행하고, Abstraction은 더 추상화된 서비스의 관점의 인터페이스를 제공한다. ConcreteImplementor(TV) : Implementor 인터페이스를 구현하는 것으로 실제적인 구현 내용을 담는다.📖 references 정인상, 「JAVA 객체지향 디자인 패턴」, 한빛미디어" }, { "title": "[Design Pattern] 어댑터 패턴", "url": "/posts/Adapter_Pattern/", "categories": "Design Pattern", "tags": "java, design pattern", "date": "2022-12-19 00:00:00 +0800", "snippet": "클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 변환시킨다. 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킨다.Adder라는 인터페이스를 이용해 UserAdd가 덧셈을 구현하는 방식을 클래스 다이어그램으로 나타내면 다음과 같다.UserAdder는 Adder를 상속한 Adder객체와 더할 두 정수를 생성자의 매개변수로 받게 되어 ...", "content": "클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 변환시킨다. 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킨다.Adder라는 인터페이스를 이용해 UserAdd가 덧셈을 구현하는 방식을 클래스 다이어그램으로 나타내면 다음과 같다.UserAdder는 Adder를 상속한 Adder객체와 더할 두 정수를 생성자의 매개변수로 받게 되어 계산을 하게 된다.Adderpublic interface Adder { public int plus(int x, int y);}MyAdderpublic class MyAdder implements Adder { @Override public int plus(int x, int y) { return x + y; }}UserAdderpublic class UseAdder { public int add(Adder adder, int x, int y) { int r = 0; r = adder.plus(x, y); return r; }}Mainpublic class Main { public static void main(String[] args) { Adder adder = new MyAdder(); UseAdder use = new UseAdder(); System.out.println(use.add(adder, 10, 20)); }}이런 상황에서는 문제가 없지만 만약 수정할 수 없는 라이브러리로 주어진 Adder형태를 사용해야한다면 이 구조로 사용이 가능할까? 그러면 Adder 인터페이스를 상속 받지 못하고 위의 예제에서 plus라는 기능을 사용못하고 라이브러리가 제공하는 형태에 맞춰서 사용을 해야한다. 이와 같은 제약사항에서 사용하는 패턴인 adpter 패턴이다.사용하려는 인터페이스와 제공하는 인터페이스가 다르다면 adpter 패턴을 적용하여 이 둘 사이에 호환이 되게끔 adpter 클래스를 만들면 된다.제공하는 인터페이스를 YourAdder라고 하면 YourAdder에서는 add라는 메소드를 제공하지만 UseAdder는 plus라는 연산을 사용하므로 이 둘을 연결해주는 YourAdapter 클래스를 만들어 사용하면 된다.YourAdderpublic class YourAdder { public int add3(int x, int y, int z) { return x + y + z; }}YourAdderpublic class YourAdderAdapter implements Adder { private YourAdder yourAdder; public YourAdderAdapter(YourAdder yourAdder) { this.yourAdder = yourAdder; } @Override public int plus(int x, int y) { return yourAdder.add3(x, y, 0); }}Mainpublic class Main { public static void main(String[] args) { Adder adder = new MyAdder(); UseAdder use = new UseAdder(); System.out.println(use.add(adder, 10, 20)); Adder adder1 = new YourAdderAdapter(new YourAdder()); System.out.println(use.add(adder1, 10, 20)); }}이렇게 되면 제공하는 인터페이스가 달라도 기존의 코드 수정없이 adpter만 추가하여 덧셈 연산을 구현할 수 있게 된다. Client(UseAdder) : Target 인터페이스를 만족하는 객체와 동작할 대상 Target(Adder) : 사용자가 사용할 응용 분야에 종속적인 인터페이스를 정의하는 클래스 Adapter(yourAdapter) : Target 인터페이스에 Adaptee의 인터페이스를 적응 시키는 클래스 Adaptee(YourAdder) : 인터페이스의 적응이 필요한 기존 인터페이스를 정의 하는 클래스로, 적응 대상자라고 함📖 references 정인상, 「JAVA 객체지향 디자인 패턴」, 한빛미디어" }, { "title": "[Design Pattern] 팩토리 메서드 패턴", "url": "/posts/Factory_Method_Pattern/", "categories": "Design Pattern", "tags": "java, design pattern", "date": "2022-12-18 00:00:00 +0800", "snippet": "객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 하는 패턴팩토리 메소드 패턴은 생성 패턴 중 하나로 이 패턴이 언제 적용 되는지 알기 위해 사과를 디저트로 제공하는 식당 클래스로 예를 들어보자Applepublic abstract class Apple { public abstrac...", "content": "객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할지에 대한 결정은 서브클래스가 내리도록 하는 패턴팩토리 메소드 패턴은 생성 패턴 중 하나로 이 패턴이 언제 적용 되는지 알기 위해 사과를 디저트로 제공하는 식당 클래스로 예를 들어보자Applepublic abstract class Apple { public abstract void wash(); public abstract void peel(); public abstract void slice();}Restaurantpublic class Restaurant { public Apple servingApple() { Apple apple = new busa(); apple.wash(); apple.peel(); apple.slice(); return apple; }}Busapublic class Busa extends Apple { @Override public void wash() { System.out.println(\"Busa: wash\"); } @Override public void peel() { System.out.println(\"Busa: peel\"); } @Override public void slice() { System.out.println(\"Busa: slice\"); }}Hongokpublic class Hongok extends Apple { @Override public void wash() { System.out.println(\"Hongok: wash\"); } @Override public void peel() { System.out.println(\"Hongok: peel\"); } @Override public void slice() { System.out.println(\"Hongok: slice\"); }}만약 아침에 홍옥 사과를 먹는 클래스를 만들어보면 다음과 같다.public class Home { public Apple getAppleForBreakfast() { Apple apple = new Hongok(); apple.wash(); return apple; }}여기서 만약 사과의 종류가 변경된다고 해보자. 그럼 Restuarant 클래스와 Home 클래스에서 사과를 생성하는 명령어 부분을 다른 종류의 사과로 바꿔 생성자를 통해 생성 해야한다. 이렇게 되면 사과 인스턴스를 생성하는 모든 코드에서 계속해서 반복하여 작업하게 된다.public class Restaurant { public Apple servingApple(String kind) { Apple apple = null;\t\t\t\tif(kind.equals(\"busa\")) apple = new Busa();\t\t\t\telse if(kind.eqauls(\"hongok\")) apple = new hongok(); apple.wash(); apple.peel(); apple.slice(); return apple; }}이런식으로 kind 매개변수를 받고 kind에 따라 사과를 생성하는 방식으로 바꿀수 있지만 사과의 종류는 계속 변경되므로 이 부분을 따로 클래스로 분리하여 캡슐화한다. 이떄 사용하는 패턴이 팩토리 메소드 패턴으로 이 예제에서는 AppleFactory라는 클래스로 캡슐화를 하게 되면 아래의 코드와 같다.AppleFactorypublic class AppleFactory {\t\t Apple apple = null;\t\t\tif(kind.equals(\"busa\")) apple = new Busa();\t\t\telse if(kind.eqauls(\"hongok\")) apple = new hongok(); apple.wash(); apple.peel(); apple.slice(); return apple;}Restuarantpublic class Restaurant { public Apple servingApple(String kind) {\t\t\t\tApple apple = null; Apple apple = factory.getApple(kind); apple.wash(); apple.peel(); apple.slice(); return apple; }}여기서 AppleFactory 메소드는 생성자를 생성하는 클래스이므로 여기에 싱글턴 패턴을 적용해서 코드를 다시 구성하게 된다면 아래와 같다.public class AppleFactory { private static AppleFactoryinstance= null; private AppleFactory() {}; public static AppleFactory getInstance() { if (instance== null)instance= new AppleFactory(); returninstance; } public Apple getApple(String kind) { Apple apple = null; if (kind.equals(\"busa\")) apple = new Busa(); else if (kind.equals(\"hongok\")) apple = new Hongok(); else if (kind.equals(\"hongro\")) apple = new Hongro(); return apple; }}Restaurantpublic class Restaurant { public Apple servingApple(String kind) { AppleFactory factory = AppleFactory.getInstance(); Apple apple = factory.getApple(kind); apple.wash(); apple.peel(); apple.slice(); return apple; }}Mainpublic class Main { public static void main(String[] args) { Restaurant r1 = new Restaurant(); r1.servingApple(\"busa\"); }} 팩토리 메소드 패턴은 객체를 생성하는 코드를 별도의 클래스/메소드로 분리함으로써 객체 생성 방식의 변화에 대비하는데 유용하다. 여기에 GoF의 팩토리 메소드 패턴을 소개하면 GoF의 팩토리 메소드 패턴은 템플릿 메소드 패턴을 이용하여 자식 클래스에서 생성자를 정의하도록 구성하였다.Restuarantpublic abstract class Restaurant { public Apple servingApple(String kind) { //template method Apple apple = getApple(kind); //factory method apple.wash(); apple.peel(); apple.slice(); return apple; } public abstract Apple getApple(String kind);}전체적인 흐름에서 특정부분만 달라지기 때문에 사과를 얻어오는 지점만 Template Method을 적용할 수 있다.여기서 servingApple 메소드는 전체적인 흐름을 기술하는 것이기 때문에 template method 이고 사과를 얻어오는 getApple은 각 지점마다 다르므로 하위 클래스에서 정의하는 factory method이다.SeoulRestuarantpublic class SeoulRestaurant extends Restaurant { @Override public Apple getApple(String kind) { Apple apple = null; if (kind.equals(\"busa\")) apple = new Busa(); if (kind.equals(\"hongok\")) apple = new Hongok(); if (kind.equals(\"hongro\")) apple = new Hongro(); return apple; }}NYRestuarantpublic class NYRestaurant extends Restaurant { @Override public Apple getApple(String kind) { Apple apple = null; if (kind.equals(\"koru\"))apple = new Koru(); else if(kind.equals(\"crispy\"))apple =new Everycrispy(); else if (kind.equals(\"pl\"))apple =new Pinklady(); return apple; }}Mainpublic class Main { public static void main(String[] args) { Restaurant namgajwa = new SeoulRestaurant(); namgajwa.servingApple(\"busa\"); Restaurant manha = new NYRestaurant(); manha.servingApple(\"pl\"); }} Product(Apple) : 팩토리 메소드로 생성될 객체의 공통 인터페이스 ConcreteProduct(Busa, Hongok) : 구체적으로 객체가 생성되는 클래스 Creator(Restuarant): 팩토리 메소드를 갖는 클래스 ConcreteCreator(SeoulRestuarant) : 팩토리 메소드를 구현하는 클래스로 ConcreteProduct 객체를 생성한다.📖 references 정인상, 「JAVA 객체지향 디자인 패턴」, 한빛미디어" }, { "title": "[Design Pattern] 추상 팩토리 패턴", "url": "/posts/Abstract_Factory_Pattern/", "categories": "Design Pattern", "tags": "java, design pattern", "date": "2022-12-18 00:00:00 +0800", "snippet": "구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴엘레베이터 부품 업체 변경하는 문제로 예를 들어보자. 엘레베이터를 구성하는 많은 부품들 중에서 모터와 문이 있다고 하자. LG라는 회사는 LG모터와 LG문을 제공하고, 현대는 현대 모터와 현대문을 제공한다.우...", "content": "구체적인 클래스를 지정하지 않고 관련성을 갖는 객체들의 집합을 생성하거나 서로 독립적인 객체들의 집합을 생성할 수 있는 인터페이스를 제공하는 패턴엘레베이터 부품 업체 변경하는 문제로 예를 들어보자. 엘레베이터를 구성하는 많은 부품들 중에서 모터와 문이 있다고 하자. LG라는 회사는 LG모터와 LG문을 제공하고, 현대는 현대 모터와 현대문을 제공한다.우선 LG의 모터와 현대의 모터는 구체적인 제어 방식은 다르지만 엘레베이터 입장에서는 모터를 구동해 엘레베이터를 이동시킨다는 면에서 동일하다. 그러므로 추상 클래스로 Motor를 정의하고 LGMotor와 HyundaiMotor를 하위 클래스로 정의할 수 있다. Door도 마찬가지로 LGDoor와 HyundaiDoor를 하위클래스로 지정할 수 있다.Motorpublic abstract class Motor { private Door door; private MotorStatus motorStatus; public void setDoor(Door door) { this.door = door; this.motorStatus = MotorStatus.STOPPED; } public void move(Direction direction) { MotorStatus motorStatus = getMotorStatus(); if (motorStatus == MotorStatus.MOVING) return; DoorStatus doorStatus = door.getDoorStatus(); if (doorStatus == DoorStatus.OPENED) door.close(); moveMotor(direction); //이 부분이 제조사마다 다르게 구현됨 setMotorStatus(MotorStatus.MOVING); } private void setMotorStatus(MotorStatus motorStatus) { this.motorStatus = motorStatus; } protected abstract void moveMotor(Direction direction); private MotorStatus getMotorStatus() { return motorStatus; }}LGMotorpublic class LgMotor extends Motor { @Override protected void moveMotor(Direction direction) { System.out.println(\"Lg motor is Moving \" + direction); }}Motorpublic class HyundaiMotor extends Motor { @Override protected void moveMotor(Direction direction) { System.out.println(\"Hyundai motor is Moving \" + direction); }}Doorpublic abstract class Door { private DoorStatus doorStatus; public Door() { this.doorStatus = DoorStatus.OPENED; } public DoorStatus getDoorStatus() { return doorStatus; } public void close() { if (doorStatus == DoorStatus.CLOSED) return; doClose(); doorStatus = DoorStatus.CLOSED; } protected abstract void doClose(); public void open() { if (doorStatus == DoorStatus.OPENED) return; doOpen(); //이 부분이 제조사마다 다르게 구현됨 doorStatus = DoorStatus.OPENED; } protected abstract void doOpen();}LGDoorpublic class LgDoor extends Door { @Override protected void doClose() { System.out.println(\"Close Lg Door\"); } @Override protected void doOpen() { System.out.println(\"Open Lg Door\"); }}HyundaiDoorpublic class HyundaiDoor extends Door { @Override protected void doClose() { System.out.println(\"Close Lg Door\"); } @Override public void doOpen() { System.out.println(\"Open Lg Door\"); }}DirectionLamppublic abstract class DirectionLamp { private Direction lampStatus; public void light(Direction direction) { if (lampStatus == getLampStatus()) return; doLight(lampStatus); //이 부분이 제조사마다 다르게 구현됨 setLampStatus(lampStatus); } public Direction getLampStatus() { return lampStatus; } public void setLampStatus(Direction lampStatus) { this.lampStatus = lampStatus; } protected abstract void doLight(Direction lampStatus);}LGLamppublic class LgLamp extends DirectionLamp { @Override protected void doLight(Direction direction) { System.out.println(\"Lg Lamp \"+direction); }}HyundaiLamppublic class HyundaiLamp extends DirectionLamp { @Override protected void doLight(Direction direction) { System.out.println(\"Hyundai Lamp \"+direction); }}Elevatorpublic class Elevator { private Motor motor; private Door door; private DirectionLamp lamp; public void setLamp(DirectionLamp lamp) { this.lamp = lamp; } public void setMotor(Motor motor) { this.motor = motor; } public void setDoor(Door door) { this.door = door; } public void move(Direction direction) { motor.move(direction); lamp.doLight(direction); }}Elevatorpublic class ElevatorCreator { public static Elevator assembleElevator() { Elevator elevator = new LgElevator(); Motor motor = new LgMotor(); elevator.setMotor(motor); Door door = new LgDoor(); elevator.setDoor(door); motor.setDoor(door); DirectionLamp lamp = new LgLamp(); elevator.setLamp(lamp); return elevator; } public static void main(String[] args) { Elevator elevator =assembleElevator(); elevator.move(Direction.UP); }}위의 코드에서 만약 Elevator.java에서 LGElevator를 HyundaioElevator로 바꾸게 된다면 기존 코드를 변경해야 되므로 OCP에 위반되는것을 알 수 있다. 따라서 객체 생성을 자식 클래스에서 정의하도록 하기 위해 팩토리 메소드 패턴을 적용하게되면 Elevator Factory는 다음과 같이 구성된다.public class ElevatorFactory { public static Elevator createElevator(VendorId id) { Elevator elevator = null; switch (id) { caseLG: elevator = new LgElevator(); break; caseHYUNDAI:elevator = new HyundaiElevator(); break; } return elevator; }}ElevatorFactory와 마찬가지로 Door, Motor, Lamp도 각각 Factory클래스를 만들고 ElevatorCreator.java는 다음과 같이 구성된다.public class ElevatorCreator { public static Elevator assembleElevator(VendorId id) { Elevator elevator = ElevatorFactory.createElevator(id); Motor motor = MotorFactory.createMotor(id); elevator.setMotor(motor); Door door = DoorFactory.createDoor(id); elevator.setDoor(door); motor.setDoor(door); DirectionLamp lamp = LampFactory.createLamp(id); elevator.setLamp(lamp); return elevator; } public static void main(String[] args) { Elevator elevator =assembleElevator(VendorId.HYUNDAI); elevator.move(Direction.UP); }}But, 만약 새로운 제조업체의 부품을 사용한다면 각각 Factory 클래스에 새로운 제조업체에 대한 객체 생성을 해주어야하고, 만약 엘레베이터에 필요한 부품들이 10개면 Factory 클래스를 10개를 만들어야 된다.그래서, 부품별로 클래스를 구성하는게 아니라 제조업체 별로 팩토리를 정의해야 한다. 이러한 패턴을 추상 팩토리 패턴이다.클래스 다이어그램ElevatorFactorypublic abstract class ElevatorAbstractFactory { public abstract Motor createMotor(); public abstract Door createDoor(); public abstract DirectionLamp createLamp(); public abstract Elevator createElevator();}LGElevatorFactorypublic class LgElevatorFactory extends ElevatorAbstractFactory { @Override public Motor createMotor() { return new LgMotor(); } @Override public Door createDoor() { return new LgDoor(); } @Override public DirectionLamp createLamp() { return new LgLamp(); } @Override public Elevator createElevator() { return new LgElevator(); }}LGDoorpublic class LgDoor extends Door { @Override protected void doClose() { System.out.println(\"Close Lg Door\"); } @Override protected void doOpen() { System.out.println(\"Open Lg Door\"); }}LGMotorpublic class LgMotor extends Motor { @Override protected void moveMotor(Direction direction) { System.out.println(\"Lg motor is Moving \" + direction); }}위와 같이 제조업체별로 팩토리 클래스를 만들고 하위 클래스에서 제조업체의 부품들을 정의해나가면 추상 팩토리 패턴을 적용할 수 있게 된다.ElevatorCreatorpublic class ElevatorCreator { public static Elevator assembleElevator(ElevatorAbstractFactory factory) { Elevator elevator = factory.createElevator(); Motor motor = factory.createMotor(); elevator.setMotor(motor); Door door = factory.createDoor(); elevator.setDoor(door); motor.setDoor(door); DirectionLamp lamp = factory.createLamp(); elevator.setLamp(lamp); return elevator; } public static void main(String[] args) { ElevatorAbstractFactory factory = null; if (args[0].equalsIgnoreCase(\"LG\")) factory = new LgElevatorFactory(); else if (args[0].equalsIgnoreCase(\"Hyundai\")) factory = new HyundaiElevatorFactory(); else factory = new SamsungElevatorFactory(); Elevator elevator =assembleElevator(factory); elevator.move(Direction.UP); }}팩토리 메소드 패턴은 한 종류의 객체를 생성하기 위해 사용되지만, 추상 팩토리 메소드는 연관되거나 의존적인 객체로 이루어진 여러 종류의 객체를 생성하기 위해 생성된다.추상 팩토리 패턴은 이와 같이 관련성 있는 여러 종류의 객체를 일관된 방식으로 생성하는 경우에 유용하다. AbstractFactory : 실제 팩토리 클래스의 공통 인터페이스. 각 제품의 부품을 생성하는 기능을 추상 메소드로 정의한다. ConcreteFactory : 구체적인 팩토리 클래스로 AbstractFactory 클래스의 추상 메소드를 오버라이딩함으로써 구체적인 제품을 생성한다. AbstractProduct : 제품의 공통 인터페이스 ConcreteProduct : 구체적인 팩토리 클래스에서 생성되는 구체적인 제품📖 references 정인상, 「JAVA 객체지향 디자인 패턴」, 한빛미디어" }, { "title": "[Design Pattern] 템플릿 메서드 패턴", "url": "/posts/Template_method_Pattern/", "categories": "Design Pattern", "tags": "java, design pattern", "date": "2022-12-17 00:00:00 +0800", "snippet": "객체의 연산에는 알고리즘의 뼈대만 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미룬다. 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단계를 서브 클래스에서 재정의할 수 있게 해주는 패턴템플릿 메소드 패턴이 어떻게 적용 되는지 알기 위해 엘레베이터 제어 시스템에서 모터를 구동시키는 기능을 예로 들어 보자현재 모터를 이용하는 제어 ...", "content": "객체의 연산에는 알고리즘의 뼈대만 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스 쪽으로 미룬다. 알고리즘의 구조 자체는 그대로 놔둔 채 알고리즘 각 단계를 서브 클래스에서 재정의할 수 있게 해주는 패턴템플릿 메소드 패턴이 어떻게 적용 되는지 알기 위해 엘레베이터 제어 시스템에서 모터를 구동시키는 기능을 예로 들어 보자현재 모터를 이용하는 제어 시스템이 잇고 HyundaiMotor 클래스에 move 메서드를 정의할 수 있다. HyundaiMotor : 모터의 구동을 제어하여 엘레베이터를 이동시키는 기능 Door : 문을 열거나 닫는 기능을 제공클래스 다이어그램또한 엘레베이터의 이동방향(위, 아래)과 모터의 상태(정지, 이동 중), 문의 상태(닫힘, 열림)를 나태내주는 변수들이 필요하므로 이 변수들을 enum class에 따로 생성하게 되면 다음과 같다.public enum DoorStatus { CLOSED, OPENED }public enum MotorStatus { MOVING, STOPPED}public enum Direction {UP, DOWN};이 예제에서 동작 순서를 설명하면 HyundaiMotor 클래스에 move() getMotorStatus()를 호출해 모터의 상태를 확인한다. 만약 모터가 동작 중이면 move()는 return후 종료하게 된다. Door 클래스에 getDoorStatus()를 호출해 문의 상태를 확인한다. 만약 문이 열려 있다면 Door 클래스에 close()를 호출해 문을 닫는다. moveHyundaiMotor()를 호출해 모터를 구동시키고, setMotorStatus()를 호출해 모터의 상태를 MOVING으로 바꾼다.Doorpublic class Door { private DoorStatus doorStatus ; public Door() { doorStatus = DoorStatus.CLOSED ; } public DoorStatus getDoorStatus() { return doorStatus ; } public void close() { doorStatus = DoorStatus.CLOSED ; } public void open() { doorStatus = DoorStatus.OPENED ; } }HyundaiMotorpublic class HyundaiMotor { private Door door; private MotorStatus motorStatus; public HyundaiMotor(Door door) { this.door = door; motorStatus = MotorStatus.STOPPED; // 초기에는 멈춘 상태 } private void moveHyundaiMotor(Direction direction) { // Hyundai Motor를 구동시킨다. } public MotorStatus getMotorStatus() { return motorStatus; } private void setMotorStatus(MotorStatus motorStatus) { this.motorStatus = motorStatus; } public void move(Direction direction) { MotorStatus motorStatus = getMotorStatus(); if (motorStatus == MotorStatus.MOVING) return; // 이미 이동 중이면 아무 작업을 하지 않음 DoorStatus doorStatus = door.getDoorStatus(); if (doorStatus == DoorStatus.OPENED) door.close(); // 만약 문이 열려 있으면 먼저 문을 닫음 moveHyundaiMotor(direction); // 모터를 주어진 방향으로 이동 setMotorStatus(MotorStatus.MOVING); // 모터 상태를 이동 중으로 변경함 }}public class Main{\tpublic static void main(String[] args) { Door door = new Door() ; HyundaiMotor hyundaiMotor = new HyundaiMotor(door) ; hyundaiMotor.move(Direction.UP) ; }}But,만약 hyundaiMotor말고 다른 회사의 모터를 사용하게 된다면?LGMotor클래스를 만들어 다른 회사 모터를 사용하게 되면 다음 코드와 같다.LGMotorpublic class LGMotor { private Door door ; private MotorStatus motorStatus ; public LGMotor(Door door) { this.door = door ; motorStatus = MotorStatus.STOPPED ; } private void moveLGMotor(Direction direction) { // LG Motor를 구동시킴 } public MotorStatus getMotorStatus() { return motorStatus; } private void setMotorStatus(MotorStatus motorStatus) { this.motorStatus = motorStatus; } public void move(Direction direction) { MotorStatus motorStatus = getMotorStatus() ; if ( motorStatus == MotorStatus.MOVING ) return ; DoorStatus doorStatus = door.getDoorStatus() ; if ( doorStatus == DoorStatus.OPENED ) door.close() ; moveLGMotor(direction) ; // move 메서드는 이 문장을 제외하면 HyundaiMotor와 동일함 setMotorStatus(MotorStatus.MOVING) ; } }여기서 LGMotor 클래스와 HyndaiMotor 클래스를 비교해보면 여러 개의 메소드가 동일한 코드로 구성되어 두개의 클래스는 많은 중복 코드를 가져 문제가 생기게 된다.!중복을 최소한으로 줄이기 위해 중복되는 부분을 추상화시켜 상속을 이용해 문제를 해결할 수 있다.따라서 중복되는 부분의 코드를 따로 Moto라는 추상클래스로 나누게 되면 코드는 다음과 같다.Motorpublic abstract class Motor { // HyundaiMotor와 LGMotor에 공통적인 기능을 구현하는 클래스 protected Door door ; private MotorStatus motorStatus ; public Motor(Door door) { this.door = door ; motorStatus = MotorStatus.STOPPED ; } public MotorStatus getMotorStatus() { return motorStatus; } protected void setMotorStatus(MotorStatus motorStatus) { this.motorStatus = motorStatus; } }HyundaiMotorpublic class HyundaiMotor extends Motor { // Motor를 상속받아서 HyundaiMotor를 구현함 public HyundaiMotor(Door door) { super(door) ; } private void moveHyundaiMotor(Direction direction) { // Hyundai Motor를 구동시킨다. } public void move(Direction direction) { MotorStatus motorStatus = getMotorStatus() ; if ( motorStatus == MotorStatus.MOVING ) return ; DoorStatus doorStatus = door.getDoorStatus() ; if ( doorStatus == DoorStatus.OPENED ) door.close() ; moveHyundaiMotor(direction) ; // move 메서드는 이 구문을 제외하면 LGMotor와 동일함 setMotorStatus(MotorStatus.MOVING) ; }}LGMotorpublic class LGMotor extends Motor { public LGMotor(Door door) { super(door) ; } private void moveLGMotor(Direction direction) { // LG Motor를 구동시킨다. } public void move(Direction direction) { MotorStatus motorStatus = getMotorStatus() ; if ( motorStatus == MotorStatus.MOVING ) return ; DoorStatus doorStatus = door.getDoorStatus() ; if ( doorStatus == DoorStatus.OPENED ) door.close() ; moveLGMotor(direction) ; // move 메서드는 이 구문을 제외하면 HyundaiMotor와 동일함 setMotorStatus(MotorStatus.MOVING) ; }}이렇게 보면 두 코드가 중복되는게 없어 보이지만 HudaniMotor 클래스 move()와 LGMotor 클래스 move()의 로직을 보면 이 메소드도 대부분 구조가 비슷하여 코드가 중복되는것을 알 수 있다. 즉, move()에서 moveHyundaiMotor()와 moveLGMotor() 메소드 호출하는 구문을 제외하면 두 클래스의 move()는 동일하다. 따라서 move()를 상위 Motor클래스로 이동시키고 다른 구문, 즉, moveHyudaniMotor()와 moveLGMotor() 호출 부분을 하위 클래스에서 재정의하는 방식으로 코드를 수정해야 코드의 중복을 줄일 수 있게 된다.클래스 다이어그램Motorpublic abstract class Motor { private Door door; private MotorStatus motorStatus; public Motor(Door door) { this.door = door; motorStatus = MotorStatus.STOPPED; } public MotorStatus getMotorStatus() { return motorStatus; } private void setMotorStatus(MotorStatus motorStatus) { this.motorStatus = motorStatus; } public void move(Direction direction) { // LGMotor와 HyundaiMotor의 move에서 공통만을 가짐 MotorStatus motorStatus = getMotorStatus() ; if (motorStatus == MotorStatus.MOVING) return; DoorStatus doorStatus = door.getDoorStatus(); if (doorStatus == DoorStatus.OPENED) door.close(); moveMotor(direction); // 하위 클래스에서 override됨 setMotorStatus(MotorStatus.MOVING); } protected abstract void moveMotor(Direction direction);}HyudaniMotorpublic class HyundaiMotor extends Motor { public HyundaiMotor(Door door) { super(door); } protected void moveMotor(Direction direction) { // Hyundai Motor를 구동시킨다. } }LGMotorpublic class LGMotor extends Motor { \t\tpublic LGMotor(Door door) {\t\t\tsuper(door); \t\t}\t\tprotected void moveMotor(Direction direction) { // LG Motor를 구동시킨다.\t\t} }위와 같이 전체적으로 동일하면서 부분적으로 다른 구문으로 구성된 메소드의 코드가 중복될때 사용되는 디자인 패턴이 바로 템플릿 메소드 패턴이다. 템플릿 메소드 패턴은 전체적인 알고리즘을 구현하면서 상이한 부분은 하위클래스에서 구현할 수 있도록 해주는 디자인 패턴으로서 전체적인 알고리즘의 코드를 재사용하는데 유용하다. AbstractClass : 템플릿 메소드를 정의하는 클래스. 하위 클래스에 공통 알고리즘을 정의하고 하위 클래스에서 구현될 기능을 primitive 메소드 또는 hook 메소드로 정의하는 클래스. ConcreteClass : 물려받은 primitive 메소드나 hook 메소드를 구현하는 클래스. 상위 클래스에 구현된 템플릿 메소드의 일반적인 알고리즘에서 하위 클래스에 적합하게 primitive 메소드나 hook 메소드를 override하는 클래스.📖 references 정인상, 「JAVA 객체지향 디자인 패턴」, 한빛미디어" }, { "title": "[Design Pattern] 데코레이터 패턴", "url": "/posts/Decorator_Pattern/", "categories": "Design Pattern", "tags": "java, design pattern", "date": "2022-12-17 00:00:00 +0800", "snippet": "데코레이터 패턴은 기본 기능에 추가할 수 있는 기능의 종류가 많은 경우에 각 추가 기능을 Decorator 클래스로 정의한 후 필요한 Decorator 객체를 조합함으로써 추가 기능의 조합을 설계하는 방식데코레이터 패턴을 이해하기 위해 예를 들어보자네비게이션에 도로를 표시하는 기능을 생각해보자. 여기서 기본 기능은 도로를 간단한 선으로 표시하는 것이고...", "content": "데코레이터 패턴은 기본 기능에 추가할 수 있는 기능의 종류가 많은 경우에 각 추가 기능을 Decorator 클래스로 정의한 후 필요한 Decorator 객체를 조합함으로써 추가 기능의 조합을 설계하는 방식데코레이터 패턴을 이해하기 위해 예를 들어보자네비게이션에 도로를 표시하는 기능을 생각해보자. 여기서 기본 기능은 도로를 간단한 선으로 표시하는 것이고, 추가적으로 차선을 표시하는 기능이 있다고 하자.따라서 필요한 클래스는 RoadDisplay : 기본 도로 표시 기능을 제공하는 클래스 RoadDisplayWithLane : 기본 도로 표시에 추가적으로 차선을 표시하는 클래스RoadDisplaypublic class RoadDisplay { // 기본 도로 표시 클래스\tpublic void draw() {\t\tSystem.out.println(\"도로 기본 표시\") ;\t}}RoadDisplayWithLanepublic class RoadDisplayWithLane extends RoadDisplay { // 기본 도로 표시 + 차선 표시 클래스 public void draw() { super.draw(); // 상위 클래스 즉 RoadDisplay의 draw 메서드를 호출해서 기본 도로를 표시 drawLane(); } private void drawLane() { System.out.println(\"차선 표시\") ; }}Mainpublic class Main { public static void main(String[] args) { RoadDisplay road = new RoadDisplay() ; road.draw() ; // 기본 도로만 표시 RoadDisplay roadWithLane = new RoadDisplayWithLane() ; roadWithLane.draw() ; // 기본 도로 + 차선 표시 }}But, 1. 만약 추가적으로 도로표시 기능을 추가하고싶다면? 그리고 추가적으로 여러가지 추가 기능을 조합하여 추가하고싶다면?먼저 1번의 요구사항을 해결하기 위해서는 RoadDisplay를 상속하여 클래스를 생성하면 된다.RoadDisplayWithTrafficpublic class RoadDisplayWithTraffic extends RoadDisplay { public void draw() { super.draw(); drawTraffic(); } private void drawTraffic() { System.out.println(\"교통량 표시\") ; }}문제점 1번의 요구사항은 클래스를 추가하면 문제가 되지 않지만 문제점 2번을 만족하려면 저 각각의 조합마다 클래스를 추가해야 한다. 즉, 이들을 조합하면 많은 수 의 클래스가 설계되어 문제가 된다.이를 해결하기 위해서는 각 추가 기능별로 개별작인 클래스를 설계하고 기능을 조합할 때 각 클래스의 객체 조합을 이용하면 된다.→ 기본기능을 제공하는 클래스와 추가기능을 제공하는 인터페이스를 만들어 기본기능과 추가기능 클래스를 분리한다.클래스 다이어그램의 형태는 다음과 같다. 여기서 Display 인터페이스와 이를 상속받은 DisplayDecorator 간의 연관관계를 맺은 이유는 기본 기능을 제공하는 draw()를 사용하기 위해 상속관계가 아닌 기본기능과 추가기능 간의 연관관계로 관계를 맺은 것이다.Displaypublic abstract class Display { public abstract void draw() ;}RoadDisplaypublic class RoadDisplay extends Display { // 기본 도로 표시 클래스 public void draw() { System.out.println(\"도로 기본 표시\") ; }}DisplayDecorator// 다양한 추가 기능에 대한 공통 클래스public class DisplayDecorator extends Display { private Display decoratedDisplay ; public DisplayDecorator(Display decoratedDisplay) { this.decoratedDisplay = decoratedDisplay ; } public void draw() { decoratedDisplay.draw() ; }}LaneDecoratorpublic class LaneDecorator extends DisplayDecorator { // 차선표시를 축하는 클래스 public LaneDecorator(Display decoratedDisplay) { // 기존 표시 클래스의 설정 super(decoratedDisplay); } public void draw() { super.draw(); // 설정된 기존 표시 기능을 수행 drawLane() ; // 추가적으로 차선을 표시 } private void drawLane() { System.out.println(\"\\t차선 표시\") ; }}TrafficDecoratorpublic class TrafficDecorator extends DisplayDecorator { // 교통량 표시를 추가하는 클래스 public TrafficDecorator(Display decoratedDisplay) { // 기존 표시 클래스의 설정 super(decoratedDisplay); } public void draw() { super.draw(); // 설정된 기존 표시 기능을 수행 drawTraffic() ; // 추가적으로 교통량을 표시 } private void drawTraffic() { System.out.println(\"\\t교통량 표시\") ; }}Mainpublic class Main { public static void main(String[] args) { Display road = new RoadDisplay(); road.draw(); // 기본 도로 표시 Display roadWithLane = new LaneDecorator(new RoadDisplay()); roadWithLane.draw(); // 기본 도로 표시 + 차선 표시 Display roadWithTraffic = new TrafficDecorator(new RoadDisplay()); roadWithTraffic.draw(); // 기본 도로 표시 + 교통량 표시 }}Decorator Pattern Component : 기본 기능을 뜻하는 ConcreteComponent와 추가 기능을 뜻하는 Decorator의 공통 기능을 정의 ConcreteComponent : 기본 기능을 구현하는 클래스 Decorator : 많은 수가 존재하는 구체적인 Decorator의 공통 기능을 제공 ConcreteDecorcator : Decorator의 하위 클래스로 기본 기능에 추가되는 개별적인 기능을 뜻함.📖 references 정인상, 「JAVA 객체지향 디자인 패턴」, 한빛미디어" }, { "title": "[Design Pattern] 옵서버 패턴", "url": "/posts/Observer_Pattern/", "categories": "Design Pattern", "tags": "java, design pattern", "date": "2022-12-16 00:00:00 +0800", "snippet": "옵서버 패턴은 객체 사이에 일 대 다의 의존 관계를 두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴옵서버 패턴이 언제 쓰면 유용한지 알아보기 위해 성적 출력 프로그램으로 예를 들어보자. 성적 출력 프로그램은 점수를 목록 형태로 출력하는 구조를 가지고 있다. Score...", "content": "옵서버 패턴은 객체 사이에 일 대 다의 의존 관계를 두어, 어떤 객체의 상태가 변할 때 그 객체에 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴옵서버 패턴이 언제 쓰면 유용한지 알아보기 위해 성적 출력 프로그램으로 예를 들어보자. 성적 출력 프로그램은 점수를 목록 형태로 출력하는 구조를 가지고 있다. ScoreRecord class : 점수를 저장/관리하는 클래스 DataSheetView class : 점수를 목록형태로 출력하는 클래스ScoreRecordpublic class ScoreRecord { private DataSheetView dataSheetView; private List&lt;Integer&gt; scores = new ArrayList&lt;Integer&gt;(); public void setDataSheetView(DataSheetView dataSheetView) { this.dataSheetView = dataSheetView; } public void addScore(int score){ scores.add(score); dataSheetView.update(); } public List&lt;Integer&gt; getScoreRecord(){ return scores; }}DataSheetViewpublic class DataSheetView { private ScoreRecord scoreRecord; private int viewCount; public DataSheetView(ScoreRecord scoreRecord, int viewCount) { this.scoreRecord = scoreRecord; this.viewCount = viewCount; } public void update(){ List&lt;Integer&gt; record = scoreRecord.getScoreRecord(); displayScores(record, viewCount); } private void displayScores(List&lt;Integer&gt; record, int viewCount) { System.out.println(\"List of \" + viewCount + \" entries\"); for(int i=0; i&lt; viewCount &amp;&amp; i&lt; record.size(); i++){ System.out.println(record.get(i)); } }}Mainpublic class Main { public static void main(String[] args) { ScoreRecord scoreRecord = new ScoreRecord(); DataSheetView dataSheetView = new DataSheetView(scoreRecord, 3); scoreRecord.setDataSheetView(dataSheetView); for(int index = 1; index &lt;=5;index++){ int score = index*10; System.out.println(\"Adding \"+ score); scoreRecord.addScore(score); } }}위와 같이 실행하면 성적들을 리스트 형식으로 출력할 수 있게 된다.But,성적을 다른 방식으로 출력해야 하거나, 성적을 동시에 여러가지 형태로 출력해야한다면?ScoreRecord 클래스를 수정해야하고 다음과 같이 작성할 수 있다.ScoreRecordpublic class ScoreRecord { private MinMaxView minmaxView; private List&lt;DataSheetView&gt; dataSheetViews = new ArrayList&lt;DataSheetView&gt;(); private List&lt;Integer&gt; scores = new ArrayList&lt;Integer&gt;(); public void setMinmaxView(MinMaxView minmaxView) { this.minmaxView = minmaxView; } public void addScore(int score){ scores.add(score);\t\t\t\t//기존 코드 수정 -&gt; OCP 위반 minmaxView.update(); for(DataSheetView dataSheetView : dataSheetViews){ dataSheetView.update(); } } public void addDataSheetView(DataSheetView dataSheetView){ dataSheetViews.add(dataSheetView); } public List&lt;Integer&gt; getScoreRecord(){ return scores; }}MinMaxViewpublic class MinMaxView { private ScoreRecord scoreRecord; public MinMaxView(ScoreRecord scoreRecord) { this.scoreRecord = scoreRecord; } public void update(){ List&lt;Integer&gt; record = scoreRecord.getScoreRecord(); displayScores(record); } private void displayScores(List&lt;Integer&gt; record) { int min = Collections.min(record); int max = Collections.max(record); System.out.println(\"Min\" + min + \" Max\" + max); }}Mainpublic class Main { public static void main(String[] args) { ScoreRecord scoreRecord = new ScoreRecord(); MinMaxView minMaxView = new MinMaxView(scoreRecord); DataSheetView dataSheetView3 = new DataSheetView(scoreRecord, 3); DataSheetView dataSheetView5 = new DataSheetView(scoreRecord, 5); scoreRecord.setMinmaxView(minMaxView); scoreRecord.addDataSheetView(dataSheetView3); scoreRecord.addDataSheetView(dataSheetView5); for(int index = 1; index &lt;=5;index++){ int score = index*10; System.out.println(\"Adding \"+ score); scoreRecord.addScore(score); } }}요구사항에 맞게 변경된 위와 같은 코드를 보면 ScoreRecord 클래스에서 최대/최소 값을 출력하게 하는 방식으로 바뀌어서 minmaxview.update()로 변경 되고, 동시에 여러가지 방식으로 출력하기 위해 for문을 사용해 dataSheetView.update()로 코드가 변경된 것을 볼 수 있다.즉, ScoreRecord 클래스가 변경되므로 OCP에 위반되는것을 알 수 있다.이를 해결 하기 위해 변화되는 것을 식별하면 성적의 통보 대상이 변경될 때 기존 코드가 수정되기 때문에 임의의 데이터가 변경 되었을 때 이에 관심을 가지는 모든 대상 객체에 통보하는 것을 인터페이슬 일반화하는 것이 좋다. 이때 사용하는 것이 observer 패턴이다. observer 인터페이스를 이용하여 데이터가 변경됨을 감지하여 출력 방식에 맞게 해당하는 클래스를 사용하면 된다.Observer 클래스 다이어그램Observer interfacepublic interface Observer { public void update();}DataSheetViewpublic class DataSheetView implements Observer{ private ScoreRecord scoreRecord; private int viewCount; public DataSheetView(ScoreRecord scoreRecord, int viewCount) { this.scoreRecord = scoreRecord; this.viewCount = viewCount; } public void update(){ List&lt;Integer&gt; record = scoreRecord.getScoreRecord(); displayScores(record, viewCount); } private void displayScores(List&lt;Integer&gt; record, int viewCount) { System.out.println(\"List of \" + viewCount + \" entries\"); for(int i=0; i&lt; viewCount &amp;&amp; i&lt; record.size(); i++){ System.out.println(record.get(i)); } }}MinMaxViewpublic class MinMaxView implements Observer{ private ScoreRecord scoreRecord; public MinMaxView(ScoreRecord scoreRecord) { this.scoreRecord = scoreRecord; } public void update(){ List&lt;Integer&gt; record = scoreRecord.getScoreRecord(); displayScores(record); } private void displayScores(List&lt;Integer&gt; record) { int min = Collections.min(record); int max = Collections.max(record); System.out.println(\"Min\" + min + \" Max\" + max); }}ScoreRecordpublic class ScoreRecord { private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); //Observer setter 메소드 public void attach(Observer observer){ observers.add(observer); } public void detach(Observer observer){ observers.remove(observer); } private List&lt;Integer&gt; scores = new ArrayList&lt;Integer&gt;(); public void addScore(int score){ scores.add(score); for(Observer observer : observers){ observer.update(); } } public List&lt;Integer&gt; getScoreRecord(){ return scores; }}Mainpublic class Main { public static void main(String[] args) { ScoreRecord scoreRecord = new ScoreRecord(); Observer minMaxView = new MinMaxView(scoreRecord); Observer dataSheetView3 = new DataSheetView(scoreRecord, 3); Observer dataSheetView5 = new DataSheetView(scoreRecord, 5); scoreRecord.attach(minMaxView); scoreRecord.attach(dataSheetView3); scoreRecord.attach(dataSheetView5); Random random = new Random(); for(int index = 1; index &lt;=5;index++){ int score = random.nextInt(101); System.out.println(\"Adding \"+ score); scoreRecord.addScore(score); } }}위와 같이 코드를 짜면 OCP에 위배되지 않고 코드를 구성할 수 있고 새로운 방식의 출력 방식이 추가되어도 기존 코드에 영향 없이 Observer 인터페이스를 상속하여 출력 방식을 지정해줄 수 있다.그러나 ScoreRecord클래스를 살펴보면 옵서버들을 관리해주는 메소드 즉, attach, detach, update의 메소드들은 ScoreRecord클래스만 관리하는 것이 아닌 데이터를 관리하는 다른 클래스들도 관리하게 된다.따라서 다른 클래스들도 사용할 수 있게 옵서버들 관리하는 인터페이스를 하나 만들어 다른 클래스들도 데이터를 관리 할 수 있게 만들 수 있다.Subject 인터페이스를 구현한 ScoreRecord로 수정하면Subjectpublic abstract class Subject { private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;(); public void attach(Observer observer){ observers.add(observer); } public void detach(Observer observer){ observers.remove(observer); } public void notifyObservers(){ for(Observer observer : observers){ observer.update(); } }}ScoreRecordpublic class ScoreRecord extends Subject{ private List&lt;Integer&gt; scores = new ArrayList&lt;Integer&gt;(); public void addScore(int score){ scores.add(score); notifyObservers(); } public List&lt;Integer&gt; getScoreRecord(){ return scores; }}위와 같은 코드를 보게 되면 Subject 클래스에는 성적 변경에 관심이 있는 대상 객체들의 관리하는것으로 구성하고 ScoreRecord 클래스는 Subject 클래스를 상속받아 scores라는 데이터를 관리하는 클래스가 된다.즉, Subject 클래스는 옵서버 객체를 관리하는 클래스, ScoreRecord 클래스는 변경 관리 대상이 되는 데이터가 있는 클래스가 된다. Subject : 감시자들을 알고 있는 주체. 임의 개수의 감시자 객체는 주체를 감시할 수 있다. 주체는 감시자 객체를 붙이거나 떼는 데 필요한 인터페이스를 제공한다. Observer : 주체에 생긴 변화에 관심 있는 객체를 갱신하는 데 필요한 인터페이스를 정의. 이로써 주체의 변경에 따라 변화되어야 하는 객체들의 일관성을 유지. ConcreteSubject : ConecreteObserver 객체에게 알려주어야 하는 상태를 저장. 이 상태가 변경될 때 감시자에게 변경을 통보 ConcreteObserver : ConcreteSubject 객체에 대한 참조자를 관리. 주체의 상태와 일관성을 유지해야 하는 상태를 저장. 주체의 상태와 감시자의 상태를 일관되게 유지하는 데 사용하는 갱신 인터페이스를 구현옵서버 패턴은 통보 대상 객체의 관리를 Subject 클래스와 Observer 인터페이스로 일반화한다.그러면 데이터 변경을 통보하는 클래스(Concrete Subject)는 통보 대상 클래스/객체(ConcreteObserver)에 대한 의존성을 제거할 수 있다. 결과적으로 옵서버 패턴은 통보 대상 클래스나 대상 객체의 변경에도 ConcreteSubject 클래스를 수정 없이 그대로 사용할 수 있도록 한다.위의 예에 적용하면 ScoreRecord 클래스는 ConcreteSubject의 역할, DataSheetView클래스와 MinMaxView 클래스는 ConcreteObserver 역할을 한다.📖 references 정인상, 「JAVA 객체지향 디자인 패턴」, 한빛미디어" }, { "title": "[Design Pattern] 커멘드 패턴", "url": "/posts/Command_Pattern/", "categories": "Design Pattern", "tags": "java, design pattern", "date": "2022-12-16 00:00:00 +0800", "snippet": "커맨드 패턴은 이벤트가 발생했을 때 실행될 기능이 다양하면서도 변경이 필요한 경우에 이벤트를 발생 시키는 클래스를 변경하지 않고 재사용하고자 할때 사용하는 패턴🚴🏼 눌리면 특정 기능을 수행하는 버튼의 예를 들어보자버튼을 눌렀을 때 램프의 불이 켜지는 프로그램을 개발하려면 버튼이 눌러졌음을 인식하는 Button 클래스, 불을 켜는 기능을 제공하는 Lam...", "content": "커맨드 패턴은 이벤트가 발생했을 때 실행될 기능이 다양하면서도 변경이 필요한 경우에 이벤트를 발생 시키는 클래스를 변경하지 않고 재사용하고자 할때 사용하는 패턴🚴🏼 눌리면 특정 기능을 수행하는 버튼의 예를 들어보자버튼을 눌렀을 때 램프의 불이 켜지는 프로그램을 개발하려면 버튼이 눌러졌음을 인식하는 Button 클래스, 불을 켜는 기능을 제공하는 Lamp 클래스가 필요하다. 그리고 버튼을 눌렀을 때 램프를 켜려면 Button 클래스는 Lamp 객체를 참조해야 한다.Lamppublic class Lamp { public void turnOn() { System.out.println(\"Lamp On\") ; }}Buttonpublic class Button { private Lamp theLamp ; public Button(Lamp theLamp) { this.theLamp = theLamp ; } public void pressed() { theLamp.turnOn() ; }}Mainpublic class Main { public static void main(String[] args) { Lamp lamp = new Lamp() ; Button lampButton = new Button(lamp) ; lampButton.pressed() ; }}But,버튼을 눌렀을 때 다른 기능을 실행할 경우와, 버튼을 누르는 동작에 따라 다른 기능을 실해하는 경우 모두 Button 클래스를 수정해야 된다. 즉, 다른 기능(알람 동작)을 추가하거나 변경할 때 메서드를 변경해야 하므로 OCP를 위배하게 된다.**해결책 버튼은 수행될 기능을 캡슐화된 객체로서 전달 받음 버튼이 눌리면 전달 받은 객체를 호출함으로써 구체적 기능을 수행Command interfacepublic interface Command { abstract public void execute();}public class Lamp { public void turnOn() { System.out.println(\"Lamp On\") ; }}public class LampOnCommand implements Command { // 램프를 켜는 기능의 캡슐화 private Lamp theLamp; public LampOnCommand(Lamp theLamp) { this.theLamp = theLamp ; } public void execute() { theLamp.turnOn() ; }}public class Alarm { public void start() { System.out.println(\"Alarming...\") ; }}public class AlarmOnCommand implements Command { // 알람을 울리는 기능의 캡슐화 private Alarm theAlarm ; public AlarmOnCommand(Alarm theAlarm) { this.theAlarm = theAlarm ; } public void execute() { theAlarm.start() ; }}Buttonpublic class Button { private Command theCommand ; public Button(Command theCommand) { setCommand(theCommand) ; } public void setCommand(Command newCommand) { this.theCommand = newCommand ; } // 버튼이 눌리면 주어진 Command의 execute 메서드를 호출함 public void pressed() { theCommand.execute() ; }}Mainpublic class Main{ public static void main(String[] args) { Lamp lamp = new Lamp() ; Command lampOnCommand = new LampOnCommand(lamp); Button button1 = new Button(lampOnCommand) ; // 램프를 켜는 기능을 설정함 button1.pressed() ; Alarm alarm = new Alarm() ; Command alarmOnCommand = new AlarmOnCommand(alarm) ; // 알람을 울리는 기능을 설정함 Button button2 = new Button(alarmOnCommand) ; button2.pressed() ; button2.setCommand(lampOnCommand) ; // 알람을 울리는 기능을 설정함 button2.pressed() ; }}버튼이 눌렀을 때 필요한 임의의 기능은 Command 인터페이스를 구현한 클래스의 객체를 Button 객체에 설정해서 실핼할 수 있다. 따라서 Button 클래스는 소스코드를 변경하지 않으면서도 다양한 동작을 구현할 수 있다. 커맨드 패턴은 실행될 기능을 캡슐화함으로써 기능의 실행을 요구하는 호출자(Invoker) 클래스와 실제 기능을 실행하는 수신자(Recevier) 클래스 사이의 의존성을 제거한다. 따라서 실행될 기능의 변경에도 호출자 클래스를 수정 없이 그대로 사용할 수 있도록 해준다. Button 클래스는 Invoker 역할을 한다. LampOnCommand와 AlarmOnCommand는 ConcreteCommand 역할을 한다. Lamp 클래스와 Alarm 클래스는 Receiver 역할을 한다.📖 references 정인상, 「JAVA 객체지향 디자인 패턴」, 한빛미디어" }, { "title": "[Design Pattern] 스트래티지 패턴", "url": "/posts/Stategy_Pattern/", "categories": "Design Pattern", "tags": "java, design pattern", "date": "2022-12-15 00:00:00 +0800", "snippet": "스트래티지 패턴은 전략을 쉽게 바꿀 수 있도록 해주는 디자인 패턴이다. 여기에서 전략이란 문제를 해결하는 알고리즘으로 이해할 수 있다. 같은 문제를 해결하는 여러 알고리즘이 클래스 별로 캡슐화 되어 있고 이들이 필요할 때 교체할 수 있도록 함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴Robot 클래스로 예를 들어 보자....", "content": "스트래티지 패턴은 전략을 쉽게 바꿀 수 있도록 해주는 디자인 패턴이다. 여기에서 전략이란 문제를 해결하는 알고리즘으로 이해할 수 있다. 같은 문제를 해결하는 여러 알고리즘이 클래스 별로 캡슐화 되어 있고 이들이 필요할 때 교체할 수 있도록 함으로써 동일한 문제를 다른 알고리즘으로 해결할 수 있게 하는 디자인 패턴Robot 클래스로 예를 들어 보자. 로봇은 아톰과 태권V가 있고, 이 두 로봇은 공격 기능과 이동 기능이 있다. 아톰은 공격할 때 주먹만 사용하지만 하늘을 날 수가 있고 태권V는 미사일로 공격할 수는 있지만 날아다니지 못하고 걷기만 할 수 있다.클래스 다이어그램Robotpublic abstract class Robot { private String name; public Robot(String name){ this.name = name; } public String getName() { return name; }\t\t\t\tpublic abstract void attack();\t\tpublic abstract void move();}TaekwonVpublic class TaekwonV extends Robot{ public TaekwonV(String name) { super(name); } @Override public void attack() { System.out.println(\"I have Missile and can attack with it.\"); } @Override public void move() { System.out.println(\"I can only walk.\"); }}Atompublic class Atom extends Robot{ public Atom(String name) { super(name); } @Override public void attack() { System.out.println(\"I have strong punch and can attack with it.\"); } @Override public void move() { System.out.println(\"I can fly\"); }}Mainpublic class Main { public static void main(String[] args) { Robot r1 = new TaekwonV(\"taekwonV\"); Robot r2 = new Atom(\"atom\");\t\t\t\t\t\t\t\tr1.move();\t\t\t\tr1.attack();\t\t\t\tr2.move();\t\t\t\tr2.attack(); }}TaekwonV와 Atom 클래스는 추상클래스를 상속하여 구현하여 공격과 이동 기능이 있는 로봇을 나타나게 하였다. 아톰과 태권V의 이동 기능과 공격 기능이 서로 다르기 때문에 Robot 클래스에서 attack과 move 메소드를 추상메소드로 설정해 자식클래스에서 각각 정의하도록 하였다.But,만약 아톰이 날수 없고 오직 걷게만 만들고 싶다면 atom 클래스에서 move메소드를 수정해야한다.이는 새로운 기능으로 변경하려고 하면 기존 코드의 내용을 수정해야 해서 OCP(Open Closed Principle)에 위배된다.→ 만약 걷는 방식에 문제가 있거나 새로운 방식으로 수정하려면 모든 중복된 코드를 일관성 있게 변경해야만 한다.해결책이 예제에서 변화되면서 문제를 발생시키는 요인은 로봇의 이동 방식과 공격 방식의 변화다.즉, 새로운 방식의 이동 및 공격 기능이 계속해서 추가될 수 있으므로 기존의 로봇이나 새로운 로봇이 이러한 기능을 별다른 코드 변경 없이 제공받거나 기존의 공격이나 이동 방식을 다른 공격이나 이동 방식으로 쉽게 변경할 수 있어야한다.→ 무엇이 변화되는지를 찾은 후에 이를 클래스로 캡슐화 한다.캡슐화 하기 위해서는 외부에서 구체적인 이동 방식과 공격 방식을 담은 구체적인 클래스들을 은닉해야 한다. 이를 위해 공격과 이동을 위한 인터페이스를 각각 만들고 이들을 실제 실현한 클래스를 만들어야 한다.개선된 클래스 다이어그램Robotpublic abstract class Robot { private String name; private MovingStrategy movingStrategy; private AttackStrategy attackStrategy; public void setMovingStrategy(MovingStrategy movingStrategy) { this.movingStrategy = movingStrategy; } public void setAttackStrategy(AttackStrategy attackStrategy) { this.attackStrategy = attackStrategy; } public void move(){ this.movingStrategy.move(); } public void attack(){ this.attackStrategy.attack(); } public Robot(String name){ this.name = name; } public String getName() { return name; }}MovingStrategy interfacepublic interface MovingStrategy { public void move();}public class FlyingStrategy implements MovingStrategy{ @Override public void move() { System.out.println(\"can fly\"); }}public class WalkingStrategy implements MovingStrategy{ @Override public void move() { System.out.println(\"can only walk\"); }}AttackStrategy interfacepublic interface AttackStrategy { public void attack();}public class MissileStrategy implements AttackStrategy{ @Override public void attack() { System.out.println(\"can bomb\"); }}public class PunchStrategy implements AttackStrategy{ @Override public void attack() { System.out.println(\"Punch\"); }}Mainpublic class Main { public static void main(String[] args) { Robot r1 = new TaekwonV(\"taekwonV\"); Robot r2 = new TaekwonV(\"Atom\"); r1.setAttackStrategy(new MissileStrategy()); r1.setMovingStrategy(new FlyingStrategy()); r1.move(); r1.attack(); r2.setMovingStrategy(new WalkingStrategy()); r2.setAttackStrategy(new PunchStrategy()); r2.move(); r2.attack(); }}위와 같이 strategy pattern으로 작성하면 이들 기능을 이용하는 로봇 객체와는 상관없이 향후 등장할 이동 방식과 공격 방식의 변화뿐만 아니라 현재 변화도 잘 처리할 수 있게 된다. 즉, 새로운 기능의 추가가 기존의 코드에 영향을 미치치 못하게 하므로 OCP를 만족하는 설계가 된다.또한 위와 같은 코드는 외부에서 로봇 객체의 이동 방식과 공경 방식을 임의대로 바꾸도록 해주는 메소드가 추가로 필요하게 된다. 이를 위해 Robot 클래스에 setMovingStrategy와 setAttackStrategy 메소드를 정의해 로봇의 이동 방식과 공격 방식이 필요할 때 바꿀 수 있도록 한다.Strategy - Quicksort or Mergesort [algo change]Command - Open or Close [action change]📖 references 정인상, 「JAVA 객체지향 디자인 패턴」, 한빛미디어" }, { "title": "[Design Pattern] 빌더 패턴", "url": "/posts/Builder_Pattern/", "categories": "Design Pattern", "tags": "java, design pattern", "date": "2022-12-14 00:00:00 +0800", "snippet": "빌더 패턴은 복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리하여 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공하는 패턴book 클래스를 예로 들어 살펴보자생성자의 인자가 많을 경우 일반적인 객체를 생성하는 방식은 다음과 같다.Book(Telescoping Constructor pattern)public cl...", "content": "빌더 패턴은 복잡한 객체를 생성하는 방법과 표현하는 방법을 정의하는 클래스를 별도로 분리하여 서로 다른 표현이라도 이를 생성할 수 있는 동일한 절차를 제공하는 패턴book 클래스를 예로 들어 살펴보자생성자의 인자가 많을 경우 일반적인 객체를 생성하는 방식은 다음과 같다.Book(Telescoping Constructor pattern)public class Book { private Long id; private String isbn; private String title; private String author; private int pages; private String category; public Book(Long id, String isbn) { this.id = id; this.isbn = isbn; } public Book(Long id, String isbn, String title) { this.id = id; this.isbn = isbn; this.title = title; } public Book(Long id, String isbn, String title, String author) { this.id = id; this.isbn = isbn; this.title = title; this.author = author; } public Book(Long id, String isbn, String title, String author, int pages) { this.id = id; this.isbn = isbn; this.title = title; this.author = author; this.pages = pages; } public Book(Long id, String isbn, String title, String author, int pages, String category) { this.id = id; this.isbn = isbn; this.title = title; this.author = author; this.pages = pages; this.category = category; }}그러나 이 방식은 인자가 많을수록 생성자 개수도 많아진다.따라서 생성자의 인자가 어떤 의미인지를 파악하기 힘들며 가독성이 떨어지게 된다.JavaBeans Pattern→ Setter 메소드로 각 속성의 값을 설정Bookpublic class Book{ public Book() { } public void setId(Long id) { this.id = id; } public void setIsbn(String isbn) { this.isbn = isbn; } public void setTitle(String title) { this.title = title; } public void setAuthor(String author) { Author = author; } public void setPages(int pages) { this.pages = pages; } public void setCategory(String category) { this.category = category;}}Mainpublic class Main { public static void main(String[] args) { Book book1 = new Book(1L, \"isbn1234\");\t\t\tbook1.setCategory(\"CE\"); }}javaBeans 방식을 사용하면 가독성은 향상되나 immutable object를 만들수 없다.immutable 객체란 외부에서 값을 변경할수 있는 객체를 뜻한다.Builder Pattern다음의 3가지 상황이 필요할 떄 빌더 패턴이 효과적이다. 생성자의 인자가 많거나 생성자의 인자들 중에 필수적 인자와 선택적 인자가 혼합되어 있는 경우 immtuable 객체를 생성Bookpublic class Book { private Long id; private String isbn; private String title; private String author; private int pages; private String category; public Long getId() { return id; } public String getIsbn() { return isbn; } public String getTitle() { return title; } public String getAuthor() { return author; } public int getPages() { return pages; } public String getCategory() { return category; } public static class BookBuilder { private Long id; private String isbn; private String title; private String author; private int pages; private String category; public BookBuilder(Long id, String isbn) { this.id = id; this.isbn = isbn; } public BookBuilder Id(Long id) { this.id = id; return this; } public BookBuilder ISbn(String isbn) { this.isbn = isbn; return this; } public BookBuilder title(String title) { this.title = title; return this; } public BookBuilder author(String author) { this.author = author; return this; } public BookBuilder pages(int pages) { this.pages = pages; return this; } public BookBuilder category(String category) { this.category = category; return this; } public Book build() { Book book = new Book(); book.id = this.id; book.isbn = this.isbn; book.author = this.author; book.title = this.title; book.pages = this.pages; book.category = this.category; return book; } }}Mainpublic class Main { public static void main(String[] args) { Book book1 = new Book.BookBuilder(1L, \"isb1234\") .author(\"sanguining\") .pages(360).category(\"CE\") .title(\"Design Pattern\").category(\"CE\") .build(); System.out.println(book1.getAuthor()); }}→ builder 패턴을 적용하여 객체를 생성하게 되면 가독성이 개선되고, 메소드 체인닝과 immutable 객체를 생성할 수 있게 된다.Lombok Builder Pattern@builder 어노테이션 사용Bookimport lombok.Builder;import lombok.Getter;import lombok.NonNull;@Builder@Getterpublic class Book { @NonNull private Long id; @NonNull private String isbn; private String title; private String author; private int pages; private String category;}MainBook book1 = new Book.BookBuilder().id(2L) .isbn(\"isbn1234\") .author(\"sanguining\") .pages(360).category(\"CE\") .title(\"Design Pattern\").category(\"CE\") .build(); System.out.println(book1.getAuthor());📖 references 정인상, 「JAVA 객체지향 디자인 패턴」, 한빛미디어" }, { "title": "[Design Pattern] 싱글톤 패턴", "url": "/posts/Singleton_Pattern/", "categories": "Design Pattern", "tags": "java, design pattern", "date": "2022-12-13 00:00:00 +0800", "snippet": "싱글턴 패턴은 인스턴스가 오직 하나만 생성되는 것을 보장하고 어디에서든 이 인스턴스에 접근할 수 있도록 하는 디자인 패턴싱글턴 패턴이 왜 쓰는지 알기 위해 예를 통해 살펴보자ex) 공통 로그 파일에 모든 사용자 계좌의 입금/출금의 발생 내역을 기록Account, Logger 클래스Accountpublic class Account { private...", "content": "싱글턴 패턴은 인스턴스가 오직 하나만 생성되는 것을 보장하고 어디에서든 이 인스턴스에 접근할 수 있도록 하는 디자인 패턴싱글턴 패턴이 왜 쓰는지 알기 위해 예를 통해 살펴보자ex) 공통 로그 파일에 모든 사용자 계좌의 입금/출금의 발생 내역을 기록Account, Logger 클래스Accountpublic class Account { private String owner; private int balance; private Logger myLogger; public Account(String owner, int balance) { this.owner = owner; this.balance = balance; this.myLogger = new Logger(); } public String getOwner() { return owner; } public int getBalance() { return balance; } public void deposit(int money) { myLogger.log(\"owner\" + \" : \" + this.getOwner() + \" deposit \" + money); balance += money; } public void withdraw(int money) { if (balance &gt;= money) { myLogger.log(\"owner\" + \" : \" + this.getOwner() + \" withdraw \" + money); balance -= money; } }}Account는 계좌를 생성하여 입금과 출금 기능을 제공한다.Loggerpublic class Logger { private final String LOGFILE = \"log.txt\"; private PrintWriter writer; public Logger() { try { FileWriter fw = new FileWriter(LOGFILE); writer = new PrintWriter(fw, true); } catch (IOException e) { } } public void log(String message) { SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd 'at' HH:mm:ss z\"); Date date = new Date(System.currentTimeMillis()); writer.println(formatter.format(date) + \" : \" + message); }}Logger 클래스는 log.txt파일에 입금/출금 내역을 기록하는 일을 수행한다.Mainpublic class Main { public static void main(String[] args) { Account acct1 = new Account(\"dong1\", 1000000); acct1.deposit(20000); Account acct2 = new Account(\"dong2\", 2000000); acct2.withdraw(5000); }}dong1과 dong2의 계좌를 생성하여 입금과 출금을 기록하는 일을 수행한다.실행결과 → dong1의 입금 내역이 누락되어 dong2의 출금내역만 log.txt에 출력된것을 볼 수 있다.이는 하나의 인스턴스를 공유하는 것이 아닌 dong1과 dong2의 인스턴스를 각각 생성했기에 발생한 문제이다.해결책 모든 Account 인스턴스가 하나의 Logger 인스턴스를 공유하도록 만들어야한다. 이를 위해 account 클래스를 수정하여 해결한다.Accountpublic class Account { private String owner; private int balance; private Logger myLogger;\t\t//Logger 인스턴스 생성 부분을 제거 public Account(String owner, int balance) { this.owner = owner; this.balance = balance; } public String getOwner() { return owner; } public int getBalance() { return balance; } public void deposit(int money) { myLogger.log(\"owner\" + \" : \" +this.getOwner() + \" deposit \" + money); balance += money; } public void withdraw(int money) { if (balance &gt;= money) { myLogger.log(\"owner\" + \" : \" +this.getOwner() + \" withdraw \" + money); balance -= money; } } public void setMyLogger(Logger myLogger) { this.myLogger = myLogger; }}Mainpublic class Main { public static void main(String[] args) { Logger logger = new Logger(); Account acct1 = new Account(\"insang1\", 1000000); acct1.setMyLogger(logger); acct1.deposit(20000); Account acct2 = new Account(\"insang2\", 2000000); acct2.setMyLogger(logger); acct2.withdraw(5000); }}실행결과but, 위와 같은 코드로 작성하게 되면 Logger 인스턴스를 외부에서 여러개 생성할 수 있게 된다. 따라서 외부에서 여러개 생성못하도록 막아야한다.해결책 클래스가 하나의 인스턴스만을 가지도록 만드는 패턴을 싱글턴 패턴이라고 하며, 외부에서 생성자를 여러개 생성못하게 막고, 오직 하나의 인스턴스를 생성할 수 있게 해준다.싱글턴 패턴 static 변수 instance 선언 생성자를 private으로 선언 Logger 인스턴스를 생성 및 반환하는 getInstance() 메소드 정의Accountpublic class Account { private String owner; private int balance; private Logger myLogger; public Account(String owner, int balance) { this.owner = owner; this.balance = balance; this.myLogger = Logger.getInstance(); } public String getOwner() { return owner; } public int getBalance() { return balance; } public void deposit(int money) { myLogger.log(\"owner\" + \" : \" + this.getOwner() + \" deposit \" + money); balance += money; } public void withdraw(int money) { if (balance &gt;= money) { myLogger.log(\"owner\" + \" : \" + this.getOwner() + \" withdraw \" + money); balance -= money; } }}Loggerpublic class Logger { private final String LOGFILE = \"log.txt\"; private PrintWriter writer; private static Logger instance; public Logger() { try { FileWriter fw = new FileWriter(LOGFILE); writer = new PrintWriter(fw, true); } catch (IOException e) { } } public void log(String message) { SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd 'at' HH:mm:ss z\"); Date date = new Date(System.currentTimeMillis()); writer.println(formatter.format(date) + \" : \" + message); } public static Logger getInstance(){ if(instance== null)\t\t\t\t\t\tinstance= new Logger(); return instance; }}Mainpublic class Main { public static void main(String[] args) { Account acct1 = new Account(\"dong1\", 1000000); acct1.deposit(20000); Account acct2 = new Account(\"dong2\", 2000000); acct2.withdraw(5000); }}실행결과→ 하나의 Logger 인스턴스를 공유해 문제없이 잘 수행된다.다중스레드에서의 싱글턴 패턴 위의 예제에서 싱글턴 패턴을 적용하여 하나의 Logger 인스턴스를 생성하여 공유하도록 설계가 가능했지만 이는 다중스레드에서는 적용이 되지 않는다. 왜냐하면 각각의 스레드들이 여러개의 인스턴스를 생성하기 때문이다.Userpublic class User extends Thread { public User(String name) { super(name); } public void run() { Random r = new Random(); Account acct = new Account(Thread.currentThread().getName(), r.nextInt(1000000)); if (r.nextBoolean()) acct.withdraw(r.nextInt(acct.getBalance())); else acct.deposit(r.nextInt(acct.getBalance())); }}Mainpublic class Main { public static void main(String[] args) { User[] users = new User[10]; for (int i = 0; i &lt; 10; i++) { users[i] = new User(\"dong\"+i); users[i].start(); } }}실행결과→ 위의 실행결과와 같이 다중스레드 환경에서는 하나의 내역만 출력되고 인스턴스는 여러개가 생성된것을 알 수 있다.해결책 Synchronized DCL(Double Checked Locking) Initialization on demand holder idiom1. Synchronized→ synchronized를 이용해 race condition이 발생하지 않게 만든다.Loggerpublic class Logger { private final String LOGFILE = \"log.txt\"; private PrintWriter writer; private static Loggerinstance; private Logger() { try { FileWriter fw = new FileWriter(LOGFILE); writer = new PrintWriter(fw, true); } catch (IOException e) { } } //Logger 메서드에 synchronized 추가 public synchronized static Logger getInstance() { if (instance== null)\t\t\t\t\t\tinstance= new Logger(); return instance; } public void log(String message) { System.out.println(this.toString()); SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd 'at' HH:mm:ss z\"); Date date = new Date(System.currentTimeMillis()); writer.println(formatter.format(date) + \" : \" + message); }}syncrhonized로 해결 가능하지만 synchronized 사용 시 내부적으로 많은 cost가 발생하고 많은 thread 들이 getInstance()를 호출하게 되면 프로그램 전반적인 성능저하가 발생2. DCL(Double Checked Locking)→ synchronized의 비효율성을 해결하기 위해 dcl기법을 적용해 instance가 생성되었는지를 두번 체크하는 로직이다.Loggerpublic class Logger { private final String LOGFILE = \"log.txt\"; private PrintWriter writer; private volatile static Loggerinstance; private Logger() { try { FileWriter fw = new FileWriter(LOGFILE); writer = new PrintWriter(fw, true); } catch (IOException e) { } } public static Logger getInstance() { if (instance== null) { synchronized (Logger.class) { if (instance== null) {\t\t\t\t\t\t\t\t\t\tinstance= new Logger(); } } } return instance; } public void log(String message) { System.out.println(this.toString()); SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd 'at' HH:mm:ss z\"); Date date = new Date(System.currentTimeMillis()); writer.println(formatter.format(date) + \" : \" + message); }}dcl 기법으로 보완은 가능하지만 명령어 reorder가 발생할 수 있어 미완성 인스턴스가 다른 스레드에게서 생성 될 수 있다.3. Initialization on demand holder idiom→ 앞서 dcl 기법과 synchronzied 기법을 안쓰고 동시성 문제를 해결할 수 있다.Loggerpublic class Logger { private final String LOGFILE = \"log.txt\"; private PrintWriter writer; public Logger() { try { FileWriter fw = new FileWriter(LOGFILE); writer = new PrintWriter(fw, true); } catch (IOException e) {} } public void log (String message) { System.out.println(this.toString()); SimpleDateFormat formatter= new SimpleDateFormat(\"yyyy-MM-dd 'at' HH:mm:ss z\"); Date date = new Date(System.currentTimeMillis()); writer.println(formatter.format(date) + \" : \" + message); } private static class LazyHolder { public static final LoggerINSTANCE= new Logger(); } public static Logger getInstance() { return LazyHolder.INSTANCE; }}현재까지 가장 많이 사용되는 방법이며 Singleton 클래스에는 LazyHolder 클래스의 변수가 없기 때문에 Singleton 클래스 로딩 시 LazyHolder 클래스를 초기화하지 않는다.또한 Class를 로딩하고 초기화하는 시점은 thread-safe를 보장하고 holder 안에 선언된 instance가 static이기 때문에 클래스 로딩 시점에 한번만 호출→final을 써서 다시 값이 할당되지 않도록 함정적 클래스를 이용하여 싱글턴 패턴을 이용할 수 있지만 가장 차이나는 점은 정적 클래스를 이용하면 객체를 전혀 생성하지 않고 메서드를 사용한다는 점이다 → but, 인터페이스의 경우 정적 메서드는 사용 불가하기 때문에 사용할 수 없는 경우가 있다.싱글턴 생성 방식 2가지1. Eager initialization2. Lazy initializationEager initialization→ 싱글톤 객체를 미리 생성하는 기본적인 Singleton 방식public class Logger { private final String LOGFILE = \"log.txt\"; private PrintWriter writer; private static Loggerinstance= new Logger(); private Logger() { try { FileWriter fw = new FileWriter(LOGFILE); writer = new PrintWriter(fw, true); } catch (IOException e) {} } public static Logger getInstance() { returninstance; } public void log (String message) { SimpleDateFormat formatter= new SimpleDateFormat(\"yyyy-MM-dd 'at' HH:mm:ss z\"); Date date = new Date(System.currentTimeMillis()); writer.println(formatter.format(date) + \" : \" + message); }} 클래스 로딩 시점에 초기화되어 인스턴스가 필요하지 않는 경우에도 생성 → 따라서 인스턴스가 필요할 떄 생성하는 lazy initialization을 써야한다. Lazy initializationpublic class Logger { private final String LOGFILE = \"log.txt\"; private PrintWriter writer; private static Loggerinstance; private Logger() { try { FileWriter fw = new FileWriter(LOGFILE); writer = new PrintWriter(fw, true); } catch (IOException e) {} } public static Logger getInstance() { if (instance== null)instance= new Logger(); returninstance; } public void log (String message) { SimpleDateFormat formatter= new SimpleDateFormat(\"yyyy-MM-dd 'at' HH:mm:ss z\"); Date date = new Date(System.currentTimeMillis()); writer.println(formatter.format(date) + \" : \" + message); }}📖 references정인상, 「JAVA 객체지향 디자인 패턴」, 한빛미디어" }, { "title": "[Design Pattern] SOLID 원칙", "url": "/posts/SOLID/", "categories": "Design Pattern", "tags": "java, design pattern", "date": "2022-12-12 00:00:00 +0800", "snippet": "로버트 마틴이 주장한 5가지의 설계원칙SRP(Single Responsbility Principle)객체지향 설계 관점에서는 SRP에서 말하는 책임의 기본 단위는 객체를 말한다. 즉, 객체는 단 하나의 책일만 가져야 한다는 의미다.책임이란?→ 해야 하는 것, 할 수 있는것으로 객체에 책임을 할당할 때는 어떤 객체보다도 작업을 잘할 수 있는 객체에 할당...", "content": "로버트 마틴이 주장한 5가지의 설계원칙SRP(Single Responsbility Principle)객체지향 설계 관점에서는 SRP에서 말하는 책임의 기본 단위는 객체를 말한다. 즉, 객체는 단 하나의 책일만 가져야 한다는 의미다.책임이란?→ 해야 하는 것, 할 수 있는것으로 객체에 책임을 할당할 때는 어떤 객체보다도 작업을 잘할 수 있는 객체에 할당해야 한다.예를 들어 Student 클래스가 수강 과목을 추가하거나 조회하고, 데이터베이스에 객체 정보를 저장하거나 데이터베이스에서 객체 정보를 읽는 작업도 처리하고, 성적표와 출석부에 출력하는 일도 실행한다고 가정하자. 그럼 코드는 다음과 같다.public class Stduent{\t\tpublic void getCourses() {...}\t\tpublic void addCourse(Course c) {...}\t\tpublic void save() {...}\t\tpublic Student load() {...}\t\tpublic void printOnReportCard() {...}\t\tpublic void printOnAttenddanceBook() {...}}지금 이대로라면 Student 클래스에는 너무나 많은 책임을 수행해야 한다. 즉, Student 클래스에는 단한가지 일만 할 수 있도록 단 나의 책임만 가져야 한다. 책임은 또한 변경이유라고 해석할 수 있으며 만약 학생 정보를 성적표와 출석부 이외에 형식으로 출력한다면 Student 클래스도 변경 되어야 하기 때문에 한 책임은 변화의 이유로도 볼 수 있다.따라서 Student 클래스는 책임을 분리해서 SRP를 적용해야 하며 Student 클래스의 경우 학생 고유의 역할을 수행하게끔 Student 클래스를 수정해야 한다.public class Stduent{\t\tpublic Student load() {...}}OCP(Open Closed Principle)기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다는 원칙Student 클래스로 예를 들어보면만약 이 구조에서 출력형식을 json으로 바꾸게된다면?그러면 Studnet 클래스에서 코드를 수정해야 하며 OCP원칙에 어긋나게 된다. 따라서 OCP를 만족하는 설계가 되기 위해서는 다음과 같은 단계를 거치면 된다. 변화되는것을 식별 변화되는것을 클래스로 분리 변하는것을 포용하는 개념인 추상클래스나 인터페이스로 추상화한다. 추상클래스나 인터페이스를 이용하여 자식클래스로 모델링한다.위의 Student 클래스에서 변화되는것은 출력하는 방식으로 print()가 변경 되므로 이것을 클래스로 분리시킨다. 그런후 변화되는것을 포용하는 개념인 Printer라는 인터페이스를 만든 후 적용하면 다음과 같다.위와 같이 변화되는것을 식별하고 인터페이스를 만든 후 자식클래스에서 구현하도록 만들면 OCP 원칙에 만족하는 설계가 된다.LSP(Liskov Substitution Principle)일반화 관계를 적절하게 사용했는지를 점검하는 원칙다음 정렬하는 예제를 살펴보면public class MinMax {\t\tpublic ArrayList&lt;Integer&gt; mimax(ArrayList&lt;Integer&gt; a) {\t\t\tint minValue;\t\t\tint maxValue;\t\t\tArrayList&lt;Integer&gt; b;\t\t\tb=a;\t\t\tminValue = Collections.min(a);\t\t\tmaxValue = Collections.max(a);\t\t\tb.set(0, minValue);\t\t\tb.set(a.size()-1, maxValue);\t\t\treturn b;\t\t}}public class MinMax1 extends MinMax{\t\tpublic ArrayList&lt;Integer&gt; mimax(ArrayList&lt;Integer&gt; a){\t\t\t\tint minValue;\t\t\t\tint maxValue;\t\t\t\tArrayList&lt;Integer&gt; b;\t\t\t\tminValue = Collections.min(a);\t\t\t\tmaxValue = Collections.min(a);\t\t\t\tb.set(0, minValue);\t\t\t\tb.set(a.size()-1, maxValue);\t\t\t\treturn b;\t\t}}MinMax 클래스와 MinMax1 클래스를 보면 MinMax 클래스는 가장 큰값과 가장 작은값을 출력하는 반면 MinMax1은 가장 작은값만 출력한다. 즉, MinMax1은 MinMax 클래스를 상속하여 구현하였지만 부모 클래스와 결과가 달라 이둘은 행위적으로 일관성이 없게 된다. 따라서 LSP를 만족하려면 자식클래스도 부모클래스와 같이 가장 큰값과 가장 작은 값을 출력하도록 설계를 해야 한다.ISP(Interface Seperate Principle)인터페이스를 클라이언트에 특화시키도록 분리시키는 설계 원칙복합기 기능을 제공하는 클래스로 예를 들어보자public interface PrintingService { public void print(); public void fax(); public void copy();}PrintingServie를 이용해 구현한 복합기 클래스public class HansungPrinter implements PrintingService { @Override public void print() { System.out.println(\" 한성프린터 출력\"); } @Override public void fax() { throw new UnsupportedOperationException(\"Not Supported\"); } @Override public void copy() { throw new UnsupportedOperationException(\"Not Supported\"); }}위 클래스를 보면 HansungPrinter는 fax기능과 copy기능을 사용하지 않고 상속되는 문제가 발생하게 된다. 그래서 만약 HansungPrinter가 제공하지 않는 fax()나 copy() 인터페이스에 변화가 생긴다면 변경으로 인해 발생하는 문제의 영향을 받지 않도록 해야한다. (예를 들어 copy(int pages) 처럼 copy() 연산에 복사할 페이지 수를 인자로 요구하도록 변경)즉, ISP는 인터페이스를 클라이언트에 특화되도록 분리시키는 원칙이므로 위의 예제를 ISP를 만족하게 설계하면 다음과 같은 구조로 이루질 수 있다.DIP(Dependency Inversion Principle)상위 모듈은 하위 모듈에 의존하면 안되며 이 두 모듈 모두 다른 추상화된 것에 의존해야 하고 구체적인 것이 추상화된 것에 의존해야 한다는 원칙의존 관계를 설정할 때에는 구체적인 클래스 보다는 이를 추상화한 개념과 인터페이스 같은 수단을 이용하여 관계를 맺도록 설계해야 한다.DIP가 적용되기 전의 클래스 다이어그램을 보면위와 같은 설계는 상위모듈이 하위모듈에 의존관계가 생기게 되어 만약 하위모듈이 변화된다면 자연스럽게 상위 모듈도 변경해야 되어 DIP를 만족하지 못하는 설계가 되어버린다. 따라서 상위모듈과 하위모듈 모두 인터페이스 즉 추상화된것에 의존관계를 맺도록 의존관계를 역전 시키게 설계해야 DIP를 만족하게 된다.DIP를 만족한 설계위와 같이 상위모듈과 하위모듈 모두 추상화된것에 의존하게 되며 DIP를 만족하게 된다.📖 references정인상, 「JAVA 객체지향 디자인 패턴」, 한빛미디어" }, { "title": "[프로젝트] marvel_website", "url": "/posts/marvel_site/", "categories": "Project", "tags": "html, css, javascript, api", "date": "2022-01-27 00:00:00 +0800", "snippet": "api 호출을 이용한 반응형 웹페이지 마블 사이트주요 사용 기술 HTML CSS javascript이번에 html, css ,js를 공부하면서 한번 웹사이트를 만들어보고 싶어 마침 api중에 marvel 정보를 주는 api가 있어서 마블 정보를 주는 사이트를 한번 만들어 보았다.내가만든 마블 웹사이트 ↓ ↓ ↓https://dj-marvel-s...", "content": "api 호출을 이용한 반응형 웹페이지 마블 사이트주요 사용 기술 HTML CSS javascript이번에 html, css ,js를 공부하면서 한번 웹사이트를 만들어보고 싶어 마침 api중에 marvel 정보를 주는 api가 있어서 마블 정보를 주는 사이트를 한번 만들어 보았다.내가만든 마블 웹사이트 ↓ ↓ ↓https://dj-marvel-site.netlify.app웹사이트는 모바일 버전에서도 볼 수 있게 반응형 웹사이트로 만들었고 공부한 내용들을 전체적으로 사용할 수 있었다.소스코드 ↓ ↓ ↓Github 바로가기!메인 화면 모습카테고리는 캐릭터, 시리즈, 스토리, 만화 그리고 사건으로 구성되고각 카테고리를 누르면 topic에 맞게 api를 호출한다.카테고리별 화면그런데 getdata()함수에서 api를 하려고 url을 이용해 fetch를 하는데 ‘fetch has been blocked by cors policy’라는 오류 발생..인터넷에 처보니 CORS(Cross-Origin Resource Sharing) 이라고 하는데 이것은 추가 http헤더를 사용하며, 한 출처에서 실행 중인 웹 어플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제 라고 한다.결국 api를 사용하는 웹어플리케이션은 자신의 출처와 동일한 리소스만 불러올 수 있는것인데 이 해결방법을 구글링 해보니프록시서버라는 중계서버로 우회해서 api를 호출하면 해결이 된다고 한다.api호출 url앞에 ‘https://cors-anywhere.herokuapp.com/’ 를 추가해서 fetch하면 잘 동작한다. 백엔드 쪽에서 CORS오류를 해결할 수 있지만프론트 쪽에서는 딱히 방법이 없어 프록시서버로 우회해서 접속하였다.모바일 화면검색기능도 구현했고, 모바일 버전에서는 메뉴바도 생기게 구현그리고 마지막 page navigation도 구현하여 웹페이지 완성javascript를 공부할겸 처음 만든 웹페이지. javascript로 api 불러오는거를 통해 웹페이지를 조금더 동적으로 만들수 있었고 만드는 과정에서 REST api에 관하여 백엔드와 프론트간에 통신에 있어 주고 받는 데이터 형식에 대해 많은 공부를 하였다. 또한 bootstrap을 이용하면서 웹페이지를 꾸몄고 html과 css를 써가면서 사용자UI에 신경을 많이 썼지만 전체적인 css나 웹페이지에 보여지는 컴포넌트들이 좀 심심한느낌도 있어 화면구성에 어려움을 느꼈다. 또한 화면을 구성할때 사용자에게 이해도와 흥미를 높이기 위해 UI를 구성하는 연습과 생각이 필요하고 느꼈다." }, { "title": "[프로젝트] Avoiding_bullets_game", "url": "/posts/avoiding_bullets_game/", "categories": "Project", "tags": "java", "date": "2022-01-08 00:00:00 +0800", "snippet": "자바 GUI 그래픽과 스레드를 이용해서 만든 총알을 피하는 게임Github 바로가기!게임설명게임이 시작되면 총알이 무작위로 날라 다니고 키보드 방향키로 플레이어를 상하좌우로 움직일 수 있으며 총알과 부딪히지 않고 계속 살아남아 점수를 획득하는 방식이다. 만약 총알에 부딪힌 경우 종료된다는 메시지와 함께 게임이 종료 된다. 종료되는 메세지에 점수가 표시...", "content": "자바 GUI 그래픽과 스레드를 이용해서 만든 총알을 피하는 게임Github 바로가기!게임설명게임이 시작되면 총알이 무작위로 날라 다니고 키보드 방향키로 플레이어를 상하좌우로 움직일 수 있으며 총알과 부딪히지 않고 계속 살아남아 점수를 획득하는 방식이다. 만약 총알에 부딪힌 경우 종료된다는 메시지와 함께 게임이 종료 된다. 종료되는 메세지에 점수가 표시되어 얼마동안 살아남았는지도 확인할 수 있습니다. 그리고 확인버튼을 누르면 다시 게임을 시작할 수 있고, 사용자가 그만하고 싶을 때는 x를 눌러 게임을 종료할 수 있다.JAVA 소스코드package mini_project;import java.awt.*;import java.awt.event.*;import java.util.*;import javax.swing.*;//총알 구현 클래스(총알 좌표와 속도 변수 생성)class Ball { public static final int SIZE = 0;\tint x = 0; int y = 0; int[] speed = {1, 2, 3, 4, 5}; int xSp, ySp; Random rd; Ball(int x, int y) { this.x = x; this.y = y; rd = new Random(); int s = rd.nextInt(5); xSp = speed[s]; ySp = speed[s]; }}public class Game extends JFrame implements Runnable{\tImageIcon ib= new ImageIcon(\"images/back.png\");//배경이미지\tImage imgb =ib.getImage();\t\tImageIcon ia= new ImageIcon(\"images/airplane.png\"); //플레이어 이미지(비행기)\tImage ap =ia.getImage();\t//플레이어 좌표\tint xpos=100;\tint ypos=100;\t\tImage bufferImage;//화면이 깜빡거리는 것을 없애기위해 따로 별도의 가상이미지공간에 그리기 위한 이미지 객체\tGraphics ge;\tArrayList balls = new ArrayList();//총알을 저장하기 위한 컬렉션\t\t\tint TOP=0; int BOTTOM = 400; int LEFT=0; int RIGHT = 500; boolean isRunning= true; private boolean isKeyUp, isKeyDown, isKeyLeft, isKeyRight = false; int count=0; \tpublic Game() {\t\tsetTitle(\"mini_project\");\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\t\tsetSize(500,400);\t\tsetVisible(true);\t\t\t\taddKeyListener(new KeyAdapter() {\t\t\t\t\t\t@Override\t\t\tpublic void keyPressed(KeyEvent e) {\t\t\t\tswitch(e.getKeyCode()) {\t\t\t\t \tcase KeyEvent.VK_UP:\t\t isKeyUp = true;\t\t break;\t\t case KeyEvent.VK_DOWN:\t\t isKeyDown = true;\t\t break;\t\t case KeyEvent.VK_LEFT:\t\t isKeyLeft = true;\t\t break;\t\t case KeyEvent.VK_RIGHT:\t\t isKeyRight = true;\t\t break;\t\t\t\t}\t\t\t}\t\t\t@Override\t\t\tpublic void keyReleased(KeyEvent e) {\t\t\t\tswitch (e.getKeyCode()) { \t \tcase KeyEvent.VK_UP:\t \t\tisKeyUp = false;\t \t\tbreak;\t \tcase KeyEvent.VK_DOWN:\t \tisKeyDown = false;\t \tbreak;\t \tcase KeyEvent.VK_LEFT:\t \t\tisKeyLeft = false;\t \t\tbreak;\t \tcase KeyEvent.VK_RIGHT:\t \t\tisKeyRight = false;\t \t\tbreak;\t\t\t\t}\t\t\t}\t\t});\t}\t\t@Override\tpublic void paint(Graphics g) {\t\tbufferImage = createImage(500,400); //가상의 이미지 만들기\t\tge=bufferImage.getGraphics(); //가상의 이미지에 그려 repaint()로 인한 화면 깜빡임을 없앤다\t\tge.drawImage(imgb,0,0,null);\t\tge.drawImage(ap,xpos,ypos,this);\t\t\t\tge.setColor(Color.RED); int size = balls.size(); for (int i = 0; i &lt; size; i++) { Ball b = (Ball) balls.get(i); ge.fillOval(b.x, b.y,10, 10); //총알을 bufferimage에 그린다 } update(g); \t}\t //repaint()를 호출하게 되면 update()-&gt;paint()순으로 처리 되기 떄문에 update를 오버라이드 해준다.\t@Override\tpublic void update(Graphics g) {\t\tg.drawImage(bufferImage, 0, 0, this);\t}\t\t\t@Override\tpublic void run() {\t\tnew BallGenerator().start(); //총알의 위치를 랜덤으로 지정해주는 쓰레드 실행\t\twhile(isRunning) {\t\t\ttry { Thread.sleep(15);\t \t } catch (Exception e){\t e.printStackTrace();\t }\t\t\t\t\t\ttakeBallsOutFromArray(); //총알이 프레임 바깥으로 나갔을때의 처리와 속도 조정\t\t\tmovePlayer(); // 플레이어 움직임\t\t\tPlayerBallBumped(); //플레이어와 총알이 부딪힐떄의 처리\t\t\trepaint(); //다시그리기\t\t\tcount++; //점수측정을 위해 count변수로 측정 }\t\t\t\t\t\t\t}\t//총알의 위치를 랜덤으로 지정해주는 쓰레드\tclass BallGenerator extends Thread { \t\t@Override\t\tpublic void run() {\t\t\t int x, y;\t\t while (true) {\t\t x = (int) (Math.random()* (RIGHT - Ball.SIZE));\t\t y = (int) (Math.random()* (BOTTOM - Ball.SIZE));\t\t \t\t \t\t \t\t balls.add(new Ball(x, y));\t\t try {\t\t Thread.sleep(700);\t\t } catch (Exception e) {\t\t \t\t\t\t }\t\t }\t\t}\t \t}\t\t//총알이 프레임 바깥으로 나갔을떄의 위치 조정과 총알의 속도 조정\t private void takeBallsOutFromArray() {\t int size = balls.size();\t for (int i = 0; i &lt; size; i++) {\t Ball b = (Ball) balls.get(i); \t b.x += b.xSp;\t b.y += b.ySp;\t if (b.y &lt;= TOP) {\t b.y = TOP;\t b.ySp = -b.ySp; //속도를 -로 바꿈\t }\t if (b.y &gt;= BOTTOM) {\t b.y = BOTTOM;\t b.ySp = -b.ySp;\t }\t if (b.x &lt;= LEFT) {\t b.x = LEFT;\t b.xSp = -b.xSp;\t }\t if (b.x &gt;= RIGHT) {\t b.x = RIGHT;\t b.xSp = -b.xSp;\t }\t }\t }\t //키보드 방향키 누릉때 각 방향의 좌표 5만큼 이동 \t private void movePlayer() {\t if (isKeyUp) {\t ypos -= 5;\t }\t if (isKeyDown) {\t ypos += 5;\t }\t if (isKeyLeft) {\t xpos -= 5;\t }\t if (isKeyRight) {\t xpos += 5;\t }\t }\t \t //총알이랑 플레이어가 부딪혔을떄의 처리 메소드\t private void PlayerBallBumped() {\t int size = balls.size(); \t \t for (int i = 0; i &lt; size; i++) { \t Ball b = (Ball) balls.get(i);\t int Circlex=b.x;\t int Circley=b.y;\t \t //총알의 면적을 10*10 사각형이라고 가정하고 이 좌표에 플레이어가 있다면 충돌했다고 작성\t if(xpos&lt;=Circlex+10 &amp;&amp; Circlex-10&lt;=xpos &amp;&amp; ypos&lt;=Circley+10 &amp;&amp; Circley-10&lt;=ypos) {\t \tisRunning = false;\t this.setVisible(false);\t this.dispose(); //해당프레임만종료\t JOptionPane.showMessageDialog(this, \"GameOver\", \"점수: \"+count+\"점\", JOptionPane.ERROR_MESSAGE);\t new Game();\t Thread th= new Thread(new Game());\t \t\tth.start(); \t} \t}\t }\t\t \t\t\tpublic static void main(String[] args) {\t\tnew Game();\t\tThread th= new Thread(new Game());\t\tth.start();\t\t\t}}게임모습느낀점자바를 배우고 문법과 기능들을 구현하기 위해 간단한 게임을 만들어 보았다.그래픽과 스레드는 나한테 많이 생소하여 코드 작성하는데 어려웠다. 간단한 게임에도 불구하고 플레이어 움직임, 총알이 날라 다니는 모습, 플레이어와 총알이 부딪혔을 때의 이벤트 처리 등 하나하나 코드로 작성해야되서 조금 복잡하기도 하고 아직 프로그래밍을 할 때 객체지향적으로 생각하는게 좀 어렵다. 객체지향적으로 코드를 작성하기 위해 공부를 많이 해야함을 느꼈다." }, { "title": "[프로젝트] bicycle_monitoring_system", "url": "/posts/bicycle_monitoring_system/", "categories": "Project", "tags": "python, raspberrypi, javascript", "date": "2022-01-06 00:00:00 +0800", "snippet": "라즈베리파이를 이용하여 사용자의 자전거가 도난당하지 않게끔 자전거를 실시간으로 모니터링 한다.Github 바로가기!주요 사용 기술 flask (python famework) Mosquitto(MQTT) OpenCV javascript작품개요사용자의 자전거가 도난 당하지 않게 자전거를 모니터링 하는 장치이다. 자전거 앞에 초음파센서가 달린 라즈베...", "content": "라즈베리파이를 이용하여 사용자의 자전거가 도난당하지 않게끔 자전거를 실시간으로 모니터링 한다.Github 바로가기!주요 사용 기술 flask (python famework) Mosquitto(MQTT) OpenCV javascript작품개요사용자의 자전거가 도난 당하지 않게 자전거를 모니터링 하는 장치이다. 자전거 앞에 초음파센서가 달린 라즈베리파이를 두어 자전거가 있는 곳까지의 거리 값을 측정한다. 만약 초음파 센서의 거리 값이 계속 증가하여 기존 거리 값보다 높아졌다면 자전거가없어졌다는 걸로 간주하여 그 순간 라즈베리파이에 연결된 카메라로 자전거 주변을 촬영해서 웹페이지에 전송한다. 그러면 사용자는 자전거가 도난 당했다는 알림과 함께 웹페이지에서 자전거 주변의 촬영된 사진을 확인 할 수 있다. 또한, 훔쳐간 범인의 얼굴을 쉽게 확인할 수 있도록 얼굴인식기능을 이용하여 카메라에 범인의 얼굴이 찍히면 쉽게 범인의 얼굴을 알 수 있게 사진을 찍는다. 그리고 거리가 멀어졌을 때 자전거가 도난당한 것을 알리기 위해 led로 점등하고, 언제 도난 당했는지 사진이 찍힌 날짜와 시간을 웹페이지에 표시하고, 사용자는 언제 자전거가 없어졌는지 알 수 있게 자전거를 실시간으로 모니터링하여 내 자전거를 안전하게 관리한다.시스템 구조사용한 부품 라즈베리파이 1대 카메라 1대 Led 1개 초음파센서 1대사용한 회로도 번호 GPIO 핀 LED = 6번 Trig = 20번 Echo= 16번회로도소프트웨어총 7개로 설계 (파이썬 코드 4개) Circuit.py (초음파센서를 제어하는 파이썬코드) Camera.py (카메라를 제어하는 파이썬코드) Mqtt.py (mosquitto를 통해 웹브라우저와 통신하는 파이썬코드) App.py (웹 브라우저로부터 접속과 요청을 받아 처리하는 플라스크 앱) Mqtt.html (사용자에게 라즈베리파이에서 측정한 센서값들을 보여주기 위한 html 코드) Mqttio.js (측정된 값을 웹페이지에서 실시간으로 확인하기 위한 javascrpit) Face.js (카메라로 찍은 사진을 얼굴인식을 하기 위한 javascript) 1. Circuit.pyimport timeimport RPi.GPIO as GPIO# 초음파 센서를 대한 전역 변수 선언 및 초기화trig = 20echo = 16GPIO.setmode(GPIO.BCM)#BCM모드로 설정GPIO.setwarnings(False)GPIO.setup(trig, GPIO.OUT) #초음파센서 20번을 출력선으로 지정GPIO.setup(echo, GPIO.IN) #초음파센서 16번을 입력선으로 지정GPIO.output(trig, False)led = 6 # LED를 사용할 핀번호 GPIO6 의미GPIO.setup(led, GPIO.OUT) # GPIO 6번 핀을 출력 선으로 지정def measureDistance(): global trig, echo time.sleep(0.5) GPIO.output(trig, True) # 신호 1 발생 time.sleep(0.00001) # 짧은 시간을 나타내기 위함 GPIO.output(trig, False) # 신호 0 발생 while(GPIO.input(echo) == 0): pulse_start = time.time() # 신호 1을 받았던 시간 while(GPIO.input(echo) == 1): pulse_end = time.time() # 신호 0을 받았던 시간 pulse_duration = pulse_end - pulse_start return 340*100/2*pulse_durationif(__name__ == \"__main__\"): while(True): print(\"물체와의거리는 %f\" %measureDistance())def controlLED(led = 6, onOff =0 ): # led 번호의 핀에 onOff(0/1) 값 출력GPIO.output(led, onOff)초음파센서로 자전거와의 거리를 측정하는 measureDistance 함수와 LED 불빛이 켜지고 꺼질수 있는 함수를 포함하는 코드2. Camera.pyimport os; import io; import timeimport picameraimport cv2; import numpy as npfileName = \"\"stream = io.BytesIO()camera =picamera.PiCamera()camera.start_preview()camera.resolution = (320, 240)time.sleep(1)def takePicture() : global fileName, stream, camera stream.seek(0) #파일포인터를 처음으로 옮김 stream.truncate() #파일을 비우는 작업 camera.capture(stream, format='jpeg', use_video_port=True) #사진을 찍음(화질은 선명하게 설정하고 확장자는 jpeg로 stream에 저장) data = np.frombuffer(stream.getvalue(), dtype=np.uint8) #바이너리 파일인 stream을 읽어서 data변수에 저장 image = cv2.imdecode(data, 1) #얼굴인식을 위해 Binary 형태인 data를 읽은 다음 컬러이미지로 decode하기 haar = cv2.CascadeClassifier('./haarCascades/haar-cascade-files-master/haarcascade_frontalface_default.xml') #객체 감지를 위한 CascadeClassifier 클래스를 이용 image_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) #이미지를 회색으로 처리 faces = haar.detectMultiScale(image_gray,1.1,3) #입력 이미지에서 다양한 크기의 개체(얼굴)를 감지하고 감지된 얼굴(객체)은 사각형목록으로 반환 for x, y, w, h in faces: cv2.rectangle(image, (x, y), (x + w, y + h), (255, 0, 0), 2) #이미지에 (x+y)와 (x+w, y+h)를 꼭짓점으로 하는사각형 그리기 takeTime = time.time() #시간을 부동소수점으로 표현 fileName = \"./static/%d.jpg\" %(takeTime*10) cv2.imwrite(fileName, image) #얼굴인식된 이미지 저장 return fileNameif __name__ == '__main__' : while(True): name = takePicture() print(\"fname= %s\" % name)파이카메라로 카메라를 제어하고 OpenCV를 이용해 얼굴인식이 가능하도록 만든 python3. Mqtt.py# publisherimport timeimport paho.mqtt.client as mqttimport circuit # 초음파 센서 입력 모듈 임포트import mycamerabroker_ip = \"localhost\" # 현재 이 컴퓨터를 브로커로 설정client = mqtt.Client()client.connect(broker_ip, 1883)client.loop_start()while(True): d= circuit.measureDistance() t=time.localtime() print(\"측정거리는 %.2fcm 입니다\"%d) if(d&gt;30): img=mycamera.takePicture() #자전거와 초음파센서까지의 거리가 30cm이상이면 사진을 찍음 client.publish(\"image\", img, qos=0) #broker에게 image라는 토픽으로 publish circuit.controlLED(onOff=1) #자전거와 초음파센서까지의 거리가 30cm이상이면 LED ON else: circuit.controlLED(onOff=0) #거리가 다시 30cm이하면 LED끄기client.loop_stop()client.disconnect()지속적으로 자전거와의 거리를 측정하고 만약에 거리가 30cm가 넘으면 사진을 찍어 broker에게 image를 publish한다.또한 거리가 30cm가 넘으면 되면 LED 불빛이 점등되고, 다시 30cm이하가 되면 LED 불빛을 끄게 만든다.4. app.pyfrom flask import Flask, render_template, requestapp = Flask(__name__)@app.route('/')def index(): return render_template(\"mqtt.html\")if __name__ == \"__main__\": app.run(host='0.0.0.0', port=8080)파이썬 프레임워크인 flask를 이용하여 웹브라우저의 요청에 응답하는 코드5. mqtt.html&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;        &lt;meta charset=\"utf-8\"&gt;    &lt;title&gt;Mini_Project&lt;/title&gt;    &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.2/mqttws31.min.js\" type=\"text/javascript\"&gt;&lt;/script&gt;    &lt;script src=\"/static/mqttio.js\" type=\"text/javascript\"&gt;&lt;/script&gt;    &lt;script src=\"/static/face.js\" type=\"text/javascript\"&gt;&lt;/script&gt;    &lt;script&gt;           window.addEventListener(\"load\", function () {                // http://224..129:8080/에서 224...의 IP만 끊어내는 코드                var url = new String(document.location);                ip = (url.split(\"//\"))[1]; // ip = \"224...:8080/\"                ip = (ip.split(\":\"))[0]; // ip = \"224...\"                document.getElementById(\"broker\").value = ip           });      &lt;/script&gt;    &lt;style&gt;        canvas {background-color:lightblue}    &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style =\"text-align:center\"&gt;        &lt;h1&gt;자전거 도난 방지 시스템&lt;/h1&gt; &lt;/div&gt;        &lt;hr&gt; &lt;div style =\"text-align:center\"&gt;                &lt;form id=\"connection-form\"&gt;                        &lt;b&gt;관리자 IP:&lt;/b&gt;                        &lt;input id=\"broker\" type=\"text\" name=\"broker\" value=\"\"&gt;&lt;br&gt;                        &lt;input type=\"button\" onclick=\"startConnect()\" value=\"관리시작\"&gt;                        &lt;input type=\"button\" onclick=\"startDisconnect()\" value=\"관리종료\"&gt;                &lt;/form&gt; &lt;/div&gt;         &lt;hr&gt; &lt;div style=\"text-align:center\"&gt;         &lt;form id=\"subscribe-form\"&gt; &lt;p id=\"sub\"&gt;&lt;/p&gt;         &lt;/form&gt;         &lt;canvas id=\"myCanvas\" width=\"320\" height=\"240\"&gt;&lt;/canvas&gt;&lt;br&gt; &lt;input type=\"button\" onclick=\"unsubscribe('image')\" value=\"확인\"&gt; &lt;/div&gt; &lt;hr&gt; &lt;p&gt;&lt;strong&gt;&lt;font size=\"4\"&gt;●이력관리●&lt;/font&gt;&lt;/strong&gt;&lt;/p&gt;         &lt;div id=\"messages\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;사용자가 실시간으로 자전거를 모니터링 할 수 있게 html로 만든 웹페이지6. mqttio.jsvar port = 9001 // mosquitto의 디폴트 웹 포트var client = null; // null이면 연결되지 않았음var time=null; //날짜를 저장하기 위한 변수var first=null; //처음 찍힌 날짜를 저장하기 위한 변수var month=null; //처음 찍힌 날짜중 월을 저장하기 위한 변수var tmonth=null; // 몇월달인지를 저장하기 위한 변수function startConnect() { // 접속을 시도하는 함수 clientID = \"clientID-\" + parseInt(Math.random() * 100); // 랜덤한 사용자 ID 생성 // 사용자가 입력한 브로커의 IP 주소와 포트 번호 알아내기 broker = document.getElementById(\"broker\").value; // 브로커의 IP 주소 // id가 message인 DIV 객체에 브로커의 IP와 포트 번호 출력 // MQTT 메시지 전송 기능을 모두 가징 Paho client 객체 생성 client = new Paho.MQTT.Client(broker, Number(port), clientID); // client 객체에 콜백 함수 등록 client.onConnectionLost = onConnectionLost; // 접속이 끊어졌을 때 실행되는 함수 등록 client.onMessageArrived = onMessageArrived; // 메시지가 도착하였을 때 실행되는 함수 등록 // 브로커에 접속. 매개변수는 객체 {onSuccess : onConnect}로서, 객체의 프로퍼틴느 onSuccess이고 그 값이 onConnect. // 접속에 성공하면 onConnect 함수를 실행하라는 지시 client.connect({ onSuccess: onConnect, });}var isConnected = false;// 브로커로의 접속이 성공할 때 호출되는 함수function onConnect() { isConnected = true; document.getElementById(\"messages\").innerHTML += '&lt;span&gt;&lt;strong&gt;*자전거 모니터링을 시작합니다.&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;'; topic = \"image\" // 토픽으로 subscribe 하고 있음을 id가 message인 DIV에 출력 document.getElementById(\"messages\").innerHTML += '&lt;span&gt;&lt;strong&gt;*자전거가 없어지면 사진과 아래 이력들을 확인하세요.&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;'; document.getElementById(\"sub\").innerHTML = '&lt;span&gt;&lt;strong&gt;자전거가 안전하게 보관중&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;'; client.subscribe(topic, qos = 0); // 브로커에 subscribe}function unsubscribe(topic) { if(client == null || isConnected != true) return; // 토픽으로 subscribe 하고 있음을 id가 message인 DIV에 출력 document.getElementById(\"sub\").innerHTML += '&lt;span&gt;&lt;strong&gt;'+first.getFullYear()+'/'+first.getMonth()+'/'+month+'/'+first.getHours()+'시'+first.getMinutes()+'분'+first.getSeconds()+'초에 없어졌습니다.'+'&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;'; document.getElementById(\"sub\").innerHTML += '&lt;span&gt;&lt;strong&gt;찍은 사진들은 static폴더에 저장되었으니 확인해주십시오.'+ '&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;'; client.unsubscribe(topic, null); // 브로커에 subscribe}// 접속이 끊어졌을 때 호출되는 함수function onConnectionLost(responseObject) { // 매개변수인 responseObject는 응답 패킷의 정보를 담은 개체 document.getElementById(\"messages\").innerHTML += '&lt;span&gt; 접속을 끊고&lt;/span&gt;&lt;br/&gt;'; if (responseObject.errorCode !== 0) { document.getElementById(\"messages\").innerHTML += '&lt;span&gt;오류 : ' + + responseObject.errorMessage + '&lt;/span&gt;&lt;br/&gt;'; }}// 메시지가 도착할 때 호출되는 함수function onMessageArrived(msg) { // 매개변수 msg는 도착한 MQTT 메시지를 담고 있는 객체 console.log(\"onMessageArrived: \" + msg.payloadString); // 토픽 image가 도착하면 payload에 담긴 파일 이름의 이미지 그리기 if(msg.destinationName == \"image\") { drawImage(msg.payloadString); // 메시지에 담긴 파일 이름으로 drawImage() 호출. drawImage()는 웹 페이지에 있음 } if(time==null){ //처음 사진이 찍힌 날짜 저장하기 위한 조건문 first=new Date(); time=new Date(); month=first.getMonth()+1; tmonth=time.getMonth()+1; } else{ //처음 찍힌것이 아니라면 관리이력에 표시하기 위한 시간저장 time=new Date(); tmonth=time.getMonth()+1; } document.getElementById(\"sub\").innerHTML = '&lt;span&gt;&lt;strong&gt; ' + '자전거가 없어짐!!' + '&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;'; // 도착한 메시지 출력 document.getElementById(\"messages\").innerHTML += '&lt;span&gt;'+'자전거없어짐!!' + ' | ' + '사진을 확인하세요!'+' | '+' 시각 : '+time.getFullYear()+'/'+tmonth+'/'+time.getDate()+'/'+time.getHours()+'시'+time.getMinutes()+'분'+time.getSeconds()+'초' +'&lt;/span&gt;&lt;br/&gt;';}// disconnection 버튼이 선택되었을 때 호출되는 함수function startDisconnect() { client.disconnect(); // 브로커에 접속 해제 document.getElementById(\"messages\").innerHTML += '&lt;span&gt;모니터링을 종료합니다 &lt;/span&gt;&lt;br/&gt;';}mqtt broker와 연결하는 함수, broker에게 topic이라는 주제로 subscribe 하는 함수, 자전거가 도난당했을때의 주변 촬영사진을 받아 웹페이지에 나타내는 함수로 구성했다.7. face.js// 전역 변수 선언var canvas;var context;var img;// load 이벤트 리스너 등록. 웹페이지가 로딩된 후 실행window.addEventListener(\"load\", function() { canvas = document.getElementById(\"myCanvas\"); context = canvas.getContext(\"2d\"); img = new Image(); img.onload = function () { context.drawImage(img, 0, 0); // (0,0) 위치에 img의 크기로 그리기 }});// drawImage()는 \"image' 토픽이 도착하였을 때 onMessageArrived()에 의해 호출된다.function drawImage(imgUrl) { // imgUrl은 이미지의 url img.src = imgUrl; // img.onload에 등록된 코드에 의해 그려짐}var isImageSubscribed = false;function recognize() { if(!isImageSubscribed) { subscribe(\"image\"); // 토픽 image 등록 }}사진을 받아 웹페이지에 얼굴이 찍힌 사진들은 얼굴에 사각형모양을 그려서 웹페이지에 나타냈다.실행 과정초기화면호스트 ip주로 접속한 웹페이지 모습이다.관리시작 버튼을 누른 화면 &amp; 자전거와의 거리측정관리시작을 누르면 이력관리 밑에 안내설명이 나오고 mqtt.py를 실행한 모습이다.만약 자전거가 도난 당했을 경우 웹페이지자전거가 도난 당했을 경우 초음파센서의 거리측정 값이 증가되면서 30cm이상 될 경우 사진을 찍어 웹페이지에 지속적으로 나타나는 화면이다.이력관리 화면도난 당했을시 웹페이지에서 사진을 받으면서 이력관리에 언제 없어졌는지 시간도 함께 표시되어 기록한다.얼굴이 찍혔을 경우의 사진이 전송된 웹페이지만약 범인의 얼굴이 찍혔을 경우 사진에 얼굴인식기능을 할 수 있게 구현하여 사용자가 범인의 얼굴을 더 명확하게 볼 수 있게끔 소스코드를 작성했다.확인 버튼을 누른 화면사용자가 자전거가 도난당한 것을 인지하고 확인버튼을 누르면 언제 없어졌는지 그리고 static폴더에 찍힌 사진들이 저장됐다는 메시지와 함께 자전거 주변의 사진전송을 멈출 수 있다.static 폴더에 저장된 사진들증거로 남기기 위해 사진을 static폴더에 저장하여 보관할 수 있다.느낀점컴퓨터공학을 전공하고 나서 처음으로 만든 프로젝트이다. 비록 간단한 프로젝트지만 이 프로젝트를 하면서 주제선정부터 코드작성, 발표준비까지 정말 많은 시간을 들이면서 준비 했었다. 특히 나는 만드는 과정 중에 어떻게 하면 이 작품을 사용하는 사용자가더 유용하게 쓰일 수 있을지에 대해 고민하면서 제작을 했었다. 이 작품을 만들고 나름 자신감도얻었고 다 만들었을 때의 뿌듯함도 느꼈다. 그치만 결국 프로그램을 완성해도 사용자에게 정보를 시각적으로 잘 전달할려면 웹페이지를 잘 꾸며서 보여줘야 된다고 생각했고, 웹페이지를 제작하는데 어려움을 느꼈다. html&amp;css&amp;javascript를 공부해서 보완해야겠다." } ]
